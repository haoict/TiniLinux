diff --git a/Documentation/devicetree/bindings/bus/allwinner,sun50i-a64-de2.yaml b/Documentation/devicetree/bindings/bus/allwinner,sun50i-a64-de2.yaml
index 9845a187b..317a27cf5 100644
--- a/Documentation/devicetree/bindings/bus/allwinner,sun50i-a64-de2.yaml
+++ b/Documentation/devicetree/bindings/bus/allwinner,sun50i-a64-de2.yaml
@@ -24,11 +24,14 @@ properties:
     oneOf:
       - const: allwinner,sun50i-a64-de2
       - items:
-          - const: allwinner,sun50i-h6-de3
+          - enum:
+              - allwinner,sun50i-h6-de3
+              - allwinner,sun50i-h616-de33
           - const: allwinner,sun50i-a64-de2
 
   reg:
-    maxItems: 1
+    minItems: 1
+    maxItems: 3
 
   allwinner,sram:
     description:
diff --git a/Documentation/devicetree/bindings/display/allwinner,sun8i-a83t-de2-mixer.yaml b/Documentation/devicetree/bindings/display/allwinner,sun8i-a83t-de2-mixer.yaml
index b75c1ec68..274f5e632 100644
--- a/Documentation/devicetree/bindings/display/allwinner,sun8i-a83t-de2-mixer.yaml
+++ b/Documentation/devicetree/bindings/display/allwinner,sun8i-a83t-de2-mixer.yaml
@@ -24,9 +24,11 @@ properties:
       - allwinner,sun50i-a64-de2-mixer-0
       - allwinner,sun50i-a64-de2-mixer-1
       - allwinner,sun50i-h6-de3-mixer-0
+      - allwinner,sun50i-h616-de33-mixer-0
 
   reg:
-    maxItems: 1
+    minItems: 1
+    maxItems: 3
 
   clocks:
     items:
@@ -61,6 +63,23 @@ properties:
     required:
       - port@1
 
+allOf:
+  - if:
+      properties:
+        compatible:
+          enum:
+            - allwinner,sun50i-h616-de33-mixer-0
+
+    then:
+      properties:
+        reg:
+          maxItems: 3
+
+    else:
+      properties:
+        reg:
+          maxItems: 1
+
 required:
   - compatible
   - reg
diff --git a/Documentation/devicetree/bindings/display/panel/panel-mipi.yaml b/Documentation/devicetree/bindings/display/panel/panel-mipi.yaml
new file mode 100644
index 000000000..d70cf0063
--- /dev/null
+++ b/Documentation/devicetree/bindings/display/panel/panel-mipi.yaml
@@ -0,0 +1,121 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/display/panel/panel-mipi.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Generic MIPI-DSI/DPI Panels Requiring Initialization
+
+maintainers:
+  - Hironori KIKUCHI <kikuchan98@gmail.com>
+
+description: This is a binding for generic MIPI-DSI/DPI panels that require
+  initialization with a simple command sequence before use.
+
+properties:
+  compatible:
+    oneOf:
+      - items:
+          - enum:
+              # Unknown 3.35" 720x480 24-bit IPS LCD panel
+              # used in Anbernic RG 34XX
+              - anbernic,rg34xx-panel
+              # Unknown 4.00" 640x480 24-bit IPS LCD panel (YLM-LBV0400001X-V1)
+              # used in Anbernic RG40XX series
+              - anbernic,rg40xx-panel
+              # Unknown 3.95" 720x720 24-bit IPS LCD panel (YLM-LBN0395004H-V1)
+              # used in Anbernic RG CubeXX
+              - anbernic,rgcubexx-panel
+          - const: panel-mipi-dpi-spi
+      - items:
+          - enum:
+              # HOTHMI TFT-H028B23VGIST7G40-V1 2.80" 480x640 TFT LCD panel
+              - hothmi,tft-h028b23vgist7g40-v1
+          - const: panel-mipi-dsi
+
+  reg:
+    description: DSI / SPI channel used by that screen
+    maxItems: 1
+
+  power-supply: true
+
+  io-supply:
+    description: I/O system regulator.
+      No need to set if this is the same as polwer-supply.
+
+  dc-gpios:
+    maxItems: 1
+    description: Controller data/command selection (D/CX) in 4-line SPI mode.
+      If not set, the controller is in 3-line SPI mode.
+      Disallowed for DSI.
+
+  port: true
+  reset-gpios: true
+
+  backlight: true
+
+required:
+  - compatible
+  - reg
+
+allOf:
+  - $ref: panel-common.yaml#
+  - if:
+      properties:
+        compatible:
+          contains:
+            enum:
+              - panel-mipi-dpi-spi
+    then:
+      # SPI mode
+      $ref: /schemas/spi/spi-peripheral-props.yaml#
+
+  - if:
+      properties:
+        compatible:
+          contains:
+            enum:
+              - panel-mipi-dsi
+    then:
+      # DSI mode
+      properties:
+        dc-gpios: false
+
+unevaluatedProperties: false
+
+examples:
+  - |
+    dsi {
+        #address-cells = <1>;
+        #size-cells = <0>;
+
+        panel@0 {
+            compatible = "hothmi,tft-h028b23vgist7g40-v1", "panel-mipi-dsi";
+            reg = <0>;
+
+            port {
+                mipi_in_panel: endpoint {
+                    remote-endpoint = <&mipi_out_panel>;
+                };
+            };
+        };
+    };
+  - |
+    #include <dt-bindings/gpio/gpio.h>
+
+    spi {
+        #address-cells = <1>;
+        #size-cells = <0>;
+
+        panel@0 {
+            compatible = "anbernic,rg40xx-panel", "panel-mipi-dpi-spi";
+            reg = <0>;
+
+            spi-max-frequency = <40000000>;
+
+            dc-gpios = <&gpio 24 GPIO_ACTIVE_HIGH>;
+            reset-gpios = <&gpio 25 GPIO_ACTIVE_LOW>;
+
+            backlight = <&backlight>;
+        };
+    };
diff --git a/Documentation/devicetree/bindings/vendor-prefixes.yaml b/Documentation/devicetree/bindings/vendor-prefixes.yaml
index 5d2a7a8d3..b9f6146f3 100644
--- a/Documentation/devicetree/bindings/vendor-prefixes.yaml
+++ b/Documentation/devicetree/bindings/vendor-prefixes.yaml
@@ -660,6 +660,8 @@ patternProperties:
     description: Shenzhen Hope Microelectronics Co., Ltd.
   "^hoperun,.*":
     description: Jiangsu HopeRun Software Co., Ltd.
+  "^hothmi,.*":
+    description: Hotdisplay Technology Co.Ltd
   "^hp,.*":
     description: Hewlett Packard Inc.
   "^hpe,.*":
diff --git a/arch/arm64/boot/dts/allwinner/sun50i-h616-cpu-opp.dtsi b/arch/arm64/boot/dts/allwinner/sun50i-h616-cpu-opp.dtsi
index dd10aaf47..384cbffae 100644
--- a/arch/arm64/boot/dts/allwinner/sun50i-h616-cpu-opp.dtsi
+++ b/arch/arm64/boot/dts/allwinner/sun50i-h616-cpu-opp.dtsi
@@ -55,13 +55,6 @@ opp-1008000000 {
 			opp-supported-hw = <0x3f>;
 		};
 
-		opp-1032000000 {
-			opp-hz = /bits/ 64 <1032000000>;
-			opp-microvolt = <900000>;
-			clock-latency-ns = <244144>; /* 8 32k periods */
-			opp-supported-hw = <0x20>;
-		};
-
 		opp-1104000000 {
 			opp-hz = /bits/ 64 <1104000000>;
 			opp-microvolt-speed0 = <1000000>;
@@ -88,7 +81,7 @@ opp-1320000000 {
 			opp-hz = /bits/ 64 <1320000000>;
 			opp-microvolt = <1100000>;
 			clock-latency-ns = <244144>; /* 8 32k periods */
-			opp-supported-hw = <0x1d>;
+			opp-supported-hw = <0x3d>;
 		};
 
 		opp-1416000000 {
@@ -105,6 +98,7 @@ opp-1512000000 {
 			opp-microvolt-speed5 = <1160000>;
 			clock-latency-ns = <244144>; /* 8 32k periods */
 			opp-supported-hw = <0x2a>;
+			turbo-mode;
 		};
 	};
 };
diff --git a/arch/arm64/boot/dts/allwinner/sun50i-h616.dtsi b/arch/arm64/boot/dts/allwinner/sun50i-h616.dtsi
index ceedae9e3..867689751 100644
--- a/arch/arm64/boot/dts/allwinner/sun50i-h616.dtsi
+++ b/arch/arm64/boot/dts/allwinner/sun50i-h616.dtsi
@@ -7,9 +7,12 @@
 #include <dt-bindings/clock/sun50i-h616-ccu.h>
 #include <dt-bindings/clock/sun50i-h6-r-ccu.h>
 #include <dt-bindings/clock/sun6i-rtc.h>
+#include <dt-bindings/clock/sun8i-de2.h>
+#include <dt-bindings/clock/sun8i-tcon-top.h>
 #include <dt-bindings/reset/sun50i-h616-ccu.h>
 #include <dt-bindings/reset/sun50i-h6-r-ccu.h>
 #include <dt-bindings/thermal/thermal.h>
+#include <dt-bindings/reset/sun8i-de2.h>
 
 / {
 	interrupt-parent = <&gic>;
@@ -94,6 +97,12 @@ l2_cache: l2-cache {
 		};
 	};
 
+	de: display-engine {
+		compatible = "allwinner,sun50i-h6-display-engine";
+		allwinner,pipelines = <&mixer0>;
+		status = "disabled";
+	};
+
 	reserved-memory {
 		#address-cells = <2>;
 		#size-cells = <2>;
@@ -165,6 +174,51 @@ gpu: gpu@1800000 {
 			status = "disabled";
 		};
 
+		bus: bus@1000000 {
+			compatible = "allwinner,sun50i-h616-de33",
+				     "allwinner,sun50i-a64-de2";
+			reg = <0x1000000 0x400000>;
+			allwinner,sram = <&de3_sram 1>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges = <0 0x1000000 0x400000>;
+
+			display_clocks: clock@8000 {
+				compatible = "allwinner,sun50i-h616-de33-clk";
+				reg = <0x8000 0x100>;
+				clocks = <&ccu CLK_DE>, <&ccu CLK_BUS_DE>;
+				clock-names = "mod", "bus";
+				resets = <&ccu RST_BUS_DE>;
+				#clock-cells = <1>;
+				#reset-cells = <1>;
+			};
+
+			mixer0: mixer@100000 {
+				compatible = "allwinner,sun50i-h616-de33-mixer-0";
+				reg = <0x100000 0x100000>,
+				      <0x8100 0x40>,
+				      <0x280000 0x20000>;
+				clocks = <&display_clocks CLK_BUS_MIXER0>,
+					 <&display_clocks CLK_MIXER0>;
+				clock-names = "bus", "mod";
+				resets = <&display_clocks RST_MIXER0>;
+				iommus = <&iommu 0>;
+
+				ports {
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					mixer0_out: port@1 {
+						reg = <1>;
+
+						mixer0_out_tcon_top_mixer0: endpoint {
+							remote-endpoint = <&tcon_top_mixer0_in_mixer0>;
+						};
+					};
+				};
+			};
+		};
+
 		crypto: crypto@1904000 {
 			compatible = "allwinner,sun50i-h616-crypto";
 			reg = <0x01904000 0x800>;
@@ -188,6 +242,11 @@ sram_c: sram@28000 {
 				#address-cells = <1>;
 				#size-cells = <1>;
 				ranges = <0 0x00028000 0x30000>;
+
+				de3_sram: sram-section@0 {
+					compatible = "allwinner,sun50i-a64-sram-c";
+					reg = <0x0000 0x1e000>;
+				};
 			};
 		};
 
@@ -200,6 +259,20 @@ ccu: clock@3001000 {
 			#reset-cells = <1>;
 		};
 
+		pwm: pwm@300a000 {
+			compatible = "allwinner,sun50i-h616-pwm";
+			reg = <0x0300a000 0x400>;
+			clocks = <&ccu CLK_BUS_PWM>,
+				 <&osc24M>,
+				 <&ccu CLK_APB1>;
+			clock-names = "bus", "hosc", "apb";
+			resets = <&ccu RST_BUS_PWM>;
+			#pwm-cells = <0x3>;
+			status = "disabled";
+
+			allwinner,pwm-channels = <6>;
+		};
+
 		dma: dma-controller@3002000 {
 			compatible = "allwinner,sun50i-h616-dma",
 				     "allwinner,sun50i-a100-dma";
@@ -278,6 +351,32 @@ ir_rx_pin: ir-rx-pin {
 				function = "ir_rx";
 			};
 
+			/omit-if-no-ref/
+			lcd0_rgb888_pins: lcd0-rgb888-pins {
+				pins = "PD0", "PD1", "PD2", "PD3",
+				       "PD4", "PD5", "PD6", "PD7",
+				       "PD8", "PD9", "PD10", "PD11",
+				       "PD12", "PD13", "PD14", "PD15",
+				       "PD16", "PD17", "PD18", "PD19",
+				       "PD20", "PD21", "PD22", "PD23",
+				       "PD24", "PD25", "PD26", "PD27";
+				function = "lcd0";
+			};
+
+			/omit-if-no-ref/
+			lvds0_pins: lvds0-pins {
+				pins = "PD0", "PD1", "PD2", "PD3", "PD4",
+				       "PD5", "PD6", "PD7", "PD8", "PD9";
+				function = "lvds0";
+			};
+
+			/omit-if-no-ref/
+			lvds1_pins: lvds1-pins {
+				pins = "PD10", "PD11", "PD12", "PD13", "PD14",
+				       "PD15", "PD16", "PD17", "PD18", "PD19";
+				function = "lvds1";
+			};
+
 			mmc0_pins: mmc0-pins {
 				pins = "PF0", "PF1", "PF2", "PF3",
 				       "PF4", "PF5";
@@ -304,6 +403,12 @@ mmc2_pins: mmc2-pins {
 				bias-pull-up;
 			};
 
+			/omit-if-no-ref/
+			pwm0_pin: pwm0-pin {
+				pins = "PD28";
+				function = "pwm0";
+			};
+
 			/omit-if-no-ref/
 			spi0_pins: spi0-pins {
 				pins = "PC0", "PC2", "PC4";
@@ -708,6 +813,74 @@ codec: codec@5096000 {
 			status = "disabled";
 		};
 
+		ahub_dam_plat:ahub_dam_plat@5097000 {
+			#sound-dai-cells = <0>;
+			/* sound card without pcm for hardware mix setting */
+			compatible	= "allwinner,sunxi-snd-plat-ahub_dam";
+			reg		= <0x05097000 0x1000>;
+			resets		= <&ccu RST_BUS_AUDIO_HUB>;
+			clocks          = <&ccu CLK_AUDIO_CODEC_1X>,
+							  <&ccu CLK_AUDIO_CODEC_4X>,
+							  <&ccu CLK_AUDIO_HUB>,
+							  <&ccu CLK_BUS_AUDIO_HUB>;
+			clock-names     = "clk_pll_audio",
+							  "clk_pll_audio_4x",
+							  "clk_audio_hub",
+							  "clk_bus_audio_hub";
+			status		= "disabled";
+		};
+
+		ahub_dam_mach:ahub_dam_mach {
+			compatible = "allwinner,sunxi-snd-mach";
+			soundcard-mach,name = "ahubdam";
+			status		= "disabled";
+			soundcard-mach,cpu {
+				sound-dai = <&ahub_dam_plat>;
+			};
+			soundcard-mach,codec {
+			};
+		};
+
+		ahub1_plat:ahub1_plat {
+			#sound-dai-cells = <0>;
+			compatible	= "allwinner,sunxi-snd-plat-ahub";
+			apb_num		= <1>;	/* for dma port 4 */
+			dmas		= <&dma 4>, <&dma 4>;
+			dma-names	= "tx", "rx";
+			playback_cma	= <128>;
+			capture_cma	= <128>;
+			tx_fifo_size	= <128>;
+			rx_fifo_size	= <128>;
+
+			tdm_num		= <1>;
+			tx_pin		= <0>;
+			rx_pin		= <0>;
+			status		= "disabled";
+		};
+
+		ahub1_mach_hdmi:ahub1_mach_hdmi {
+			compatible = "allwinner,sunxi-snd-mach";
+			soundcard-mach,name = "HDMI";
+
+			soundcard-mach,format		= "i2s";
+			soundcard-mach,frame-master	= <&ahub1_cpu>;
+			soundcard-mach,bitclock-master	= <&ahub1_cpu>;
+			/* soundcard-mach,frame-inversion; */
+			/* soundcard-mach,bitclock-inversion; */
+			soundcard-mach,slot-num		= <2>;
+			soundcard-mach,slot-width	= <32>;
+
+			ahub1_cpu: soundcard-mach,cpu {
+				sound-dai = <&ahub1_plat>;
+				soundcard-mach,pll-fs	= <4>;
+				soundcard-mach,mclk-fs	= <0>;
+			};
+
+			ahub1_codec: soundcard-mach,codec {
+				sound-dai = <&hdmi>;
+			};
+		};
+
 		usbotg: usb@5100000 {
 			compatible = "allwinner,sun50i-h616-musb",
 				     "allwinner,sun8i-h3-musb";
@@ -868,6 +1041,182 @@ ohci3: usb@5311400 {
 			status = "disabled";
 		};
 
+		hdmi: hdmi@6000000 {
+			#sound-dai-cells = <0>;
+			compatible = "allwinner,sun50i-h616-dw-hdmi",
+				     "allwinner,sun50i-h6-dw-hdmi";
+			reg = <0x06000000 0x10000>;
+			reg-io-width = <1>;
+			interrupts = <GIC_SPI 63 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_HDMI>, <&ccu CLK_HDMI_SLOW>,
+				 <&ccu CLK_HDMI>, <&ccu CLK_HDMI_CEC>,
+				 <&ccu CLK_HDCP>, <&ccu CLK_BUS_HDCP>;
+			clock-names = "iahb", "isfr", "tmds", "cec", "hdcp",
+				      "hdcp-bus";
+			resets = <&ccu RST_BUS_HDMI>, <&ccu RST_BUS_HDCP>;
+			reset-names = "ctrl", "hdcp";
+			phys = <&hdmi_phy>;
+			phy-names = "phy";
+			status = "disabled";
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				hdmi_in: port@0 {
+					reg = <0>;
+
+					hdmi_in_tcon_top: endpoint {
+						remote-endpoint = <&tcon_top_hdmi_out_hdmi>;
+					};
+				};
+
+				hdmi_out: port@1 {
+					reg = <1>;
+				};
+			};
+		};
+
+		hdmi_phy: hdmi-phy@6010000 {
+			compatible = "allwinner,sun50i-h6-hdmi-phy";
+			reg = <0x06010000 0x10000>;
+			clocks = <&ccu CLK_BUS_HDMI>, <&ccu CLK_HDMI_SLOW>;
+			clock-names = "bus", "mod";
+			resets = <&ccu RST_BUS_HDMI_SUB>;
+			reset-names = "phy";
+			#phy-cells = <0>;
+		};
+
+		tcon_top: tcon-top@6510000 {
+			compatible = "allwinner,sun50i-h6-tcon-top";
+			reg = <0x06510000 0x1000>;
+			clocks = <&ccu CLK_BUS_TCON_TOP>,
+				 <&ccu CLK_TCON_TV0>;
+			clock-names = "bus", "tcon-tv0";
+			clock-output-names = "tcon-top-tv0";
+			resets = <&ccu RST_BUS_TCON_TOP>;
+			#clock-cells = <1>;
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				tcon_top_mixer0_in: port@0 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <0>;
+
+					tcon_top_mixer0_in_mixer0: endpoint@0 {
+						reg = <0>;
+						remote-endpoint = <&mixer0_out_tcon_top_mixer0>;
+					};
+				};
+
+				tcon_top_mixer0_out: port@1 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <1>;
+
+					tcon_top_mixer0_out_tcon_lcd0: endpoint@0 {
+						reg = <0>;
+						remote-endpoint = <&tcon_lcd0_in_tcon_top_mixer0>;
+					};
+
+					tcon_top_mixer0_out_tcon_tv0: endpoint@2 {
+						reg = <2>;
+						remote-endpoint = <&tcon_tv0_in_tcon_top_mixer0>;
+					};
+				};
+
+				tcon_top_hdmi_in: port@4 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <4>;
+
+					tcon_top_hdmi_in_tcon_tv0: endpoint@0 {
+						reg = <0>;
+						remote-endpoint = <&tcon_tv0_out_tcon_top>;
+					};
+				};
+
+				tcon_top_hdmi_out: port@5 {
+					reg = <5>;
+
+					tcon_top_hdmi_out_hdmi: endpoint {
+						remote-endpoint = <&hdmi_in_tcon_top>;
+					};
+				};
+			};
+		};
+
+		tcon_lcd0: lcd-controller@6511000 {
+			compatible = "allwinner,sun50i-h6-tcon-lcd",
+				     "allwinner,sun8i-r40-tcon-lcd";
+			reg = <0x06511000 0x1000>;
+			interrupts = <GIC_SPI 64 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_TCON_LCD0>, <&ccu CLK_TCON_LCD0>;
+			clock-names = "ahb", "tcon-ch0";
+			clock-output-names = "tcon-data-clock";
+			#clock-cells = <0>;
+			resets = <&ccu RST_BUS_TCON_LCD0>, <&ccu RST_BUS_TCON_LCD1>;
+			reset-names = "lcd", "lvds";
+			status = "disabled";
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				tcon_lcd0_in: port@0 {
+					reg = <0>;
+
+					tcon_lcd0_in_tcon_top_mixer0: endpoint {
+						remote-endpoint = <&tcon_top_mixer0_out_tcon_lcd0>;
+					};
+				};
+
+				tcon_lcd0_out: port@1 {
+					reg = <1>;
+				};
+			};
+		};
+
+		tcon_tv0: lcd-controller@6515000 {
+			compatible = "allwinner,sun50i-h6-tcon-tv",
+				     "allwinner,sun8i-r40-tcon-tv";
+			reg = <0x06515000 0x1000>;
+			interrupts = <GIC_SPI 66 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_TCON_TV0>,
+				 <&tcon_top CLK_TCON_TOP_TV0>;
+			clock-names = "ahb", "tcon-ch1";
+			resets = <&ccu RST_BUS_TCON_TV0>;
+			reset-names = "lcd";
+			status = "disabled";
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				tcon_tv0_in: port@0 {
+					reg = <0>;
+
+					tcon_tv0_in_tcon_top_mixer0: endpoint {
+						remote-endpoint = <&tcon_top_mixer0_out_tcon_tv0>;
+					};
+				};
+
+				tcon_tv0_out: port@1 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <1>;
+
+					tcon_tv0_out_tcon_top: endpoint@1 {
+						reg = <1>;
+						remote-endpoint = <&tcon_top_hdmi_in_tcon_tv0>;
+					};
+				};
+			};
+		};
+
 		rtc: rtc@7000000 {
 			compatible = "allwinner,sun50i-h616-rtc";
 			reg = <0x07000000 0x400>;
diff --git a/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg28xx.dts b/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg28xx.dts
new file mode 100644
index 000000000..e5291112c
--- /dev/null
+++ b/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg28xx.dts
@@ -0,0 +1,17 @@
+// SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+/*
+ * Copyright (C) 2024 Ryan Walklin <ryan@testtoast.com>.
+ * Copyright (C) 2024 Chris Morgan <macroalpha82@gmail.com>.
+ */
+
+#include "sun50i-h700-anbernic-rg35xx-plus.dts"
+
+/ {
+	model = "Anbernic RG28XX";
+	compatible = "anbernic,rg28xx", "allwinner,sun50i-h700";
+	rocknix-dt-id = "sun50i-h700-anbernic-rg28xx";
+};
+
+&panel {
+	compatible = "anbernic,rg28xx-panel", "panel-mipi-dpi-spi";
+};
diff --git a/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg34xx-sp.dts b/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg34xx-sp.dts
new file mode 100644
index 000000000..395be5f5a
--- /dev/null
+++ b/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg34xx-sp.dts
@@ -0,0 +1,23 @@
+// SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+/*
+ * Copyright (C) 2024 Ryan Walklin <ryan@testtoast.com>.
+ * Copyright (C) 2024 Chris Morgan <macroalpha82@gmail.com>.
+ */
+
+#include "sun50i-h700-anbernic-rg35xx-sp.dts"
+
+/ {
+	model = "Anbernic RG34XX-SP";
+	compatible = "anbernic,rg34xx-sp", "allwinner,sun50i-h700";
+	rocknix-dt-id = "sun50i-h700-anbernic-rg34xx-sp";
+};
+
+&panel {
+	compatible = "anbernic,rg34xx-sp-panel", "panel-mipi-dpi-spi";
+};
+
+&joypad {
+	invert-absrx;
+	invert-absry;
+	amux-count = <4>;
+};
diff --git a/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg34xx.dts b/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg34xx.dts
new file mode 100644
index 000000000..ea5b010f6
--- /dev/null
+++ b/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg34xx.dts
@@ -0,0 +1,17 @@
+// SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+/*
+ * Copyright (C) 2024 Ryan Walklin <ryan@testtoast.com>.
+ * Copyright (C) 2024 Chris Morgan <macroalpha82@gmail.com>.
+ */
+
+#include "sun50i-h700-anbernic-rg35xx-plus.dts"
+
+/ {
+	model = "Anbernic RG34XX";
+	compatible = "anbernic,rg34xx", "allwinner,sun50i-h700";
+	rocknix-dt-id = "sun50i-h700-anbernic-rg34xx";
+};
+
+&panel {
+	compatible = "anbernic,rg34xx-panel", "panel-mipi-dpi-spi";
+};
diff --git a/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg35xx-2024-rev6-panel.dts b/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg35xx-2024-rev6-panel.dts
new file mode 100644
index 000000000..15820530a
--- /dev/null
+++ b/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg35xx-2024-rev6-panel.dts
@@ -0,0 +1,15 @@
+// SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+/*
+ * Copyright (C) 2024 Ryan Walklin <ryan@testtoast.com>.
+ * Copyright (C) 2024 Chris Morgan <macroalpha82@gmail.com>.
+ */
+
+#include "sun50i-h700-anbernic-rg35xx-2024.dts"
+
+/ {
+	rocknix-dt-id = "sun50i-h700-anbernic-rg35xx-2024-rev6-panel";
+};
+
+&panel {
+	compatible = "anbernic,rg35xx-plus-rev6-panel", "panel-mipi-dpi-spi";
+};
diff --git a/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg35xx-2024.dts b/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg35xx-2024.dts
index 1a750c5f6..cfc314f22 100644
--- a/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg35xx-2024.dts
+++ b/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg35xx-2024.dts
@@ -16,11 +16,23 @@ / {
 	model = "Anbernic RG35XX 2024";
 	chassis-type = "handset";
 	compatible = "anbernic,rg35xx-2024", "allwinner,sun50i-h700";
+	rocknix-dt-id = "sun50i-h700-anbernic-rg35xx-2024";
 
 	aliases {
+		mmc0 = &mmc0;
+		mmc1 = &mmc2;
+		mmc2 = &mmc1;
 		serial0 = &uart0;
+		serial1 = &uart5;
 	};
 
+	backlight: backlight {
+		compatible = "pwm-backlight";
+		pwms = <&pwm 0 40000 0>;
+		pinctrl-0 = <&lcd_backlight_pin>;
+		pinctrl-names = "default";
+	};
+	
 	battery: battery {
 		compatible = "simple-battery";
 		constant-charge-current-max-microamp = <1024000>;
@@ -31,111 +43,172 @@ chosen {
 		stdout-path = "serial0:115200n8";
 	};
 
-	gpio_keys_gamepad: gpio-keys-gamepad {
-		compatible = "gpio-keys";
+	connector {
+		compatible = "hdmi-connector";
+		type = "d";
 
-		button-a {
-			label = "Action-Pad A";
-			gpios = <&pio 0 0 GPIO_ACTIVE_LOW>; /* PA0 */
-			linux,input-type = <EV_KEY>;
-			linux,code = <BTN_EAST>;
+		port {
+			hdmi_con_in: endpoint {
+				remote-endpoint = <&hdmi_out_con>;
+			};
 		};
+	};
 
-		button-b {
-			label = "Action-Pad B";
-			gpios = <&pio 0 1 GPIO_ACTIVE_LOW>; /* PA1 */
-			linux,input-type = <EV_KEY>;
-			linux,code = <BTN_SOUTH>;
+	joypad: rocknix-singleadc-joypad {
+		compatible = "rocknix-singleadc-joypad";
+		hw_info = <0x01>;
+
+		joypad-name = "H700 Gamepad";
+		joypad-product = <0x14DF>;
+		joypad-revision = <0x0100>;
+		joypad-vendor = <0x484B>;
+
+		status = "okay";
+
+		pwms = <&pwm 2 1000000 0>;
+		pwm-names = "enable";
+		rumble-boost-weak = <0>;
+		rumble-boost-strong = <0>;
+		
+		/* gpio pincontrol setup */
+		pinctrl-names = "default";
+		pinctrl-0 = <&joy_mux_pin>, <&pwm2_pin>;
+
+		/* Analog mux define */
+		io-channel-names = "amux_adc";
+		io-channels = <&gpadc 0>;
+
+		/* adc mux channel count */
+		amux-count = <0>;
+		/* ABS_RY ABS_RX ABS_Y ABS_X */
+		amux-channel-mapping = <0 2 1 3>;
+
+		/* adc mux select(a,b) gpio */
+		amux-a-gpios = <&pio 8 1 GPIO_ACTIVE_LOW>;
+		amux-b-gpios = <&pio 8 2 GPIO_ACTIVE_LOW>;
+
+		/* adc calculate scale */
+		button-adc-scale = <2>;
+
+		/* adc deadzone range  */
+		button-adc-deadzone = <128>;
+
+		/*
+			specifies fuzz value that is used to filter noise from
+			the event stream.
+		*/
+		button-adc-fuzz = <32>;
+		button-adc-flat = <32>;
+
+		/*
+			Analog Stick data tuning value(precent)
+			p = positive direction, n = negative direction
+			report value = (real_adc_data * tuning_value) / 100
+		*/
+		abs_x-p-tuning = <70>;
+		abs_x-n-tuning = <70>;
+		invert-absx;
+
+		abs_y-p-tuning = <70>;
+		abs_y-n-tuning = <70>;
+		invert-absy;
+
+		abs_rx-p-tuning = <70>;
+		abs_rx-n-tuning = <70>;
+
+		abs_ry-p-tuning = <70>;
+		abs_ry-n-tuning = <70>;
+
+		/* poll device interval (ms), adc read interval */
+		poll-interval = <10>;
+
+		/* gpio button auto repeat set value : default disable */
+		/* autorepeat; */
+
+		sw1 {
+			gpios = <&pio 0 6 GPIO_ACTIVE_LOW>; /* PA6 */
+			label = "GPIO DPAD-UP";
+			linux,code = <BTN_DPAD_UP>;
 		};
-
-		button-down {
-			label = "D-Pad Down";
+		sw2 {
 			gpios = <&pio 4 0 GPIO_ACTIVE_LOW>; /* PE0 */
-			linux,input-type = <EV_KEY>;
+			label = "GPIO DPAD-DOWN";
 			linux,code = <BTN_DPAD_DOWN>;
 		};
-
-		button-l1 {
-			label = "Key L1";
-			gpios = <&pio 0 10 GPIO_ACTIVE_LOW>; /* PA10 */
-			linux,input-type = <EV_KEY>;
-			linux,code = <BTN_TL>;
-		};
-
-		button-l2 {
-			label = "Key L2";
-			gpios = <&pio 0 11 GPIO_ACTIVE_LOW>; /* PA11 */
-			linux,input-type = <EV_KEY>;
-			linux,code = <BTN_TL2>;
-		};
-
-		button-left {
-			label = "D-Pad left";
+		sw3 {
 			gpios = <&pio 0 8 GPIO_ACTIVE_LOW>; /* PA8 */
-			linux,input-type = <EV_KEY>;
+			label = "GPIO DPAD-LEFT";
 			linux,code = <BTN_DPAD_LEFT>;
 		};
-
-		button-menu {
-			label = "Key Menu";
-			gpios = <&pio 4 3 GPIO_ACTIVE_LOW>; /* PE3 */
-			linux,input-type = <EV_KEY>;
-			linux,code = <BTN_MODE>;
+		sw4 {
+			gpios = <&pio 0 9 GPIO_ACTIVE_LOW>; /* PA9 */
+			label = "GPIO DPAD-RIGHT";
+			linux,code = <BTN_DPAD_RIGHT>;
 		};
-
-		button-r1 {
-			label = "Key R1";
-			gpios = <&pio 0 12 GPIO_ACTIVE_LOW>; /* PA12 */
-			linux,input-type = <EV_KEY>;
-			linux,code = <BTN_TR>;
+		sw5 {
+			gpios = <&pio 0 0 GPIO_ACTIVE_LOW>; /* PA0 */
+			label = "GPIO BTN-A";
+			linux,code = <BTN_EAST>;
 		};
-
-		button-r2 {
-			label = "Key R2";
-			gpios = <&pio 0 7 GPIO_ACTIVE_LOW>; /* PA7 */
-			linux,input-type = <EV_KEY>;
-			linux,code = <BTN_TR2>;
+		sw6 {
+			gpios = <&pio 0 1 GPIO_ACTIVE_LOW>; /* PA1 */
+			label = "GPIO BTN-B";
+			linux,code = <BTN_SOUTH>;
 		};
-
-		button-right {
-			label = "D-Pad Right";
-			gpios = <&pio 0 9 GPIO_ACTIVE_LOW>; /* PA9 */
-			linux,input-type = <EV_KEY>;
-			linux,code = <BTN_DPAD_RIGHT>;
+		sw7 {
+			gpios = <&pio 0 3 GPIO_ACTIVE_LOW>; /* PA2 */
+			label = "GPIO BTN-X";
+			linux,code = <BTN_NORTH>;
 		};
-
-		button-select {
-			label = "Key Select";
+		sw8 {
+			gpios = <&pio 0 2 GPIO_ACTIVE_LOW>; /* PA3 */
+			label = "GPIO BTN-Y";
+			linux,code = <BTN_WEST>;
+		};
+		sw9 {
 			gpios = <&pio 0 5 GPIO_ACTIVE_LOW>; /* PA5 */
-			linux,input-type = <EV_KEY>;
+			label = "BTN_SELECT";
 			linux,code = <BTN_SELECT>;
 		};
-		button-start {
-			label = "Key Start";
+		sw10 {
 			gpios = <&pio 0 4 GPIO_ACTIVE_LOW>; /* PA4 */
-			linux,input-type = <EV_KEY>;
+			label = "BTN_START";
 			linux,code = <BTN_START>;
 		};
-
-		button-up {
-			label = "D-Pad Up";
-			gpios = <&pio 0 6 GPIO_ACTIVE_LOW>; /* PA6 */
-			linux,input-type = <EV_KEY>;
-			linux,code = <BTN_DPAD_UP>;
+		sw11 {
+			gpios = <&pio 4 3 GPIO_ACTIVE_LOW>; /* PE3 */
+			label = "GPIO BTN_F";
+			linux,code = <BTN_MODE>;
 		};
-
-		button-x {
-			label = "Action-Pad X";
-			gpios = <&pio 0 3 GPIO_ACTIVE_LOW>; /* PA3 */
-			linux,input-type = <EV_KEY>;
-			linux,code = <BTN_NORTH>;
+		sw12 {
+			gpios = <&pio 4 8 GPIO_ACTIVE_LOW>; /* PE8 */
+			label = "BTN_THUMBL";
+			linux,code = <BTN_THUMBL>;
 		};
-
-		button-y {
-			label = "Action Pad Y";
-			gpios = <&pio 0 2 GPIO_ACTIVE_LOW>; /* PA2 */
-			linux,input-type = <EV_KEY>;
-			linux,code = <BTN_WEST>;
+		sw13 {
+			gpios = <&pio 4 9 GPIO_ACTIVE_LOW>; /* PE9 */
+			label = "BTN_THUMBR";
+			linux,code = <BTN_THUMBR>;
+		};
+		sw14 {
+			gpios = <&pio 0 12 GPIO_ACTIVE_LOW>; /* PA12 */
+			label = "GPIO BTN_TR";
+			linux,code = <BTN_TR>;
+		};
+		sw15 {
+			gpios = <&pio 0 7 GPIO_ACTIVE_LOW>; /* PA7 */
+			label = "GPIO BTN_TR2";
+			linux,code = <BTN_TR2>;
+		};
+		sw16 {
+			gpios = <&pio 0 10 GPIO_ACTIVE_LOW>; /* PA10 */
+			label = "GPIO BTN_TL";
+			linux,code = <BTN_TL>;
+		};
+		sw17 {
+			gpios = <&pio 0 11 GPIO_ACTIVE_LOW>; /* PA11 */
+			label = "GPIO BTN_TL2";
+			linux,code = <BTN_TL2>;
 		};
 	};
 
@@ -158,7 +231,7 @@ button-vol-down {
 		};
 	};
 
-	leds {
+	leds: leds {
 		compatible = "gpio-leds";
 
 		led-0 {
@@ -170,7 +243,7 @@ led-0 {
 
 		led-1 {
 			function = LED_FUNCTION_STATUS;
-			color = <LED_COLOR_ID_GREEN>;
+			color = <LED_COLOR_ID_RED>;
 			gpios = <&pio 8 11 GPIO_ACTIVE_HIGH>; /* PI11 */
 		};
 	};
@@ -181,6 +254,97 @@ reg_vcc5v: regulator-vcc5v { /* USB-C power input */
 		regulator-min-microvolt = <5000000>;
 		regulator-max-microvolt = <5000000>;
 	};
+
+	reg_lcd: regulator-gpio-lcd-vdd {
+		compatible = "regulator-fixed";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-name = "vdd-lcd";
+		gpio = <&pio 8 15 GPIO_ACTIVE_HIGH>; // PI15
+		enable-active-high;
+	};
+
+	spi_lcd: spi {
+		compatible = "spi-gpio";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		sck-gpios = <&pio 8 9 GPIO_ACTIVE_HIGH>; // PI9
+		mosi-gpios = <&pio 8 10 GPIO_ACTIVE_HIGH>; // PI10
+		cs-gpios = <&pio 8 8 GPIO_ACTIVE_LOW>; // PI8
+		num-chipselects = <1>;
+
+		panel: panel@0 {
+			compatible = "anbernic,rg35xx-plus-panel", "panel-mipi-dpi-spi";
+
+			reg = <0>;
+
+			spi-max-frequency = <3125000>;
+			spi-3wire;
+
+			reset-gpios = <&pio 8 14 GPIO_ACTIVE_LOW>; // PI14
+
+			backlight = <&backlight>;
+			power-supply = <&reg_lcd>;
+
+			pinctrl-0 = <&lcd0_rgb888_pins>;
+			pinctrl-names = "default";
+
+			port {
+				panel_in_rgb: endpoint {
+					remote-endpoint = <&tcon_lcd0_out_lcd>;
+				};
+			};
+		};
+	};
+
+	gpu_opp_table: opp-table-1 {
+		compatible = "operating-points-v2";
+
+		opp-420000000 {
+			opp-hz = /bits/ 64 <420000000>;
+			opp-microvolt = <900000>;
+		};
+		opp-456000000 {
+			opp-hz = /bits/ 64 <456000000>;
+			opp-microvolt = <900000>;
+		};
+		opp-504000000 {
+			opp-hz = /bits/ 64 <504000000>;
+			opp-microvolt = <900000>;
+		};
+		opp-552000000 {
+			opp-hz = /bits/ 64 <552000000>;
+			opp-microvolt = <900000>;
+		};
+		opp-600000000 {
+			opp-hz = /bits/ 64 <600000000>;
+			opp-microvolt = <900000>;
+		};
+		opp-648000000 {
+			opp-hz = /bits/ 64 <648000000>;
+			opp-microvolt = <960000>;
+		};
+	};
+
+	reg_vcc3v3_mmc2: regulator-vcc3v3-mmc2 {
+		compatible = "regulator-fixed";
+		enable-active-high;
+		gpio = <&pio 4 4 GPIO_ACTIVE_HIGH>; /* PE4 */
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-name = "vcc3v3-mmc2";
+	};
+
+	reg_usb0_vbus: regulator-usb0-vbus {
+		compatible = "regulator-fixed";
+		enable-active-high;
+		gpio = <&pio 8 16 GPIO_ACTIVE_HIGH>; /* PI16 */
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		regulator-name = "usb0-vbus";
+		vin-supply = <&reg_boost>;
+	};
 };
 
 &codec {
@@ -196,20 +360,56 @@ &cpu0 {
 	cpu-supply = <&reg_dcdc1>;
 };
 
+&de {
+	status = "okay";
+};
+
 &ehci0 {
 	status = "okay";
 };
 
 &gpu {
 	mali-supply = <&reg_dcdc2>;
+	operating-points-v2 = <&gpu_opp_table>;
 	status = "okay";
 };
 
+&hdmi {
+	hvcc-supply = <&reg_bldo1>;
+	status = "okay";
+};
+
+&hdmi_out {
+	hdmi_out_con: endpoint {
+		remote-endpoint = <&hdmi_con_in>;
+	};
+};
+
 &mmc0 {
-	vmmc-supply = <&reg_cldo3>;
-	disable-wp;
+	bus-width = <4>;
 	cd-gpios = <&pio 5 6 GPIO_ACTIVE_LOW>;  /* PF6 */
+	disable-wp;
+	no-1-8-v;
+	vmmc-supply = <&reg_cldo3>;
+	status = "okay";
+};
+
+&mmc1 {
+	vmmc-supply = <&reg_cldo4>;
+	vqmmc-supply = <&reg_aldo4>;
+	keep-power-in-suspend;
 	bus-width = <4>;
+	non-removable;
+	status = "okay";
+};
+
+&mmc2 {
+	bus-width = <4>;
+	cd-gpios = <&pio 4 22 GPIO_ACTIVE_LOW>; /* PE22 */
+	disable-wp;
+	no-1-8-v;
+	vmmc-supply = <&reg_vcc3v3_mmc2>;
+	vqmmc-supply = <&reg_cldo3>;
 	status = "okay";
 };
 
@@ -220,11 +420,50 @@ &ohci0 {
 &pio {
 	vcc-pa-supply = <&reg_cldo3>;
 	vcc-pc-supply = <&reg_cldo3>;
+	vcc-pd-supply = <&reg_cldo3>;
 	vcc-pe-supply = <&reg_cldo3>;
 	vcc-pf-supply = <&reg_cldo3>;
 	vcc-pg-supply = <&reg_aldo4>;
 	vcc-ph-supply = <&reg_cldo3>;
 	vcc-pi-supply = <&reg_cldo3>;
+
+	lcd_backlight_pin: pwm0-pin {
+		pins = "PD28";
+		function = "pwm0";
+	};
+
+	/omit-if-no-ref/
+	pwm2_pin: pwm2-pin {
+		pins = "PH2";
+		function = "pwm2";
+	};
+
+	/omit-if-no-ref/
+	pwm3_pin: pwm3-pin {
+		pins = "PI13";
+		function = "pwm3";
+	};
+
+	joy_mux_pin: joy-mux-pin {
+		pins = "PI0";
+		function = "gpio_out";
+	};
+
+	/omit-if-no-ref/
+	uart5_ph_pins: uart5-ph-pins {
+		pins = "PH2", "PH3";
+		function = "uart5";
+	};	
+};
+
+&gpadc {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	channel@0 {
+		reg = <0>;
+	};
 };
 
 &r_i2c {
@@ -264,8 +503,8 @@ reg_dcdc1: dcdc1 {
 
 			reg_dcdc2: dcdc2 {
 				regulator-always-on;
-				regulator-min-microvolt = <940000>;
-				regulator-max-microvolt = <940000>;
+				regulator-min-microvolt = <900000>;
+				regulator-max-microvolt = <960000>;
 				regulator-name = "vdd-gpu-sys";
 			};
 
@@ -372,10 +611,46 @@ &uart0 {
 
 /* the AXP717 has USB type-C role switch functionality, not yet described by the binding */
 &usbotg {
-	dr_mode = "peripheral";   /* USB type-C receptable */
+	dr_mode = "otg";   /* USB type-C receptable */
 	status = "okay";
 };
 
 &usbphy {
+	usb0_id_det-gpios = <&pio 8 4 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
+	usb0_vbus_power-supply = <&usb_power>;
+	usb0_vbus-supply = <&reg_usb0_vbus>;
+	status = "okay";
+};
+
+&tcon_lcd0 {
+	status = "okay";
+};
+
+&tcon_lcd0_out {
+	tcon_lcd0_out_lcd: endpoint@1 {
+		remote-endpoint = <&panel_in_rgb>;
+	};
+};
+
+&tcon_tv0 {
+	status = "okay";
+};
+
+&pwm {
+	allwinner,pwm-paired-channel-clock-sources = "hosc", "hosc", "hosc";
+	allwinner,pwm-paired-channel-clock-prescales = <0>, <0>, <0>;
 	status = "okay";
 };
+
+&ahub_dam_plat {
+	status = "okay";
+};
+
+&ahub1_plat {
+	status = "okay";
+};
+
+&ahub1_mach_hdmi {
+	status = "okay";
+};
+
diff --git a/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg35xx-h-rev6-panel.dts b/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg35xx-h-rev6-panel.dts
new file mode 100644
index 000000000..78287c338
--- /dev/null
+++ b/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg35xx-h-rev6-panel.dts
@@ -0,0 +1,15 @@
+// SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+/*
+ * Copyright (C) 2024 Ryan Walklin <ryan@testtoast.com>.
+ * Copyright (C) 2024 Chris Morgan <macroalpha82@gmail.com>.
+ */
+
+#include "sun50i-h700-anbernic-rg35xx-h.dts"
+
+/ {
+	rocknix-dt-id = "sun50i-h700-anbernic-rg35xx-h-rev6-panel";
+};
+
+&panel {
+	compatible = "anbernic,rg35xx-plus-rev6-panel", "panel-mipi-dpi-spi";
+};
diff --git a/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg35xx-h.dts b/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg35xx-h.dts
index bef4d1074..894db3396 100644
--- a/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg35xx-h.dts
+++ b/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg35xx-h.dts
@@ -9,68 +9,7 @@
 / {
 	model = "Anbernic RG35XX H";
 	compatible = "anbernic,rg35xx-h", "allwinner,sun50i-h700";
-
-	adc-joystick {
-		compatible = "adc-joystick";
-		io-channels = <&adc_mux 0>,
-			      <&adc_mux 1>,
-			      <&adc_mux 2>,
-			      <&adc_mux 3>;
-		pinctrl-0 = <&joy_mux_pin>;
-		pinctrl-names = "default";
-		poll-interval = <60>;
-		#address-cells = <1>;
-		#size-cells = <0>;
-
-		axis@0 {
-			reg = <0>;
-			abs-flat = <32>;
-			abs-fuzz = <32>;
-			abs-range = <4096 0>;
-			linux,code = <ABS_X>;
-		};
-
-		axis@1 {
-			reg = <1>;
-			abs-flat = <32>;
-			abs-fuzz = <32>;
-			abs-range = <0 4096>;
-			linux,code = <ABS_Y>;
-		};
-
-		axis@2 {
-			reg = <2>;
-			abs-flat = <32>;
-			abs-fuzz = <32>;
-			abs-range = <0 4096>;
-			linux,code = <ABS_RX>;
-		};
-
-		axis@3 {
-			reg = <3>;
-			abs-flat = <32>;
-			abs-fuzz = <32>;
-			abs-range = <4096 0>;
-			linux,code = <ABS_RY>;
-		};
-	};
-
-	adc_mux: adc-mux {
-		compatible = "io-channel-mux";
-		channels = "left_x", "left_y", "right_x", "right_y";
-		#io-channel-cells = <1>;
-		io-channels = <&gpadc 0>;
-		io-channel-names = "parent";
-		mux-controls = <&gpio_mux>;
-		settle-time-us = <100>;
-	};
-
-	gpio_mux: mux-controller {
-		compatible = "gpio-mux";
-		mux-gpios = <&pio 8 1 GPIO_ACTIVE_LOW>,
-			    <&pio 8 2 GPIO_ACTIVE_LOW>;
-		#mux-control-cells = <0>;
-	};
+	rocknix-dt-id = "sun50i-h700-anbernic-rg35xx-h";
 
 	reg_vcc3v8_usb: regulator-vcc3v8-usb {
 		compatible = "regulator-fixed";
@@ -90,32 +29,29 @@ reg_vcc5v0_usb: regulator-vcc5v0-usb {
 		regulator-name = "vcc5v0-usb";
 		vin-supply = <&reg_vcc3v8_usb>;
 	};
-};
-
-&gpadc {
-	#address-cells = <1>;
-	#size-cells = <0>;
-	status = "okay";
 
-	channel@0 {
-		reg = <0>;
+	reg_vcc3v8_usb: regulator-vcc3v8-usb {
+		compatible = "regulator-fixed";
+		enable-active-high;
+		gpio = <&pio 4 5 GPIO_ACTIVE_HIGH>; /* PE5 */
+		regulator-min-microvolt = <3800000>;
+		regulator-max-microvolt = <3800000>;
+		regulator-name = "vcc3v8-usb";
 	};
-};
 
-&gpio_keys_gamepad {
-	button-thumbl {
-		label = "GPIO Thumb Left";
-		gpios = <&pio 4 8 GPIO_ACTIVE_LOW>; /* PE8 */
-		linux,input-type = <EV_KEY>;
-		linux,code = <BTN_THUMBL>;
+	reg_usb1_vbus: regulator-usb1-vbus {
+		compatible = "regulator-fixed";
+		enable-active-high;
+		gpio = <&pio 8 7 GPIO_ACTIVE_HIGH>; /* PI7 */
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		regulator-name = "usb1-vbus";
+		vin-supply = <&reg_vcc3v8_usb>;
 	};
+};
 
-	button-thumbr {
-		label = "GPIO Thumb Right";
-		gpios = <&pio 4 9 GPIO_ACTIVE_LOW>; /* PE9 */
-		linux,input-type = <EV_KEY>;
-		linux,code = <BTN_THUMBR>;
-	};
+&joypad {
+	amux-count = <4>;
 };
 
 &ehci1 {
@@ -126,13 +62,10 @@ &ohci1 {
 	status = "okay";
 };
 
-&pio {
-	joy_mux_pin: joy-mux-pin {
-		pins = "PI0";
-		function = "gpio_out";
-	};
+&usbphy {
+	usb1_vbus-supply = <&reg_vcc5v0_usb>;
 };
 
 &usbphy {
-	usb1_vbus-supply = <&reg_vcc5v0_usb>;
+	usb1_vbus-supply = <&reg_usb1_vbus>;
 };
diff --git a/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg35xx-plus-rev6-panel.dts b/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg35xx-plus-rev6-panel.dts
new file mode 100644
index 000000000..0900c57af
--- /dev/null
+++ b/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg35xx-plus-rev6-panel.dts
@@ -0,0 +1,15 @@
+// SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+/*
+ * Copyright (C) 2024 Ryan Walklin <ryan@testtoast.com>.
+ * Copyright (C) 2024 Chris Morgan <macroalpha82@gmail.com>.
+ */
+
+#include "sun50i-h700-anbernic-rg35xx-plus.dts"
+
+/ {
+	rocknix-dt-id = "sun50i-h700-anbernic-rg35xx-plus-rev6-panel";
+};
+
+&panel {
+	compatible = "anbernic,rg35xx-plus-rev6-panel", "panel-mipi-dpi-spi";
+};
diff --git a/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg35xx-plus.dts b/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg35xx-plus.dts
index 60a8e4922..950dbd39c 100644
--- a/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg35xx-plus.dts
+++ b/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg35xx-plus.dts
@@ -8,6 +8,7 @@
 / {
 	model = "Anbernic RG35XX Plus";
 	compatible = "anbernic,rg35xx-plus", "allwinner,sun50i-h700";
+	rocknix-dt-id = "sun50i-h700-anbernic-rg35xx-plus";
 
 	wifi_pwrseq: pwrseq {
 		compatible = "mmc-pwrseq-simple";
@@ -22,12 +23,7 @@ wifi_pwrseq: pwrseq {
 
 /* SDIO WiFi RTL8821CS */
 &mmc1 {
-	vmmc-supply = <&reg_cldo4>;
-	vqmmc-supply = <&reg_aldo4>;
 	mmc-pwrseq = <&wifi_pwrseq>;
-	bus-width = <4>;
-	non-removable;
-	status = "okay";
 
 	sdio_wifi: wifi@1 {
 		reg = <1>;
diff --git a/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg35xx-pro.dts b/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg35xx-pro.dts
new file mode 100644
index 000000000..618142824
--- /dev/null
+++ b/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg35xx-pro.dts
@@ -0,0 +1,17 @@
+// SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+/*
+ * Copyright (C) 2024 Ryan Walklin <ryan@testtoast.com>.
+ * Copyright (C) 2024 Chris Morgan <macroalpha82@gmail.com>.
+ */
+
+#include "sun50i-h700-anbernic-rg35xx-plus.dts"
+
+/ {
+	model = "Anbernic RG35XX Pro";
+	compatible = "anbernic,rg35xx-pro", "allwinner,sun50i-h700";
+	rocknix-dt-id = "sun50i-h700-anbernic-rg35xx-pro";
+};
+
+&joypad {
+	amux-count = <4>;
+};
diff --git a/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg35xx-sp-v2-panel.dts b/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg35xx-sp-v2-panel.dts
new file mode 100644
index 000000000..ddfec9eca
--- /dev/null
+++ b/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg35xx-sp-v2-panel.dts
@@ -0,0 +1,15 @@
+// SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+/*
+ * Copyright (C) 2024 Ryan Walklin <ryan@testtoast.com>.
+ * Copyright (C) 2024 Chris Morgan <macroalpha82@gmail.com>.
+ */
+
+#include "sun50i-h700-anbernic-rg35xx-sp.dts"
+
+/ {
+	rocknix-dt-id = "sun50i-h700-anbernic-rg35xx-sp-v2-panel";
+};
+
+&panel {
+	compatible = "anbernic,rg35xx-sp-v2-panel", "panel-mipi-dpi-spi";
+};
diff --git a/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg35xx-sp.dts b/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg35xx-sp.dts
index 0cf16dc90..53b8ddd12 100644
--- a/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg35xx-sp.dts
+++ b/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg35xx-sp.dts
@@ -10,6 +10,7 @@
 / {
 	model = "Anbernic RG35XX SP";
 	compatible = "anbernic,rg35xx-sp", "allwinner,sun50i-h700";
+	rocknix-dt-id = "sun50i-h700-anbernic-rg35xx-sp";
 
 	gpio-keys-lid {
 		compatible = "gpio-keys";
diff --git a/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg40xx-h.dts b/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg40xx-h.dts
new file mode 100644
index 000000000..9abd3e0e1
--- /dev/null
+++ b/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg40xx-h.dts
@@ -0,0 +1,38 @@
+// SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+/*
+ * Copyright (C) 2024 Philippe Simons <simons.philippe@gmail.com>.
+ */
+
+#include "sun50i-h700-anbernic-rg35xx-plus.dts"
+
+/ {
+	model = "Anbernic RG40XX H";
+	compatible = "anbernic,rg40xx-h", "allwinner,sun50i-h700";
+	rocknix-dt-id = "sun50i-h700-anbernic-rg40xx-h.dts";
+};
+
+&joypad {
+	invert-absrx;
+	invert-absry;
+	amux-count = <4>;
+	pwms = <&pwm 3 1000000 0>;
+	pinctrl-0 = <&joy_mux_pin>, <&pwm3_pin>;
+};
+
+&uart5 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart5_ph_pins>;
+	status = "okay";	
+};
+
+&leds {
+	led-rgb {
+		function = LED_FUNCTION_KBD_BACKLIGHT;
+		color = <LED_COLOR_ID_RGB>;
+		gpios = <&pio 8 7 GPIO_ACTIVE_HIGH>; /* PI7 */
+	};	
+};
+
+&panel {
+	compatible = "anbernic,rg40xx-panel", "panel-mipi-dpi-spi";
+};
diff --git a/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg40xx-v.dts b/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg40xx-v.dts
new file mode 100644
index 000000000..b3d873941
--- /dev/null
+++ b/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg40xx-v.dts
@@ -0,0 +1,36 @@
+// SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+/*
+ * Copyright (C) 2024 Philippe Simons <simons.philippe@gmail.com>.
+ */
+
+#include "sun50i-h700-anbernic-rg35xx-plus.dts"
+
+/ {
+	model = "Anbernic RG40XX V";
+	compatible = "anbernic,rg40xx-V", "allwinner,sun50i-h700";
+	rocknix-dt-id = "sun50i-h700-anbernic-rg40xx-v";
+};
+
+&joypad {
+	amux-count = <4>;
+	pwms = <&pwm 3 1000000 0>;
+	pinctrl-0 = <&joy_mux_pin>, <&pwm3_pin>;
+};
+
+&uart5 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart5_ph_pins>;
+	status = "okay";	
+};
+
+&leds {
+	led-rgb {
+		function = LED_FUNCTION_KBD_BACKLIGHT;
+		color = <LED_COLOR_ID_RGB>;
+		gpios = <&pio 8 7 GPIO_ACTIVE_HIGH>; /* PI7 */
+	};	
+};
+
+&panel {
+	compatible = "anbernic,rg40xx-panel", "panel-mipi-dpi-spi";
+};
diff --git a/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rgcubexx.dts b/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rgcubexx.dts
new file mode 100644
index 000000000..6a91b73c2
--- /dev/null
+++ b/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rgcubexx.dts
@@ -0,0 +1,44 @@
+// SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+/*
+ * Copyright (C) 2024 Ryan Walklin <ryan@testtoast.com>.
+ * Copyright (C) 2024 Chris Morgan <macroalpha82@gmail.com>.
+ */
+
+#include "sun50i-h700-anbernic-rg35xx-plus.dts"
+
+/ {
+	model = "Anbernic RG CubeXX";
+	compatible = "anbernic,rgcubexx", "allwinner,sun50i-h700";
+	rocknix-dt-id = "sun50i-h700-anbernic-rgcubexx";
+};
+
+&joypad {
+	invert-absrx;
+	invert-absry;
+	amux-count = <4>;
+	pwms = <&pwm 3 1000000 0>;
+	pinctrl-0 = <&joy_mux_pin>, <&pwm3_pin>;
+};
+
+&uart5 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart5_ph_pins>;
+	status = "okay";	
+};
+
+&leds {
+	led-rgb {
+		function = LED_FUNCTION_KBD_BACKLIGHT;
+		color = <LED_COLOR_ID_RGB>;
+		gpios = <&pio 8 7 GPIO_ACTIVE_HIGH>; /* PI7 */
+	};	
+};
+
+&reg_lcd {
+	regulator-min-microvolt = <2800000>;
+	regulator-max-microvolt = <2800000>;
+};
+
+&panel {
+	compatible = "anbernic,rgcubexx-panel", "panel-mipi-dpi-spi";
+};
diff --git a/arch/arm64/boot/dts/rockchip/retrogame_joypad_s2_f1.dtsi b/arch/arm64/boot/dts/rockchip/retrogame_joypad_s2_f1.dtsi
new file mode 100644
index 000000000..304ef1ef4
--- /dev/null
+++ b/arch/arm64/boot/dts/rockchip/retrogame_joypad_s2_f1.dtsi
@@ -0,0 +1,122 @@
+/* 
+  This is a skeleton of joypad with 2 sticks and FN (MODE) button.
+  Fits devices with 1 stick and 2 extra face buttons too.
+  By including this ans setting I/O properties only,
+  devices should get consistent controller id and mapping
+  thus reusing non-game configs:
+    * SDL gamecontrollerdb.txt
+    * ES es_input.cfg
+    * Retroarch gamepad
+*/
+
+/ {
+    joypad: retrogame_joypad_s2_f1 {
+        /* These drivers emit the same button set which makes this skeleton ADC-agnostic */
+        /* compatible = "rocknix-joypad"; */
+        /* compatible = "rocknix-singleadc-joypad"; */
+
+        /* These are constants making Joystick Guid the same */
+        joypad-name = "retrogame_joypad_s2_f1";
+        joypad-vendor = <0x484B>;
+        joypad-product = <0x1121>;  /* 11 inherited, 2 for number of sticks, 1 for number of FN */
+        joypad-revision = <0x0100>;
+
+        /* require explicit status = "okay"; */
+        status = "disabled";
+
+        /* adc calculate scale */
+        button-adc-scale = <2>;
+
+        /* adc deadzone range  */
+        button-adc-deadzone = <64>;
+
+        /*
+          specifies fuzz value that is used to filter noise from
+          the event stream.
+        */
+        button-adc-fuzz = <32>;
+        button-adc-flat = <32>;
+
+        /* poll device interval (ms), adc read interval */
+        poll-interval = <10>;
+
+        /* gpio button auto repeat set value : default disable */
+        /*
+            autorepeat;
+        */
+
+        /* meaningful node names for easier use */
+        up {
+            label = "GPIO DPAD-UP";
+            linux,code = <BTN_DPAD_UP>;
+        };
+        down {
+            label = "GPIO DPAD-DOWN";
+            linux,code = <BTN_DPAD_DOWN>;
+        };
+        left {
+            label = "GPIO DPAD-LEFT";
+            linux,code = <BTN_DPAD_LEFT>;
+        };
+        right {
+            label = "GPIO DPAD-RIGHT";
+            linux,code = <BTN_DPAD_RIGHT>;
+        };
+
+        a {
+            label = "GPIO BTN-A";
+            linux,code = <BTN_EAST>;
+        };
+        b {
+            label = "GPIO BTN-B";
+            linux,code = <BTN_SOUTH>;
+        };
+        x {
+            label = "GPIO BTN-X";
+            linux,code = <BTN_NORTH>;
+        };
+        y {
+            label = "GPIO BTN-Y";
+            linux,code = <BTN_WEST>;
+        };
+
+        select {
+            label = "GPIO BTN_SELECT";
+            linux,code = <BTN_SELECT>;
+        };
+        start {
+            label = "GPIO BTN_START";
+            linux,code = <BTN_START>;
+        };
+        mode {
+            label = "GPIO BTN_F";
+            linux,code = <BTN_MODE>;
+        };
+
+        tl {
+            label = "GPIO BTN_TL";
+            linux,code = <BTN_TL>;
+        };
+        tr {
+            label = "GPIO BTN_TR";
+            linux,code = <BTN_TR>;
+        };
+        tl2 {
+            label = "GPIO BTN_TL2";
+            linux,code = <BTN_TL2>;
+        };
+        tr2 {
+            label = "GPIO BTN_TR2";
+            linux,code = <BTN_TR2>;
+        };
+
+        thumbl {
+            label = "GPIO BTN_THUMBL";
+            linux,code = <BTN_THUMBL>;
+        };
+        thumbr {
+            label = "GPIO BTN_THUMBR";
+            linux,code = <BTN_THUMBR>;
+        };
+    };
+};
diff --git a/arch/arm64/configs/defconfig b/arch/arm64/configs/defconfig
index eb5c17d4c..475e2b837 100644
--- a/arch/arm64/configs/defconfig
+++ b/arch/arm64/configs/defconfig
@@ -1559,6 +1559,7 @@ CONFIG_PWM_ROCKCHIP=y
 CONFIG_PWM_SAMSUNG=y
 CONFIG_PWM_SL28CPLD=m
 CONFIG_PWM_SUN4I=m
+CONFIG_PWM_SUN20I=m
 CONFIG_PWM_TEGRA=m
 CONFIG_PWM_TIECAP=m
 CONFIG_PWM_TIEHRPWM=m
diff --git a/drivers/bluetooth/btrtl.c b/drivers/bluetooth/btrtl.c
index 4d182cf6e..d68db3c43 100644
--- a/drivers/bluetooth/btrtl.c
+++ b/drivers/bluetooth/btrtl.c
@@ -179,6 +179,14 @@ static const struct id_table ic_id_table[] = {
 	  .cfg_name = "rtl_bt/rtl8723ds_config",
 	  .hw_info  = "rtl8723ds" },
 
+	/* 8733BU */
+	{ IC_INFO(RTL_ROM_LMP_8723B, 0xf, 0x8, HCI_USB),
+	  .config_needed = true,
+	  .has_rom_version = true,
+	  .fw_name  = "rtl_bt/rtl8723fu_fw",
+	  .cfg_name = "rtl_bt/rtl8723fu_config",
+	  .hw_info  = "rtl8733bu" },
+
 	/* 8821A */
 	{ IC_INFO(RTL_ROM_LMP_8821A, 0xa, 0x6, HCI_USB),
 	  .config_needed = false,
@@ -663,6 +671,7 @@ static int rtlbt_parse_firmware(struct hci_dev *hdev,
 		{ RTL_ROM_LMP_8822B, 13 },	/* 8822C */
 		{ RTL_ROM_LMP_8761A, 14 },	/* 8761B */
 		{ RTL_ROM_LMP_8852A, 18 },	/* 8852A */
+		{ RTL_ROM_LMP_8723B, 19 },	/* 8733B */
 		{ RTL_ROM_LMP_8852A, 20 },	/* 8852B */
 		{ RTL_ROM_LMP_8852A, 25 },	/* 8852C */
 		{ RTL_ROM_LMP_8851B, 36 },	/* 8851B */
@@ -1514,6 +1523,8 @@ MODULE_FIRMWARE("rtl_bt/rtl8723d_fw.bin");
 MODULE_FIRMWARE("rtl_bt/rtl8723d_config.bin");
 MODULE_FIRMWARE("rtl_bt/rtl8723ds_fw.bin");
 MODULE_FIRMWARE("rtl_bt/rtl8723ds_config.bin");
+MODULE_FIRMWARE("rtl_bt/rtl8723fu_fw.bin");
+MODULE_FIRMWARE("rtl_bt/rtl8723fu_config.bin");
 MODULE_FIRMWARE("rtl_bt/rtl8761a_fw.bin");
 MODULE_FIRMWARE("rtl_bt/rtl8761a_config.bin");
 MODULE_FIRMWARE("rtl_bt/rtl8761b_fw.bin");
diff --git a/drivers/bluetooth/btusb.c b/drivers/bluetooth/btusb.c
index 9efdd111b..7099e6aa2 100644
--- a/drivers/bluetooth/btusb.c
+++ b/drivers/bluetooth/btusb.c
@@ -753,6 +753,9 @@ static const struct usb_device_id quirks_table[] = {
 	{ USB_DEVICE(0x0bda, 0xb009), .driver_info = BTUSB_REALTEK },
 	{ USB_DEVICE(0x2ff8, 0xb011), .driver_info = BTUSB_REALTEK },
 
+	/* Realtek 8733BU Bluetooth device */
+	{ USB_DEVICE(0x0bda, 0xb733), .driver_info = BTUSB_REALTEK },
+
 	/* Additional Realtek 8761BUV Bluetooth devices */
 	{ USB_DEVICE(0x2357, 0x0604), .driver_info = BTUSB_REALTEK |
 						     BTUSB_WIDEBAND_SPEECH },
diff --git a/drivers/bus/sun50i-de2.c b/drivers/bus/sun50i-de2.c
index dfe588179..47c87d51a 100644
--- a/drivers/bus/sun50i-de2.c
+++ b/drivers/bus/sun50i-de2.c
@@ -31,6 +31,7 @@ static void sun50i_de2_bus_remove(struct platform_device *pdev)
 
 static const struct of_device_id sun50i_de2_bus_of_match[] = {
 	{ .compatible = "allwinner,sun50i-a64-de2", },
+	{ .compatible = "allwinner,sun50i-h616-de33", },
 	{ /* sentinel */ }
 };
 
diff --git a/drivers/gpio/gpiolib-of.c b/drivers/gpio/gpiolib-of.c
index 37ab78243..13fbd2fb7 100644
--- a/drivers/gpio/gpiolib-of.c
+++ b/drivers/gpio/gpiolib-of.c
@@ -25,21 +25,6 @@
 #include "gpiolib.h"
 #include "gpiolib-of.h"
 
-/*
- * This is Linux-specific flags. By default controllers' and Linux' mapping
- * match, but GPIO controllers are free to translate their own flags to
- * Linux-specific in their .xlate callback. Though, 1:1 mapping is recommended.
- */
-enum of_gpio_flags {
-	OF_GPIO_ACTIVE_LOW = 0x1,
-	OF_GPIO_SINGLE_ENDED = 0x2,
-	OF_GPIO_OPEN_DRAIN = 0x4,
-	OF_GPIO_TRANSITORY = 0x8,
-	OF_GPIO_PULL_UP = 0x10,
-	OF_GPIO_PULL_DOWN = 0x20,
-	OF_GPIO_PULL_DISABLE = 0x40,
-};
-
 /**
  * of_gpio_named_count() - Count GPIOs for a device
  * @np:		device node to count GPIOs for
@@ -446,6 +431,20 @@ static struct gpio_desc *of_get_named_gpiod_flags(const struct device_node *np,
 	return desc;
 }
 
+int of_get_named_gpio_flags(const struct device_node *np, const char *list_name,
+			    int index, enum of_gpio_flags *flags)
+{
+	struct gpio_desc *desc;
+
+	desc = of_get_named_gpiod_flags(np, list_name, index, flags);
+
+	if (IS_ERR(desc))
+		return PTR_ERR(desc);
+	else
+		return desc_to_gpio(desc);
+}
+EXPORT_SYMBOL_GPL(of_get_named_gpio_flags);
+
 /**
  * of_get_named_gpio() - Get a GPIO number to use with GPIO API
  * @np:		device node to get GPIO from
diff --git a/drivers/gpu/drm/panel/Kconfig b/drivers/gpu/drm/panel/Kconfig
index cfebb08e8..b80d42db3 100644
--- a/drivers/gpu/drm/panel/Kconfig
+++ b/drivers/gpu/drm/panel/Kconfig
@@ -428,6 +428,16 @@ config DRM_PANEL_MANTIX_MLAF057WE51
 	  has a resolution of 720x1440 pixels, a built in backlight and touch
 	  controller.
 
+config DRM_PANEL_MIPI
+	tristate "Generic MIPI-DSI/DPI(+SPI) panel"
+	depends on OF
+	depends on SPI || DRM_MIPI_DSI
+	select DRM_MIPI_DBI if SPI
+	depends on BACKLIGHT_CLASS_DEVICE
+	help
+	  Say Y here if you want to enable support for Generic MIPI-DSI /
+	  MIPI-DPI(+SPI) panels.
+
 config DRM_PANEL_NEC_NL8048HL11
 	tristate "NEC NL8048HL11 RGB panel"
 	depends on GPIOLIB && OF && SPI
diff --git a/drivers/gpu/drm/panel/Makefile b/drivers/gpu/drm/panel/Makefile
index 714cbac83..271375b64 100644
--- a/drivers/gpu/drm/panel/Makefile
+++ b/drivers/gpu/drm/panel/Makefile
@@ -42,6 +42,7 @@ obj-$(CONFIG_DRM_PANEL_LG_LB035Q02) += panel-lg-lb035q02.o
 obj-$(CONFIG_DRM_PANEL_LG_LG4573) += panel-lg-lg4573.o
 obj-$(CONFIG_DRM_PANEL_LG_SW43408) += panel-lg-sw43408.o
 obj-$(CONFIG_DRM_PANEL_MAGNACHIP_D53E6EA8966) += panel-magnachip-d53e6ea8966.o
+obj-$(CONFIG_DRM_PANEL_MIPI) += panel-mipi.o
 obj-$(CONFIG_DRM_PANEL_NEC_NL8048HL11) += panel-nec-nl8048hl11.o
 obj-$(CONFIG_DRM_PANEL_NEWVISION_NV3051D) += panel-newvision-nv3051d.o
 obj-$(CONFIG_DRM_PANEL_NEWVISION_NV3052C) += panel-newvision-nv3052c.o
diff --git a/drivers/gpu/drm/panel/panel-mipi.c b/drivers/gpu/drm/panel/panel-mipi.c
new file mode 100644
index 000000000..a4da1fd2e
--- /dev/null
+++ b/drivers/gpu/drm/panel/panel-mipi.c
@@ -0,0 +1,1181 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Generic MIPI-DSI/DPI(+SPI) Panel Driver
+ *
+ * Supported panels:
+ * - A generic MIPI-DSI panel which implements basic DCS
+ * - A generic MIPI-DPI panel which implements basic DCS over SPI
+ *
+ * Copyright (C) 2025, Hironori KIKUCHI <kikuchan98@gmail.com>
+ */
+
+#include <drm/drm_mipi_dbi.h>
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include <linux/backlight.h>
+#include <linux/bitfield.h>
+#include <linux/debugfs.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/firmware.h>
+#include <linux/gpio/consumer.h>
+#include <linux/media-bus-format.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/spi/spi.h>
+#include <video/mipi_display.h>
+
+/*
+ * The display panel configuration can be stored in a firmware file,
+ * under the firmware directory of the system.
+ *
+ * The name of the file is `panels/<compatible>.panel`, where the
+ * `<compatible>` is the first string of the `compatible` property
+ * defined in the Device Tree for the device.
+ *
+ * File Layout:
+ *     A binary file composed with the following data:
+ *         <header>
+ *         <config>
+ *         <timings>
+ *         <init-sequence>
+ *
+ * The 'header':
+ *     A `struct panel_firmware_header`.
+ *     The `file_format_version` must be `1`.
+ *
+ * The 'config':
+ *     A `struct panel_firmware_config`.
+ *     The values are in big-endian.
+ *
+ * The 'timings':
+ *     An array of `struct panel_firmware_panel_timing`.
+ *     Its length is `num_timings` in the config.
+ *     The values are in big-endian.
+ *
+ * The 'init-sequence':
+ *     MIPI commands to execute when the display pipeline is enabled.
+ *     This is used to configure the display controller, and it may
+ *     contains panel specific parameters as well.
+ *
+ *     The commands are encoded and stored in a byte array:
+ *
+ *         0x00             : sleep 10 ms
+ *         0x01 <M>         : MIPI command <M> with no arguments
+ *         0x02 <M> <a>     : MIPI command <M> with 1 argument <a>
+ *         0x03 <M> <a> <b> : MIPI command <M> with 2 arguments <a> <b>
+ *                :
+ *         0x7f <M> <...>   : MIPI command <M> with 126 arguments <...>
+ *         0x80             : sleep 100 ms
+ *         0x81 - 0xff      : reserved
+ *
+ *     Example:
+ *         command 0x11
+ *         sleep 10ms
+ *         command 0xb1 arguments 0x01 0x2c 0x2d
+ *         command 0x29
+ *         sleep 130ms
+ *
+ *     Byte sequence:
+ *         0x01 0x11
+ *         0x00
+ *         0x04 0xb1 0x01 0x2c 0x2d
+ *         0x01 0x29
+ *         0x80 0x00 0x00 0x00
+ *
+ */
+static const u8 panel_firmware_magic[15] = {
+	0x50, 0x41, 0x4e, 0x45, 0x4c, 0x2d, 0x46, 0x49,
+	0x52, 0x4d, 0x57, 0x41, 0x52, 0x45, 0x00,
+};
+
+struct panel_firmware_header {
+	u8 magic[15];
+	u8 file_format_version; /* must be 1 */
+} __packed;
+
+struct panel_firmware_config {
+	u16 width_mm, height_mm;
+	u16 rotation;
+	u8 _reserved_1[2];
+	u8 _reserved_2[8];
+
+	u16 reset_delay; /* delay after the reset command, in ms */
+	u16 init_delay; /* delay for sending the initial command sequence, in ms */
+	u16 sleep_delay; /* delay after the sleep command, in ms */
+	u16 backlight_delay; /* delay for enabling the backlight, in ms */
+	u16 _reserved_3[4];
+
+	u16 dsi_lanes; /* unsigned int */
+	u16 dsi_format; /* enum mipi_dsi_pixel_format */
+	u32 dsi_mode_flags; /* unsigned long */
+	u32 bus_flags; /* struct drm_bus_flags */
+	u8 _reserved_4[2];
+	u8 preferred_timing;
+	u8 num_timings;
+} __packed;
+
+struct panel_firmware_panel_timing {
+	u16 hactive;
+	u16 hfp;
+	u16 hslen;
+	u16 hbp;
+
+	u16 vactive;
+	u16 vfp;
+	u16 vslen;
+	u16 vbp;
+
+	u32 dclk; /* in kHz */
+	u32 flags; /* include/drm/drm_modes.h DRM_MODE_FLAG_* */
+
+	u8 _reserved_1[8];
+} __packed;
+
+struct panel_commands {
+	const u8 *data;
+	size_t size;
+};
+
+struct panel_firmware {
+	const struct firmware *blob;
+	const struct panel_firmware_config *config;
+	const struct panel_firmware_panel_timing *timings;
+	struct panel_commands commands;
+};
+
+struct panel_mipi {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct mipi_dbi dbi;
+
+	struct mutex lock;
+
+	struct regulator_bulk_data supplies[2];
+	struct gpio_desc *reset;
+
+	unsigned int reset_delay;
+	unsigned int init_delay;
+	unsigned int sleep_delay;
+	unsigned int backlight_delay;
+
+	unsigned int dsi_lanes;
+	enum mipi_dsi_pixel_format dsi_format;
+
+	/* Panel info */
+	u32 width_mm, height_mm;
+	u32 bus_format, bus_flags;
+	enum drm_panel_orientation orientation;
+
+	struct list_head mode_list;
+
+	struct panel_firmware *firmware;
+	struct panel_commands commands;
+
+	int (*write_command)(struct panel_mipi *mipi, const u8 *buf,
+			     size_t len);
+	int (*read_command)(struct panel_mipi *mipi, u8 cmd, u8 *buf,
+			    size_t len);
+
+	/* debugfs */
+	struct dentry *debugfs;
+	u8 recvbuf[1024];
+	size_t recvlen;
+	int display_id;
+};
+
+static inline struct panel_mipi *to_panel_mipi(struct drm_panel *panel)
+{
+	return container_of(panel, struct panel_mipi, panel);
+}
+
+static int panel_mipi_dsi_write(struct panel_mipi *mipi, const u8 *buf,
+				size_t len)
+{
+	int ret;
+
+	ret = mipi_dsi_dcs_write_buffer(mipi->dsi, buf, len);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int panel_mipi_dbi_write(struct panel_mipi *mipi, const u8 *buf,
+				size_t len)
+{
+	return mipi_dbi_command_stackbuf(&mipi->dbi, buf[0], buf + 1, len - 1);
+}
+
+#define panel_mipi_write(mipi, ...)                                \
+	({                                                         \
+		u8 _buf[] = { __VA_ARGS__ };                       \
+		mipi->write_command(mipi, _buf, ARRAY_SIZE(_buf)); \
+	})
+
+static int panel_mipi_dsi_read(struct panel_mipi *mipi, u8 cmd, u8 *buf,
+			       size_t len)
+{
+	int ret;
+
+	ret = mipi_dsi_set_maximum_return_packet_size(mipi->dsi, len);
+	if (ret)
+		return ret;
+
+	ret = mipi_dsi_dcs_read(mipi->dsi, cmd, buf, len);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int panel_mipi_dbi_read(struct panel_mipi *mipi, u8 cmd, u8 *buf,
+			       size_t len)
+{
+	void *recvbuf;
+	int err;
+
+	/* alloc DMA-safe buffer */
+	recvbuf = kzalloc(len, GFP_KERNEL);
+	if (!recvbuf)
+		return -ENOMEM;
+
+	err = mipi_dbi_command_buf(&mipi->dbi, cmd, recvbuf, len);
+	if (!err)
+		memcpy(buf, recvbuf, len);
+
+	kfree(recvbuf);
+
+	return err;
+}
+
+#define panel_mipi_read(mipi, cmd, buf, len) \
+	(mipi)->read_command((mipi), (cmd), (buf), (len))
+
+static unsigned long panel_mipi_dsi_set_mode_flags(struct panel_mipi *mipi,
+						   unsigned long new_flags)
+{
+	unsigned long old_flags;
+
+	if (!mipi->dsi)
+		return 0;
+
+	old_flags = mipi->dsi->mode_flags;
+
+	mipi->dsi->mode_flags = new_flags;
+
+	return old_flags;
+}
+
+static bool panel_mipi_dsi_set_lpm(struct panel_mipi *mipi, bool set)
+{
+	unsigned long old_flags;
+
+	if (!mipi->dsi)
+		return false;
+
+	old_flags = panel_mipi_dsi_set_mode_flags(
+		mipi, set ? mipi->dsi->mode_flags | MIPI_DSI_MODE_LPM :
+			    mipi->dsi->mode_flags & ~MIPI_DSI_MODE_LPM);
+
+	return old_flags & MIPI_DSI_MODE_LPM ? true : false;
+}
+
+#define PANEL_MIPI_TRANSACTION(mipi, stmt)   \
+	do {                                 \
+		mutex_lock(&(mipi)->lock);   \
+		do {                         \
+			stmt;                \
+		} while (0);                 \
+		mutex_unlock(&(mipi)->lock); \
+	} while (0)
+
+#define PANEL_MIPI_TRANSACTION_LPM(mipi, lpm, stmt)                       \
+	PANEL_MIPI_TRANSACTION(                                           \
+		mipi,                                                     \
+		bool _lpm_backup = panel_mipi_dsi_set_lpm((mipi), (lpm)); \
+		do { stmt; } while (0);                                   \
+		panel_mipi_dsi_set_lpm((mipi), _lpm_backup))
+
+static int panel_mipi_validate_commands(struct panel_mipi *mipi, const u8 *data,
+					size_t size, size_t *valid_len)
+{
+	size_t i = 0;
+
+	/* sanity check */
+	while (i < size) {
+		u8 inst = data[i];
+		bool ext = (inst & 0x80) ? true : false;
+		u8 len = inst & 0x7f;
+
+		if (ext && len > 0)
+			return -EINVAL; /* reserved */
+
+		if (i + 1 + len > size)
+			break;
+
+		i += 1 + len;
+	}
+
+	*valid_len = i;
+
+	return 0;
+}
+
+static int panel_mipi_load_commands(struct panel_mipi *mipi, const u8 *data,
+				    size_t size)
+{
+	int err;
+	size_t valid_len;
+
+	err = panel_mipi_validate_commands(mipi, data, size, &valid_len);
+	if (err)
+		return err;
+
+	if (valid_len != size)
+		return -EINVAL;
+
+	mipi->commands.data = data;
+	mipi->commands.size = size;
+
+	return 0;
+}
+
+static int panel_mipi_write_commands(struct panel_mipi *mipi, const u8 *data,
+				     size_t size)
+{
+	const u8 *read_commands;
+	unsigned int write_memory_bpw;
+	size_t i = 0;
+	int err = 0;
+
+	if (!data)
+		return 0;
+
+	/*
+	 * Disable interpretation for special commands for DBI
+	 *
+	 * This is required because the vendor specific custom commands
+	 * may change its command set to the other.
+	 */
+	read_commands = mipi->dbi.read_commands;
+	write_memory_bpw = mipi->dbi.write_memory_bpw;
+	mipi->dbi.read_commands = NULL;
+	mipi->dbi.write_memory_bpw = 8;
+
+	while (i < size) {
+		u8 inst = data[i++];
+		bool ext = (inst & 0x80) ? true : false;
+		u8 len = inst & 0x7f;
+
+		if (len == 0x00) {
+			msleep(ext ? 100 : 10);
+			continue;
+		}
+
+		err = mipi->write_command(mipi, data + i, len);
+		if (err)
+			break;
+
+		i += len;
+	}
+
+	/* restore */
+	mipi->dbi.read_commands = read_commands;
+	mipi->dbi.write_memory_bpw = write_memory_bpw;
+
+	return err;
+}
+
+static int panel_mipi_read_firmware(const struct device *dev,
+				    struct panel_mipi *mipi,
+				    const struct panel_firmware *firmware)
+{
+	int rotation;
+	int err;
+
+	err = panel_mipi_load_commands(mipi, firmware->commands.data,
+				       firmware->commands.size);
+	if (err) {
+		dev_err(dev, "firmware: Malformed command sequence\n");
+		return err;
+	}
+
+	mipi->width_mm = be16_to_cpu(firmware->config->width_mm);
+	mipi->height_mm = be16_to_cpu(firmware->config->height_mm);
+
+	rotation = be16_to_cpu(firmware->config->rotation);
+	if (rotation == 0)
+		mipi->orientation = DRM_MODE_PANEL_ORIENTATION_NORMAL;
+	else if (rotation == 90)
+		mipi->orientation = DRM_MODE_PANEL_ORIENTATION_RIGHT_UP;
+	else if (rotation == 180)
+		mipi->orientation = DRM_MODE_PANEL_ORIENTATION_BOTTOM_UP;
+	else if (rotation == 270)
+		mipi->orientation = DRM_MODE_PANEL_ORIENTATION_LEFT_UP;
+	else {
+		dev_err(dev, "firmware: Invalid rotation %u\n", rotation);
+		return -EINVAL;
+	}
+
+	mipi->reset_delay = be16_to_cpu(firmware->config->reset_delay);
+	mipi->init_delay = be16_to_cpu(firmware->config->init_delay);
+	mipi->sleep_delay = be16_to_cpu(firmware->config->sleep_delay);
+	mipi->backlight_delay = be16_to_cpu(firmware->config->backlight_delay);
+
+	mipi->bus_flags = be32_to_cpu(firmware->config->bus_flags);
+
+	return 0;
+}
+
+static struct panel_firmware *panel_mipi_load_firmware(struct device *dev)
+{
+	const struct firmware *blob;
+	const struct panel_firmware_header *hdr;
+	const struct panel_firmware_config *config;
+	const struct panel_firmware_panel_timing *timings;
+	struct panel_firmware *firmware;
+	const char *firmware_name;
+	size_t command_offset;
+	char filename[128];
+	int err;
+
+	err = of_property_read_string_index(dev->of_node, "compatible", 0,
+					    &firmware_name);
+	if (err)
+		return ERR_PTR(err);
+
+	snprintf(filename, sizeof(filename), "panels/%s.panel", firmware_name);
+	err = request_firmware(&blob, filename, dev);
+	if (err)
+		return ERR_PTR(err);
+
+	hdr = (const struct panel_firmware_header *)blob->data;
+
+	if (blob->size < sizeof(*hdr)) {
+		dev_err(dev, "firmware: %s: file size %zu is too small\n",
+			filename, blob->size);
+		err = -EINVAL;
+		goto err;
+	}
+
+	if (memcmp(hdr->magic, panel_firmware_magic, sizeof(hdr->magic))) {
+		dev_err(dev, "firmware: %s: Bad magic %15ph\n", filename,
+			hdr->magic);
+		err = -EINVAL;
+		goto err;
+	}
+
+	if (hdr->file_format_version != 1) {
+		dev_err(dev, "firmware: %s: version %u is not supported\n",
+			filename, hdr->file_format_version);
+		err = -EINVAL;
+		goto err;
+	}
+
+	config = (struct panel_firmware_config *)(blob->data + sizeof(*hdr));
+	timings = (struct panel_firmware_panel_timing *)(blob->data +
+							 sizeof(*hdr) +
+							 sizeof(*config));
+	command_offset = sizeof(*hdr) + sizeof(*config) +
+			 config->num_timings * sizeof(*timings);
+	if (blob->size < command_offset) {
+		dev_err(dev, "firmware: %s: file size %zu is too small\n",
+			filename, blob->size);
+		err = -EINVAL;
+		goto err;
+	}
+
+	firmware = devm_kzalloc(dev, sizeof(*firmware), GFP_KERNEL);
+	if (!firmware) {
+		err = -ENOMEM;
+		goto err;
+	}
+
+	firmware->blob = blob;
+	firmware->config = config;
+	firmware->timings = timings;
+	firmware->commands.data = blob->data + command_offset;
+	firmware->commands.size = blob->size - command_offset;
+
+	dev_info(dev, "firmware: %s: loaded successfully\n", filename);
+
+	return firmware;
+
+err:
+	release_firmware(blob);
+
+	return ERR_PTR(err);
+}
+
+static int panel_mipi_read_display_id(struct panel_mipi *mipi)
+{
+	u8 buf[3];
+	int err;
+
+	err = panel_mipi_read(mipi, MIPI_DCS_GET_DISPLAY_ID, buf, sizeof(buf));
+
+	return err ? err : ((buf[0] << 16) | (buf[1] << 8) | buf[2]);
+}
+
+static int panel_mipi_enable(struct drm_panel *panel)
+{
+	struct panel_mipi *mipi = to_panel_mipi(panel);
+	int err;
+
+	PANEL_MIPI_TRANSACTION(mipi, {
+		err = panel_mipi_write(mipi, MIPI_DCS_SET_DISPLAY_ON);
+	});
+	if (err)
+		return err;
+
+	if (panel->backlight) {
+		/* Wait for the picture to be ready before enabling backlight */
+		msleep(mipi->backlight_delay);
+	}
+
+	return 0;
+}
+
+static int panel_mipi_disable(struct drm_panel *panel)
+{
+	struct panel_mipi *mipi = to_panel_mipi(panel);
+	int err = 0;
+
+	PANEL_MIPI_TRANSACTION(mipi, {
+		err = panel_mipi_write(mipi, MIPI_DCS_SET_DISPLAY_OFF);
+	});
+
+	return err;
+}
+
+static int panel_mipi_prepare(struct drm_panel *panel)
+{
+	struct panel_mipi *mipi = to_panel_mipi(panel);
+	int err, display_id;
+
+	err = regulator_bulk_enable(ARRAY_SIZE(mipi->supplies), mipi->supplies);
+	if (err)
+		return err;
+
+	PANEL_MIPI_TRANSACTION(mipi, {
+		/* Reset the chip */
+		if (mipi->reset) {
+			gpiod_set_value_cansleep(mipi->reset, 1);
+			msleep(mipi->reset_delay);
+			gpiod_set_value_cansleep(mipi->reset, 0);
+		}
+
+		msleep(mipi->init_delay);
+
+		/* Read the Display ID */
+		mipi->display_id = panel_mipi_read_display_id(mipi);
+		if (mipi->display_id >= 0)
+			dev_info(panel->dev, "MIPI Display ID: %06x\n",
+				 mipi->display_id);
+		else
+			dev_warn(panel->dev, "MIPI Display ID: Unknown\n");
+
+		/* Write the init-sequence */
+		err = panel_mipi_write_commands(mipi, mipi->commands.data,
+						mipi->commands.size);
+		if (err)
+			break;
+
+		/* Ensure to exit from a sleep mode */
+		err = panel_mipi_write(mipi, MIPI_DCS_EXIT_SLEEP_MODE);
+		if (err)
+			break;
+		msleep(mipi->sleep_delay);
+
+		/*
+		 * Read the Display ID again,
+		 * because the init-sequence might have changed the ID.
+		 */
+		display_id = panel_mipi_read_display_id(mipi);
+		if (display_id >= 0 && display_id != mipi->display_id)
+			dev_info(panel->dev, "MIPI Display ID changed: %06x\n",
+				 display_id);
+	});
+
+	if (err) {
+		dev_err(panel->dev, "Failed to prepare the panel\n");
+		regulator_bulk_disable(ARRAY_SIZE(mipi->supplies),
+				       mipi->supplies);
+		return err;
+	}
+
+	return 0;
+}
+
+static int panel_mipi_unprepare(struct drm_panel *panel)
+{
+	struct panel_mipi *mipi = to_panel_mipi(panel);
+	int err;
+
+	PANEL_MIPI_TRANSACTION(mipi, {
+		err = panel_mipi_write(mipi, MIPI_DCS_ENTER_SLEEP_MODE);
+		if (err)
+			dev_warn(panel->dev, "Failed to enter a sleep mode\n");
+		msleep(mipi->sleep_delay);
+	});
+
+	if (mipi->reset) {
+		gpiod_set_value_cansleep(mipi->reset, 1);
+		msleep(mipi->reset_delay);
+	}
+
+	regulator_bulk_disable(ARRAY_SIZE(mipi->supplies), mipi->supplies);
+
+	return 0;
+}
+
+static int panel_mipi_get_modes(struct drm_panel *panel,
+				struct drm_connector *connector)
+{
+	struct panel_mipi *mipi = to_panel_mipi(panel);
+	struct drm_display_mode *mode;
+	unsigned int count = 0;
+
+	list_for_each_entry(mode, &mipi->mode_list, head) {
+		struct drm_display_mode *dmode;
+
+		dmode = drm_mode_duplicate(connector->dev, mode);
+		if (!dmode)
+			return -EINVAL;
+
+		drm_mode_probed_add(connector, dmode);
+		count++;
+	}
+
+	connector->display_info.bpc = 8;
+	connector->display_info.width_mm = mipi->width_mm;
+	connector->display_info.height_mm = mipi->height_mm;
+	connector->display_info.bus_flags = mipi->bus_flags;
+	drm_display_info_set_bus_formats(&connector->display_info,
+					 &mipi->bus_format, 1);
+
+	/*
+	 * TODO: Remove once all drm drivers call
+	 * drm_connector_set_orientation_from_panel()
+	 */
+	drm_connector_set_panel_orientation(connector, mipi->orientation);
+
+	return count;
+}
+
+static enum drm_panel_orientation
+panel_mipi_get_orientation(struct drm_panel *panel)
+{
+	struct panel_mipi *mipi = to_panel_mipi(panel);
+
+	return mipi->orientation;
+}
+
+#ifdef CONFIG_DEBUG_FS
+
+static int display_id_show(struct seq_file *s, void *data)
+{
+	struct drm_panel *panel = s->private;
+	struct panel_mipi *mipi = to_panel_mipi(panel);
+	int display_id;
+
+	PANEL_MIPI_TRANSACTION(mipi, {
+		display_id = panel_mipi_read_display_id(mipi);
+	});
+
+	if (display_id >= 0)
+		seq_printf(s, "%06x\n", display_id);
+	else
+		seq_puts(s, "Unknown\n");
+
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(display_id);
+
+static int initial_display_id_show(struct seq_file *s, void *data)
+{
+	struct drm_panel *panel = s->private;
+	struct panel_mipi *mipi = to_panel_mipi(panel);
+
+	if (mipi->display_id >= 0)
+		seq_printf(s, "%06x\n", mipi->display_id);
+	else
+		seq_puts(s, "Unknown\n");
+
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(initial_display_id);
+
+static int commands_open(struct inode *inode, struct file *file)
+{
+	struct panel_mipi *mipi = inode->i_private;
+
+	mipi->recvlen = 0;
+	file->private_data = mipi;
+
+	return 0;
+}
+
+static ssize_t commands_write(struct file *file, const char __user *data,
+			      size_t size, loff_t *pos)
+{
+	struct panel_mipi *mipi = file->private_data;
+	ssize_t s = min_t(u64, sizeof(mipi->recvbuf) - mipi->recvlen, size);
+	size_t valid_len;
+	int err;
+
+	if (!s || !mipi)
+		return -EINVAL;
+
+	if (copy_from_user(mipi->recvbuf + mipi->recvlen, data, s))
+		return -EINVAL;
+
+	mipi->recvlen += s;
+
+	err = panel_mipi_validate_commands(mipi, mipi->recvbuf, mipi->recvlen,
+					   &valid_len);
+	if (err)
+		return err;
+
+	if (valid_len > 0) {
+		PANEL_MIPI_TRANSACTION(mipi, {
+			err = panel_mipi_write_commands(mipi, mipi->recvbuf,
+							valid_len);
+		});
+		if (err)
+			return err;
+
+		mipi->recvlen -= valid_len;
+		if (mipi->recvlen)
+			memmove(mipi->recvbuf, mipi->recvbuf + valid_len,
+				mipi->recvlen);
+	}
+
+	return s;
+}
+
+static int commands_release(struct inode *inode, struct file *file)
+{
+	struct panel_mipi *mipi = inode->i_private;
+
+	if (mipi->recvlen) {
+		dev_err(mipi->panel.dev, "Premature end of commands\n");
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static const struct file_operations commands_fops = {
+	.owner = THIS_MODULE,
+	.open = commands_open,
+	.write = commands_write,
+	.release = commands_release,
+};
+
+#endif
+
+static void panel_mipi_debugfs_init(struct device *dev, struct panel_mipi *mipi)
+{
+#ifdef CONFIG_DEBUG_FS
+	struct dentry *dir;
+
+	mipi->debugfs = debugfs_lookup("panel-mipi", NULL);
+	if (!mipi->debugfs)
+		mipi->debugfs = debugfs_create_dir("panel-mipi", NULL);
+
+	dir = debugfs_create_dir(dev_name(dev), mipi->debugfs);
+	debugfs_create_file("display-id", 0600, dir, mipi, &display_id_fops);
+	debugfs_create_file("initial-display-id", 0600, dir, mipi,
+			    &initial_display_id_fops);
+	debugfs_create_file("commands", 0600, dir, mipi, &commands_fops);
+#endif
+}
+
+static void panel_mipi_debugfs_remove(struct panel_mipi *mipi)
+{
+#ifdef CONFIG_DEBUG_FS
+	debugfs_remove_recursive(mipi->debugfs);
+	mipi->debugfs = NULL;
+#endif
+}
+
+static const struct drm_panel_funcs panel_mipi_funcs = {
+	.prepare = panel_mipi_prepare,
+	.unprepare = panel_mipi_unprepare,
+	.enable = panel_mipi_enable,
+	.disable = panel_mipi_disable,
+	.get_modes = panel_mipi_get_modes,
+	.get_orientation = panel_mipi_get_orientation,
+};
+
+static int panel_mipi_add_mode(struct device *dev, struct panel_mipi *mipi,
+			       const struct drm_display_mode *src_mode)
+{
+	struct drm_display_mode *mode;
+
+	mode = devm_kzalloc(dev, sizeof(*mode), GFP_KERNEL);
+	if (!mode)
+		return -ENOMEM;
+
+	drm_mode_copy(mode, src_mode);
+
+	if (!mode->clock)
+		mode->clock = mode->htotal * mode->vtotal * 60 / 1000;
+
+	mode->type |= DRM_MODE_TYPE_DRIVER;
+
+	dev_info(dev, "Modeline " DRM_MODE_FMT " added\n", DRM_MODE_ARG(mode));
+
+	list_add_tail(&mode->head, &mipi->mode_list);
+
+	return 0;
+}
+
+static int panel_mipi_firmware_read_modes(const struct panel_firmware *firmware,
+					  struct drm_display_mode *mode,
+					  unsigned int i)
+{
+	const struct panel_firmware_panel_timing *timings =
+		&firmware->timings[i];
+
+	if (!firmware || i >= firmware->config->num_timings)
+		return -ENOENT;
+
+	if (!timings->hactive || !timings->vactive)
+		return -ENOENT;
+
+	memset(mode, 0, sizeof(*mode));
+
+	mode->clock = be32_to_cpu(timings->dclk);
+
+	mode->hdisplay = be16_to_cpu(timings->hactive);
+	mode->hsync_start = mode->hdisplay + be16_to_cpu(timings->hfp);
+	mode->hsync_end = mode->hsync_start + be16_to_cpu(timings->hslen);
+	mode->htotal = mode->hsync_end + be16_to_cpu(timings->hbp);
+
+	mode->vdisplay = be16_to_cpu(timings->vactive);
+	mode->vsync_start = mode->vdisplay + be16_to_cpu(timings->vfp);
+	mode->vsync_end = mode->vsync_start + be16_to_cpu(timings->vslen);
+	mode->vtotal = mode->vsync_end + be16_to_cpu(timings->vbp);
+
+	mode->flags = be32_to_cpu(timings->flags);
+
+	drm_mode_set_name(mode);
+
+	return 0;
+}
+
+static int panel_mipi_probe_modes(struct device *dev, struct panel_mipi *mipi)
+{
+	unsigned int i = 0;
+	struct drm_display_mode mode = {};
+	int err;
+
+	INIT_LIST_HEAD(&mipi->mode_list);
+
+	/* Read from the firmware */
+	for (i = 0; i < mipi->firmware->config->num_timings; i++) {
+		if (!panel_mipi_firmware_read_modes(mipi->firmware, &mode, i)) {
+			if (mipi->firmware->config->preferred_timing == i)
+				mode.type |= DRM_MODE_TYPE_PREFERRED;
+
+			err = panel_mipi_add_mode(dev, mipi, &mode);
+			if (err)
+				return err;
+		}
+	}
+
+	if (list_empty(&mipi->mode_list))
+		return dev_err_probe(dev, -EINVAL, "No modes defined\n");
+
+	return 0;
+}
+
+static void panel_mipi_cleanup(void *data)
+{
+	struct panel_mipi *mipi = (struct panel_mipi *)data;
+
+	panel_mipi_debugfs_remove(mipi);
+
+	drm_panel_remove(&mipi->panel);
+
+	if (mipi->panel.enabled)
+		drm_panel_disable(&mipi->panel);
+
+	if (mipi->panel.prepared)
+		drm_panel_unprepare(&mipi->panel);
+
+	if (mipi->firmware)
+		release_firmware(mipi->firmware->blob);
+}
+
+static int
+panel_mipi_backlight_update_status(struct backlight_device *backlight)
+{
+	struct panel_mipi *mipi = dev_get_drvdata(&backlight->dev);
+	int level = backlight_get_brightness(backlight);
+	int err;
+
+	PANEL_MIPI_TRANSACTION_LPM(mipi, false, {
+		err = panel_mipi_write(mipi, MIPI_DCS_SET_DISPLAY_BRIGHTNESS,
+				       level, level);
+	});
+
+	return err;
+}
+
+static int
+panel_mipi_backlight_get_brightness(struct backlight_device *backlight)
+{
+	return backlight_get_brightness(backlight);
+}
+
+static const struct backlight_ops panel_mipi_backlight_ops = {
+	.get_brightness = panel_mipi_backlight_get_brightness,
+	.update_status = panel_mipi_backlight_update_status,
+};
+
+static int panel_mipi_set_backlight(struct drm_panel *panel, struct device *dev,
+				    struct panel_mipi *mipi)
+{
+	int err;
+
+	err = drm_panel_of_backlight(panel);
+	if (err)
+		return err;
+
+	if (!panel->backlight) {
+		struct backlight_device *backlight = NULL;
+		struct backlight_properties props = {
+			.max_brightness = 255,
+			.type = BACKLIGHT_RAW,
+		};
+
+		backlight = devm_backlight_device_register(
+			dev, dev_name(dev), dev, mipi,
+			&panel_mipi_backlight_ops, &props);
+		if (IS_ERR(backlight))
+			return PTR_ERR(backlight);
+
+		panel->backlight = backlight;
+	}
+
+	return 0;
+}
+
+static int panel_mipi_probe(struct device *dev, int connector_type)
+{
+	struct panel_mipi *mipi;
+	int err;
+
+	mipi = devm_kzalloc(dev, sizeof(*mipi), GFP_KERNEL);
+	if (!mipi)
+		return -ENOMEM;
+
+	mutex_init(&mipi->lock);
+
+	mipi->display_id = -1;
+
+	/* Get `power-supply` and `io-supply` (if any) */
+	mipi->supplies[0].supply = "power";
+	mipi->supplies[1].supply = "io";
+	err = devm_regulator_bulk_get(dev, ARRAY_SIZE(mipi->supplies),
+				      mipi->supplies);
+	if (err < 0) {
+		return dev_err_probe(dev, err,
+				     "%pOF: Failed to get regulators\n",
+				     dev->of_node);
+	}
+
+	/* GPIO for /RESET */
+	mipi->reset = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(mipi->reset))
+		return dev_err_probe(dev, PTR_ERR(mipi->reset),
+				     "%pOF: Failed to get GPIO for RESET\n",
+				     dev->of_node);
+
+	/* Load the firmware */
+	mipi->firmware = panel_mipi_load_firmware(dev);
+	if (IS_ERR(mipi->firmware))
+		return dev_err_probe(dev, PTR_ERR(mipi->firmware),
+				     "Failed to load firmware\n");
+
+	err = panel_mipi_read_firmware(dev, mipi, mipi->firmware);
+	if (err)
+		return err;
+
+	err = panel_mipi_probe_modes(dev, mipi);
+	if (err)
+		return err;
+
+	/* DRM panel setup */
+	drm_panel_init(&mipi->panel, dev, &panel_mipi_funcs, connector_type);
+
+	err = panel_mipi_set_backlight(&mipi->panel, dev, mipi);
+	if (err)
+		return dev_err_probe(dev, err, "Failed to set backlight\n");
+
+	drm_panel_add(&mipi->panel);
+
+	dev_set_drvdata(dev, mipi);
+
+	panel_mipi_debugfs_init(dev, mipi);
+
+	return devm_add_action_or_reset(dev, panel_mipi_cleanup, mipi);
+}
+
+static int panel_mipi_dsi_probe(struct mipi_dsi_device *dsi)
+{
+	struct panel_mipi *mipi;
+	int err;
+
+	err = panel_mipi_probe(&dsi->dev, DRM_MODE_CONNECTOR_DSI);
+	if (err)
+		return err;
+
+	mipi = dev_get_drvdata(&dsi->dev);
+	mipi->dsi = dsi;
+	mipi->write_command = panel_mipi_dsi_write;
+	mipi->read_command = panel_mipi_dsi_read;
+
+	/* Read from the firmware */
+	dsi->lanes = be16_to_cpu(mipi->firmware->config->dsi_lanes);
+	dsi->format = be16_to_cpu(mipi->firmware->config->dsi_format);
+	dsi->mode_flags = be32_to_cpu(mipi->firmware->config->dsi_mode_flags);
+
+	if (!dsi->lanes)
+		return dev_err_probe(&dsi->dev, -EINVAL,
+				     "dsi-lanes == 0 for DSI panel\n");
+
+	/* Adjust bus_format */
+	switch (dsi->format) {
+	case MIPI_DSI_FMT_RGB888:
+		mipi->bus_format = MEDIA_BUS_FMT_RGB888_1X24;
+		break;
+	case MIPI_DSI_FMT_RGB666:
+		mipi->bus_format = MEDIA_BUS_FMT_RGB666_1X24_CPADHI;
+		break;
+	case MIPI_DSI_FMT_RGB666_PACKED:
+		mipi->bus_format = MEDIA_BUS_FMT_RGB666_1X18;
+		break;
+	case MIPI_DSI_FMT_RGB565:
+		mipi->bus_format = MEDIA_BUS_FMT_RGB565_1X16;
+		break;
+	}
+
+	err = mipi_dsi_attach(dsi);
+	if (err)
+		return dev_err_probe(&dsi->dev, err,
+				     "Failed to attach to DSI\n");
+
+	return 0;
+}
+
+static int panel_mipi_spi_probe(struct spi_device *spi)
+{
+	struct panel_mipi *mipi;
+	struct gpio_desc *dc;
+	int err;
+
+	err = panel_mipi_probe(&spi->dev, DRM_MODE_CONNECTOR_DPI);
+	if (err)
+		return err;
+
+	mipi = dev_get_drvdata(&spi->dev);
+	mipi->write_command = panel_mipi_dbi_write;
+	mipi->read_command = panel_mipi_dbi_read;
+
+	dc = devm_gpiod_get_optional(&spi->dev, "dc", GPIOD_OUT_LOW);
+	if (IS_ERR(dc))
+		return dev_err_probe(&spi->dev, PTR_ERR(dc),
+				     "Failed to get GPIO for D/CX\n");
+
+	err = mipi_dbi_spi_init(spi, &mipi->dbi, dc);
+	if (err)
+		return dev_err_probe(&spi->dev, err, "Failed to init SPI\n");
+
+	return 0;
+}
+
+static void panel_mipi_dsi_remove(struct mipi_dsi_device *dsi)
+{
+	mipi_dsi_detach(dsi);
+}
+
+static const struct of_device_id panel_mipi_dsi_of_match[] = {
+	{ .compatible = "panel-mipi-dsi" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, panel_mipi_dsi_of_match);
+
+static const struct of_device_id panel_mipi_spi_of_match[] = {
+	{ .compatible = "panel-mipi-dpi-spi" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, panel_mipi_spi_of_match);
+
+static const struct spi_device_id panel_mipi_spi_ids[] = {
+	{ "panel-mipi-dpi-spi" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(spi, panel_mipi_spi_ids);
+
+static struct mipi_dsi_driver panel_mipi_dsi_driver = {
+	.probe		= panel_mipi_dsi_probe,
+	.remove		= panel_mipi_dsi_remove,
+	.driver = {
+		.name		= "panel-mipi",
+		.of_match_table	= panel_mipi_dsi_of_match,
+	},
+};
+
+static struct spi_driver panel_mipi_spi_driver = {
+	.probe		= panel_mipi_spi_probe,
+	.id_table	= panel_mipi_spi_ids,
+	.driver = {
+		.name		= "panel-mipi",
+		.of_match_table	= panel_mipi_spi_of_match,
+	},
+};
+
+static int __init panel_mipi_driver_init(void)
+{
+	int err;
+
+	if (IS_ENABLED(CONFIG_SPI)) {
+		err = spi_register_driver(&panel_mipi_spi_driver);
+		if (err)
+			return err;
+	}
+
+	if (IS_ENABLED(CONFIG_DRM_MIPI_DSI)) {
+		err = mipi_dsi_driver_register(&panel_mipi_dsi_driver);
+		if (err) {
+			if (IS_ENABLED(CONFIG_SPI))
+				spi_unregister_driver(&panel_mipi_spi_driver);
+			return err;
+		}
+	}
+
+	return 0;
+}
+module_init(panel_mipi_driver_init);
+
+static void __exit panel_mipi_driver_exit(void)
+{
+	if (IS_ENABLED(CONFIG_DRM_MIPI_DSI))
+		mipi_dsi_driver_unregister(&panel_mipi_dsi_driver);
+
+	if (IS_ENABLED(CONFIG_SPI))
+		spi_unregister_driver(&panel_mipi_spi_driver);
+}
+module_exit(panel_mipi_driver_exit);
+
+MODULE_DESCRIPTION("Generic MIPI-DSI/DPI(+SPI) Panel Driver");
+MODULE_AUTHOR("Hironori KIKUCHI <kikuchan98@gmail.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/sun4i/sun4i_rgb.c b/drivers/gpu/drm/sun4i/sun4i_rgb.c
index dfb6acc42..e29c40086 100644
--- a/drivers/gpu/drm/sun4i/sun4i_rgb.c
+++ b/drivers/gpu/drm/sun4i/sun4i_rgb.c
@@ -222,7 +222,7 @@ int sun4i_rgb_init(struct drm_device *drm, struct sun4i_tcon *tcon)
 					 &sun4i_rgb_con_helper_funcs);
 		ret = drm_connector_init(drm, &rgb->connector,
 					 &sun4i_rgb_con_funcs,
-					 DRM_MODE_CONNECTOR_Unknown);
+					 DRM_MODE_CONNECTOR_DSI);
 		if (ret) {
 			dev_err(drm->dev, "Couldn't initialise the rgb connector\n");
 			goto err_cleanup_connector;
diff --git a/drivers/gpu/drm/sun4i/sun4i_tcon.c b/drivers/gpu/drm/sun4i/sun4i_tcon.c
index 960e83c82..f92ea50e4 100644
--- a/drivers/gpu/drm/sun4i/sun4i_tcon.c
+++ b/drivers/gpu/drm/sun4i/sun4i_tcon.c
@@ -1265,6 +1265,10 @@ static int sun4i_tcon_bind(struct device *dev, struct device *master,
 			goto err_free_dclk;
 	}
 
+	regmap_update_bits(tcon->regs, SUN4I_TCON_GCTL_REG,
+			   SUN4I_TCON_GCTL_PAD_SEL,
+			   SUN4I_TCON_GCTL_PAD_SEL);
+
 	if (tcon->quirks->needs_de_be_mux) {
 		/*
 		 * We assume there is no dynamic muxing of backends
@@ -1514,6 +1518,14 @@ static const struct sun4i_tcon_quirks sun8i_a83t_tv_quirks = {
 	.has_channel_1		= true,
 };
 
+static const struct sun4i_tcon_quirks sun8i_r40_lcd_quirks = {
+	.supports_lvds		= true,
+	.has_channel_0		= true,
+	.set_mux		= sun8i_r40_tcon_tv_set_mux,
+	.dclk_min_div		= 1,
+	.setup_lvds_phy		= sun6i_tcon_setup_lvds_phy,
+};
+
 static const struct sun4i_tcon_quirks sun8i_r40_tv_quirks = {
 	.has_channel_1		= true,
 	.polarity_in_ch0	= true,
@@ -1555,6 +1567,7 @@ const struct of_device_id sun4i_tcon_of_table[] = {
 	{ .compatible = "allwinner,sun8i-a33-tcon", .data = &sun8i_a33_quirks },
 	{ .compatible = "allwinner,sun8i-a83t-tcon-lcd", .data = &sun8i_a83t_lcd_quirks },
 	{ .compatible = "allwinner,sun8i-a83t-tcon-tv", .data = &sun8i_a83t_tv_quirks },
+	{ .compatible = "allwinner,sun8i-r40-tcon-lcd", .data = &sun8i_r40_lcd_quirks },
 	{ .compatible = "allwinner,sun8i-r40-tcon-tv", .data = &sun8i_r40_tv_quirks },
 	{ .compatible = "allwinner,sun8i-v3s-tcon", .data = &sun8i_v3s_quirks },
 	{ .compatible = "allwinner,sun9i-a80-tcon-lcd", .data = &sun9i_a80_tcon_lcd_quirks },
diff --git a/drivers/gpu/drm/sun4i/sun4i_tcon.h b/drivers/gpu/drm/sun4i/sun4i_tcon.h
index fa23aa23f..d56c9764f 100644
--- a/drivers/gpu/drm/sun4i/sun4i_tcon.h
+++ b/drivers/gpu/drm/sun4i/sun4i_tcon.h
@@ -19,6 +19,7 @@
 
 #define SUN4I_TCON_GCTL_REG			0x0
 #define SUN4I_TCON_GCTL_TCON_ENABLE			BIT(31)
+#define SUN4I_TCON_GCTL_PAD_SEL				BIT(1)
 #define SUN4I_TCON_GCTL_IOMAP_MASK			BIT(0)
 #define SUN4I_TCON_GCTL_IOMAP_TCON1			(1 << 0)
 #define SUN4I_TCON_GCTL_IOMAP_TCON0			(0 << 0)
diff --git a/drivers/gpu/drm/sun4i/sun8i_csc.c b/drivers/gpu/drm/sun4i/sun8i_csc.c
index 58480d8e4..6f4a2e9c6 100644
--- a/drivers/gpu/drm/sun4i/sun8i_csc.c
+++ b/drivers/gpu/drm/sun4i/sun8i_csc.c
@@ -212,7 +212,7 @@ void sun8i_csc_set_ccsc_coefficients(struct sun8i_mixer *mixer, int layer,
 {
 	u32 base;
 
-	if (mixer->cfg->is_de3) {
+	if (mixer->cfg->de_type == sun8i_mixer_de3) {
 		sun8i_de3_ccsc_set_coefficients(mixer->engine.regs, layer,
 						mode, encoding, range);
 		return;
@@ -228,7 +228,7 @@ void sun8i_csc_enable_ccsc(struct sun8i_mixer *mixer, int layer, bool enable)
 {
 	u32 base;
 
-	if (mixer->cfg->is_de3) {
+	if (mixer->cfg->de_type == sun8i_mixer_de3) {
 		sun8i_de3_ccsc_enable(mixer->engine.regs, layer, enable);
 		return;
 	}
diff --git a/drivers/gpu/drm/sun4i/sun8i_mixer.c b/drivers/gpu/drm/sun4i/sun8i_mixer.c
index 8b41d33ba..c9211a173 100644
--- a/drivers/gpu/drm/sun4i/sun8i_mixer.c
+++ b/drivers/gpu/drm/sun4i/sun8i_mixer.c
@@ -274,6 +274,7 @@ static void sun8i_mixer_commit(struct sunxi_engine *engine,
 {
 	struct sun8i_mixer *mixer = engine_to_sun8i_mixer(engine);
 	u32 bld_base = sun8i_blender_base(mixer);
+	struct regmap *bld_regs = sun8i_blender_regmap(mixer);
 	struct drm_plane_state *plane_state;
 	struct drm_plane *plane;
 	u32 route = 0, pipe_en = 0;
@@ -313,12 +314,13 @@ static void sun8i_mixer_commit(struct sunxi_engine *engine,
 		pipe_en |= SUN8I_MIXER_BLEND_PIPE_CTL_EN(zpos);
 	}
 
-	regmap_write(mixer->engine.regs, SUN8I_MIXER_BLEND_ROUTE(bld_base), route);
-	regmap_write(mixer->engine.regs, SUN8I_MIXER_BLEND_PIPE_CTL(bld_base),
+	regmap_write(bld_regs, SUN8I_MIXER_BLEND_ROUTE(bld_base), route);
+	regmap_write(bld_regs, SUN8I_MIXER_BLEND_PIPE_CTL(bld_base),
 		     pipe_en | SUN8I_MIXER_BLEND_PIPE_CTL_FC_EN(0));
 
-	regmap_write(engine->regs, SUN8I_MIXER_GLOBAL_DBUFF,
-		     SUN8I_MIXER_GLOBAL_DBUFF_ENABLE);
+	if (mixer->cfg->de_type != sun8i_mixer_de33)
+		regmap_write(engine->regs, SUN8I_MIXER_GLOBAL_DBUFF,
+			     SUN8I_MIXER_GLOBAL_DBUFF_ENABLE);
 }
 
 static struct drm_plane **sun8i_layers_init(struct drm_device *drm,
@@ -367,25 +369,31 @@ static void sun8i_mixer_mode_set(struct sunxi_engine *engine,
 				 const struct drm_display_mode *mode)
 {
 	struct sun8i_mixer *mixer = engine_to_sun8i_mixer(engine);
+	struct regmap *bld_regs;
 	u32 bld_base, size, val;
 	bool interlaced;
 
 	bld_base = sun8i_blender_base(mixer);
+	bld_regs = sun8i_blender_regmap(mixer);
 	interlaced = !!(mode->flags & DRM_MODE_FLAG_INTERLACE);
 	size = SUN8I_MIXER_SIZE(mode->hdisplay, mode->vdisplay);
 
 	DRM_DEBUG_DRIVER("Updating global size W: %u H: %u\n",
 			 mode->hdisplay, mode->vdisplay);
 
-	regmap_write(engine->regs, SUN8I_MIXER_GLOBAL_SIZE, size);
-	regmap_write(engine->regs, SUN8I_MIXER_BLEND_OUTSIZE(bld_base), size);
+	if (mixer->cfg->de_type == sun8i_mixer_de33)
+		regmap_write(mixer->top_regs, SUN50I_MIXER_GLOBAL_SIZE, size);
+	else
+		regmap_write(mixer->engine.regs, SUN8I_MIXER_GLOBAL_SIZE, size);
+
+	regmap_write(bld_regs, SUN8I_MIXER_BLEND_OUTSIZE(bld_base), size);
 
 	if (interlaced)
 		val = SUN8I_MIXER_BLEND_OUTCTL_INTERLACED;
 	else
 		val = 0;
 
-	regmap_update_bits(engine->regs, SUN8I_MIXER_BLEND_OUTCTL(bld_base),
+	regmap_update_bits(bld_regs, SUN8I_MIXER_BLEND_OUTCTL(bld_base),
 			   SUN8I_MIXER_BLEND_OUTCTL_INTERLACED, val);
 
 	DRM_DEBUG_DRIVER("Switching display mixer interlaced mode %s\n",
@@ -399,12 +407,29 @@ static const struct sunxi_engine_ops sun8i_engine_ops = {
 };
 
 static const struct regmap_config sun8i_mixer_regmap_config = {
+	.name		= "layers",
 	.reg_bits	= 32,
 	.val_bits	= 32,
 	.reg_stride	= 4,
 	.max_register	= 0xffffc, /* guessed */
 };
 
+static const struct regmap_config sun8i_top_regmap_config = {
+	.name		= "top",
+	.reg_bits	= 32,
+	.val_bits	= 32,
+	.reg_stride	= 4,
+	.max_register	= 0x3c,
+};
+
+static const struct regmap_config sun8i_disp_regmap_config = {
+	.name		= "display",
+	.reg_bits	= 32,
+	.val_bits	= 32,
+	.reg_stride	= 4,
+	.max_register	= 0x20000,
+};
+
 static int sun8i_mixer_of_get_id(struct device_node *node)
 {
 	struct device_node *ep, *remote;
@@ -425,6 +450,50 @@ static int sun8i_mixer_of_get_id(struct device_node *node)
 	return of_ep.id;
 }
 
+static void sun8i_mixer_init(struct sun8i_mixer *mixer)
+{
+	struct regmap *top_regs, *disp_regs;
+	unsigned int base = sun8i_blender_base(mixer);
+	int plane_cnt, i;
+
+	if (mixer->cfg->de_type == sun8i_mixer_de33) {
+		top_regs = mixer->top_regs;
+		disp_regs = mixer->disp_regs;
+	} else {
+		top_regs = mixer->engine.regs;
+		disp_regs = mixer->engine.regs;
+	}
+
+	/* Enable the mixer */
+	regmap_write(top_regs, SUN8I_MIXER_GLOBAL_CTL,
+		     SUN8I_MIXER_GLOBAL_CTL_RT_EN);
+
+	if (mixer->cfg->de_type == sun8i_mixer_de33)
+		regmap_write(top_regs, SUN50I_MIXER_GLOBAL_CLK, 1);
+
+	/* Set background color to black */
+	regmap_write(disp_regs, SUN8I_MIXER_BLEND_BKCOLOR(base),
+		     SUN8I_MIXER_BLEND_COLOR_BLACK);
+
+	/*
+	 * Set fill color of bottom plane to black. Generally not needed
+	 * except when VI plane is at bottom (zpos = 0) and enabled.
+	 */
+	regmap_write(disp_regs, SUN8I_MIXER_BLEND_PIPE_CTL(base),
+		     SUN8I_MIXER_BLEND_PIPE_CTL_FC_EN(0));
+	regmap_write(disp_regs, SUN8I_MIXER_BLEND_ATTR_FCOLOR(base, 0),
+		     SUN8I_MIXER_BLEND_COLOR_BLACK);
+
+	plane_cnt = mixer->cfg->vi_num + mixer->cfg->ui_num;
+	for (i = 0; i < plane_cnt; i++)
+		regmap_write(disp_regs,
+			     SUN8I_MIXER_BLEND_MODE(base, i),
+			     SUN8I_MIXER_BLEND_MODE_DEF);
+
+	regmap_update_bits(disp_regs, SUN8I_MIXER_BLEND_PIPE_CTL(base),
+			   SUN8I_MIXER_BLEND_PIPE_CTL_EN_MSK, 0);
+}
+
 static int sun8i_mixer_bind(struct device *dev, struct device *master,
 			      void *data)
 {
@@ -433,8 +502,6 @@ static int sun8i_mixer_bind(struct device *dev, struct device *master,
 	struct sun4i_drv *drv = drm->dev_private;
 	struct sun8i_mixer *mixer;
 	void __iomem *regs;
-	unsigned int base;
-	int plane_cnt;
 	int i, ret;
 
 	/*
@@ -495,6 +562,30 @@ static int sun8i_mixer_bind(struct device *dev, struct device *master,
 		return PTR_ERR(mixer->engine.regs);
 	}
 
+	if (mixer->cfg->de_type == sun8i_mixer_de33) {
+		regs = devm_platform_ioremap_resource(pdev, 1);
+		if (IS_ERR(regs))
+			return PTR_ERR(regs);
+
+		mixer->top_regs = devm_regmap_init_mmio(dev, regs,
+							&sun8i_top_regmap_config);
+		if (IS_ERR(mixer->top_regs)) {
+			dev_err(dev, "Couldn't create the top regmap\n");
+			return PTR_ERR(mixer->top_regs);
+		}
+
+		regs = devm_platform_ioremap_resource(pdev, 2);
+		if (IS_ERR(regs))
+			return PTR_ERR(regs);
+
+		mixer->disp_regs = devm_regmap_init_mmio(dev, regs,
+							 &sun8i_disp_regmap_config);
+		if (IS_ERR(mixer->disp_regs)) {
+			dev_err(dev, "Couldn't create the disp regmap\n");
+			return PTR_ERR(mixer->disp_regs);
+		}
+	}
+
 	mixer->reset = devm_reset_control_get(dev, NULL);
 	if (IS_ERR(mixer->reset)) {
 		dev_err(dev, "Couldn't get our reset line\n");
@@ -534,10 +625,8 @@ static int sun8i_mixer_bind(struct device *dev, struct device *master,
 
 	list_add_tail(&mixer->engine.list, &drv->engine_list);
 
-	base = sun8i_blender_base(mixer);
-
 	/* Reset registers and disable unused sub-engines */
-	if (mixer->cfg->is_de3) {
+	if (mixer->cfg->de_type == sun8i_mixer_de3) {
 		for (i = 0; i < DE3_MIXER_UNIT_SIZE; i += 4)
 			regmap_write(mixer->engine.regs, i, 0);
 
@@ -551,7 +640,7 @@ static int sun8i_mixer_bind(struct device *dev, struct device *master,
 		regmap_write(mixer->engine.regs, SUN50I_MIXER_FMT_EN, 0);
 		regmap_write(mixer->engine.regs, SUN50I_MIXER_CDC0_EN, 0);
 		regmap_write(mixer->engine.regs, SUN50I_MIXER_CDC1_EN, 0);
-	} else {
+	} else if (mixer->cfg->de_type == sun8i_mixer_de2) {
 		for (i = 0; i < DE2_MIXER_UNIT_SIZE; i += 4)
 			regmap_write(mixer->engine.regs, i, 0);
 
@@ -564,31 +653,7 @@ static int sun8i_mixer_bind(struct device *dev, struct device *master,
 		regmap_write(mixer->engine.regs, SUN8I_MIXER_DCSC_EN, 0);
 	}
 
-	/* Enable the mixer */
-	regmap_write(mixer->engine.regs, SUN8I_MIXER_GLOBAL_CTL,
-		     SUN8I_MIXER_GLOBAL_CTL_RT_EN);
-
-	/* Set background color to black */
-	regmap_write(mixer->engine.regs, SUN8I_MIXER_BLEND_BKCOLOR(base),
-		     SUN8I_MIXER_BLEND_COLOR_BLACK);
-
-	/*
-	 * Set fill color of bottom plane to black. Generally not needed
-	 * except when VI plane is at bottom (zpos = 0) and enabled.
-	 */
-	regmap_write(mixer->engine.regs, SUN8I_MIXER_BLEND_PIPE_CTL(base),
-		     SUN8I_MIXER_BLEND_PIPE_CTL_FC_EN(0));
-	regmap_write(mixer->engine.regs, SUN8I_MIXER_BLEND_ATTR_FCOLOR(base, 0),
-		     SUN8I_MIXER_BLEND_COLOR_BLACK);
-
-	plane_cnt = mixer->cfg->vi_num + mixer->cfg->ui_num;
-	for (i = 0; i < plane_cnt; i++)
-		regmap_write(mixer->engine.regs,
-			     SUN8I_MIXER_BLEND_MODE(base, i),
-			     SUN8I_MIXER_BLEND_MODE_DEF);
-
-	regmap_update_bits(mixer->engine.regs, SUN8I_MIXER_BLEND_PIPE_CTL(base),
-			   SUN8I_MIXER_BLEND_PIPE_CTL_EN_MSK, 0);
+	sun8i_mixer_init(mixer);
 
 	return 0;
 
@@ -628,6 +693,7 @@ static void sun8i_mixer_remove(struct platform_device *pdev)
 
 static const struct sun8i_mixer_cfg sun8i_a83t_mixer0_cfg = {
 	.ccsc		= CCSC_MIXER0_LAYOUT,
+	.de_type	= sun8i_mixer_de2,
 	.scaler_mask	= 0xf,
 	.scanline_yuv	= 2048,
 	.ui_num		= 3,
@@ -636,6 +702,7 @@ static const struct sun8i_mixer_cfg sun8i_a83t_mixer0_cfg = {
 
 static const struct sun8i_mixer_cfg sun8i_a83t_mixer1_cfg = {
 	.ccsc		= CCSC_MIXER1_LAYOUT,
+	.de_type	= sun8i_mixer_de2,
 	.scaler_mask	= 0x3,
 	.scanline_yuv	= 2048,
 	.ui_num		= 1,
@@ -644,6 +711,7 @@ static const struct sun8i_mixer_cfg sun8i_a83t_mixer1_cfg = {
 
 static const struct sun8i_mixer_cfg sun8i_h3_mixer0_cfg = {
 	.ccsc		= CCSC_MIXER0_LAYOUT,
+	.de_type	= sun8i_mixer_de2,
 	.mod_rate	= 432000000,
 	.scaler_mask	= 0xf,
 	.scanline_yuv	= 2048,
@@ -653,6 +721,7 @@ static const struct sun8i_mixer_cfg sun8i_h3_mixer0_cfg = {
 
 static const struct sun8i_mixer_cfg sun8i_r40_mixer0_cfg = {
 	.ccsc		= CCSC_MIXER0_LAYOUT,
+	.de_type	= sun8i_mixer_de2,
 	.mod_rate	= 297000000,
 	.scaler_mask	= 0xf,
 	.scanline_yuv	= 2048,
@@ -662,6 +731,7 @@ static const struct sun8i_mixer_cfg sun8i_r40_mixer0_cfg = {
 
 static const struct sun8i_mixer_cfg sun8i_r40_mixer1_cfg = {
 	.ccsc		= CCSC_MIXER1_LAYOUT,
+	.de_type	= sun8i_mixer_de2,
 	.mod_rate	= 297000000,
 	.scaler_mask	= 0x3,
 	.scanline_yuv	= 2048,
@@ -670,6 +740,7 @@ static const struct sun8i_mixer_cfg sun8i_r40_mixer1_cfg = {
 };
 
 static const struct sun8i_mixer_cfg sun8i_v3s_mixer_cfg = {
+	.de_type = sun8i_mixer_de2,
 	.vi_num = 2,
 	.ui_num = 1,
 	.scaler_mask = 0x3,
@@ -680,6 +751,7 @@ static const struct sun8i_mixer_cfg sun8i_v3s_mixer_cfg = {
 
 static const struct sun8i_mixer_cfg sun20i_d1_mixer0_cfg = {
 	.ccsc		= CCSC_D1_MIXER0_LAYOUT,
+	.de_type	= sun8i_mixer_de2,
 	.mod_rate	= 297000000,
 	.scaler_mask	= 0x3,
 	.scanline_yuv	= 2048,
@@ -689,6 +761,7 @@ static const struct sun8i_mixer_cfg sun20i_d1_mixer0_cfg = {
 
 static const struct sun8i_mixer_cfg sun20i_d1_mixer1_cfg = {
 	.ccsc		= CCSC_MIXER1_LAYOUT,
+	.de_type	= sun8i_mixer_de2,
 	.mod_rate	= 297000000,
 	.scaler_mask	= 0x1,
 	.scanline_yuv	= 1024,
@@ -698,6 +771,7 @@ static const struct sun8i_mixer_cfg sun20i_d1_mixer1_cfg = {
 
 static const struct sun8i_mixer_cfg sun50i_a64_mixer0_cfg = {
 	.ccsc		= CCSC_MIXER0_LAYOUT,
+	.de_type	= sun8i_mixer_de2,
 	.mod_rate	= 297000000,
 	.scaler_mask	= 0xf,
 	.scanline_yuv	= 4096,
@@ -707,6 +781,7 @@ static const struct sun8i_mixer_cfg sun50i_a64_mixer0_cfg = {
 
 static const struct sun8i_mixer_cfg sun50i_a64_mixer1_cfg = {
 	.ccsc		= CCSC_MIXER1_LAYOUT,
+	.de_type	= sun8i_mixer_de2,
 	.mod_rate	= 297000000,
 	.scaler_mask	= 0x3,
 	.scanline_yuv	= 2048,
@@ -716,7 +791,7 @@ static const struct sun8i_mixer_cfg sun50i_a64_mixer1_cfg = {
 
 static const struct sun8i_mixer_cfg sun50i_h6_mixer0_cfg = {
 	.ccsc		= CCSC_MIXER0_LAYOUT,
-	.is_de3		= true,
+	.de_type	= sun8i_mixer_de3,
 	.mod_rate	= 600000000,
 	.scaler_mask	= 0xf,
 	.scanline_yuv	= 4096,
@@ -724,6 +799,17 @@ static const struct sun8i_mixer_cfg sun50i_h6_mixer0_cfg = {
 	.vi_num		= 1,
 };
 
+static const struct sun8i_mixer_cfg sun50i_h616_mixer0_cfg = {
+	.ccsc		= CCSC_MIXER0_LAYOUT,
+	.de_type	= sun8i_mixer_de33,
+	.mod_rate	= 600000000,
+	.scaler_mask	= 0xf,
+	.scanline_yuv	= 4096,
+	.ui_num		= 3,
+	.vi_num		= 1,
+	.map		= {0, 6, 7, 8},
+};
+
 static const struct of_device_id sun8i_mixer_of_table[] = {
 	{
 		.compatible = "allwinner,sun8i-a83t-de2-mixer-0",
@@ -769,6 +855,10 @@ static const struct of_device_id sun8i_mixer_of_table[] = {
 		.compatible = "allwinner,sun50i-h6-de3-mixer-0",
 		.data = &sun50i_h6_mixer0_cfg,
 	},
+	{
+		.compatible = "allwinner,sun50i-h616-de33-mixer-0",
+		.data = &sun50i_h616_mixer0_cfg,
+	},
 	{ }
 };
 MODULE_DEVICE_TABLE(of, sun8i_mixer_of_table);
diff --git a/drivers/gpu/drm/sun4i/sun8i_mixer.h b/drivers/gpu/drm/sun4i/sun8i_mixer.h
index d7898c9c9..d87d19761 100644
--- a/drivers/gpu/drm/sun4i/sun8i_mixer.h
+++ b/drivers/gpu/drm/sun4i/sun8i_mixer.h
@@ -21,6 +21,9 @@
 #define SUN8I_MIXER_GLOBAL_DBUFF		0x8
 #define SUN8I_MIXER_GLOBAL_SIZE			0xc
 
+#define SUN50I_MIXER_GLOBAL_SIZE		0x8
+#define SUN50I_MIXER_GLOBAL_CLK			0xc
+
 #define SUN8I_MIXER_GLOBAL_CTL_RT_EN		BIT(0)
 
 #define SUN8I_MIXER_GLOBAL_DBUFF_ENABLE		BIT(0)
@@ -151,6 +154,12 @@ enum {
 	CCSC_D1_MIXER0_LAYOUT,
 };
 
+enum sun8i_mixer_type {
+	sun8i_mixer_de2,
+	sun8i_mixer_de3,
+	sun8i_mixer_de33,
+};
+
 /**
  * struct sun8i_mixer_cfg - mixer HW configuration
  * @vi_num: number of VI channels
@@ -162,7 +171,7 @@ enum {
  * @ccsc: select set of CCSC base addresses from the enumeration above.
  * @mod_rate: module clock rate that needs to be set in order to have
  *	a functional block.
- * @is_de3: true, if this is next gen display engine 3.0, false otherwise.
+ * @de_type: sun8i_mixer_type enum representing the display engine generation.
  * @scaline_yuv: size of a scanline for VI scaler for YUV formats.
  */
 struct sun8i_mixer_cfg {
@@ -171,8 +180,9 @@ struct sun8i_mixer_cfg {
 	int		scaler_mask;
 	int		ccsc;
 	unsigned long	mod_rate;
-	unsigned int	is_de3 : 1;
+	unsigned int	de_type;
 	unsigned int	scanline_yuv;
+	unsigned int	map[6];
 };
 
 struct sun8i_mixer {
@@ -184,6 +194,9 @@ struct sun8i_mixer {
 
 	struct clk			*bus_clk;
 	struct clk			*mod_clk;
+
+	struct regmap			*top_regs;
+	struct regmap			*disp_regs;
 };
 
 enum {
@@ -214,13 +227,22 @@ engine_to_sun8i_mixer(struct sunxi_engine *engine)
 static inline u32
 sun8i_blender_base(struct sun8i_mixer *mixer)
 {
-	return mixer->cfg->is_de3 ? DE3_BLD_BASE : DE2_BLD_BASE;
+	return mixer->cfg->de_type == sun8i_mixer_de3 ? DE3_BLD_BASE : DE2_BLD_BASE;
+}
+
+static inline struct regmap *
+sun8i_blender_regmap(struct sun8i_mixer *mixer)
+{
+	return mixer->cfg->de_type == sun8i_mixer_de33 ?
+		mixer->disp_regs : mixer->engine.regs;
 }
 
 static inline u32
 sun8i_channel_base(struct sun8i_mixer *mixer, int channel)
 {
-	if (mixer->cfg->is_de3)
+	if (mixer->cfg->de_type == sun8i_mixer_de33)
+		return mixer->cfg->map[channel] * 0x20000 + DE2_CH_SIZE;
+	else if (mixer->cfg->de_type == sun8i_mixer_de3)
 		return DE3_CH_BASE + channel * DE3_CH_SIZE;
 	else
 		return DE2_CH_BASE + channel * DE2_CH_SIZE;
diff --git a/drivers/gpu/drm/sun4i/sun8i_ui_layer.c b/drivers/gpu/drm/sun4i/sun8i_ui_layer.c
index b90e5edef..3eefdb710 100644
--- a/drivers/gpu/drm/sun4i/sun8i_ui_layer.c
+++ b/drivers/gpu/drm/sun4i/sun8i_ui_layer.c
@@ -23,6 +23,7 @@
 #include "sun8i_mixer.h"
 #include "sun8i_ui_layer.h"
 #include "sun8i_ui_scaler.h"
+#include "sun8i_vi_scaler.h"
 
 static void sun8i_ui_layer_update_alpha(struct sun8i_mixer *mixer, int channel,
 					int overlay, struct drm_plane *plane)
@@ -51,6 +52,7 @@ static int sun8i_ui_layer_update_coord(struct sun8i_mixer *mixer, int channel,
 {
 	struct drm_plane_state *state = plane->state;
 	u32 src_w, src_h, dst_w, dst_h;
+	struct regmap *bld_regs;
 	u32 bld_base, ch_base;
 	u32 outsize, insize;
 	u32 hphase, vphase;
@@ -59,6 +61,7 @@ static int sun8i_ui_layer_update_coord(struct sun8i_mixer *mixer, int channel,
 			 channel, overlay);
 
 	bld_base = sun8i_blender_base(mixer);
+	bld_regs = sun8i_blender_regmap(mixer);
 	ch_base = sun8i_channel_base(mixer, channel);
 
 	src_w = drm_rect_width(&state->src) >> 16;
@@ -91,22 +94,34 @@ static int sun8i_ui_layer_update_coord(struct sun8i_mixer *mixer, int channel,
 		hscale = state->src_w / state->crtc_w;
 		vscale = state->src_h / state->crtc_h;
 
-		sun8i_ui_scaler_setup(mixer, channel, src_w, src_h, dst_w,
-				      dst_h, hscale, vscale, hphase, vphase);
-		sun8i_ui_scaler_enable(mixer, channel, true);
+		if (mixer->cfg->de_type == sun8i_mixer_de33) {
+			sun8i_vi_scaler_setup(mixer, channel, src_w, src_h,
+					      dst_w, dst_h, hscale, vscale,
+					      hphase, vphase,
+					      state->fb->format);
+			sun8i_vi_scaler_enable(mixer, channel, true);
+		} else {
+			sun8i_ui_scaler_setup(mixer, channel, src_w, src_h,
+					      dst_w, dst_h, hscale, vscale,
+					      hphase, vphase);
+			sun8i_ui_scaler_enable(mixer, channel, true);
+		}
 	} else {
 		DRM_DEBUG_DRIVER("HW scaling is not needed\n");
-		sun8i_ui_scaler_enable(mixer, channel, false);
+		if (mixer->cfg->de_type == sun8i_mixer_de33)
+			sun8i_vi_scaler_enable(mixer, channel, false);
+		else
+			sun8i_ui_scaler_enable(mixer, channel, false);
 	}
 
 	/* Set base coordinates */
 	DRM_DEBUG_DRIVER("Layer destination coordinates X: %d Y: %d\n",
 			 state->dst.x1, state->dst.y1);
 	DRM_DEBUG_DRIVER("Layer destination size W: %d H: %d\n", dst_w, dst_h);
-	regmap_write(mixer->engine.regs,
+	regmap_write(bld_regs,
 		     SUN8I_MIXER_BLEND_ATTR_COORD(bld_base, zpos),
 		     SUN8I_MIXER_COORD(state->dst.x1, state->dst.y1));
-	regmap_write(mixer->engine.regs,
+	regmap_write(bld_regs,
 		     SUN8I_MIXER_BLEND_ATTR_INSIZE(bld_base, zpos),
 		     outsize);
 
diff --git a/drivers/gpu/drm/sun4i/sun8i_ui_scaler.c b/drivers/gpu/drm/sun4i/sun8i_ui_scaler.c
index ae0806bcc..504ffa097 100644
--- a/drivers/gpu/drm/sun4i/sun8i_ui_scaler.c
+++ b/drivers/gpu/drm/sun4i/sun8i_ui_scaler.c
@@ -93,7 +93,7 @@ static u32 sun8i_ui_scaler_base(struct sun8i_mixer *mixer, int channel)
 {
 	int vi_num = mixer->cfg->vi_num;
 
-	if (mixer->cfg->is_de3)
+	if (mixer->cfg->de_type == sun8i_mixer_de3)
 		return DE3_VI_SCALER_UNIT_BASE +
 		       DE3_VI_SCALER_UNIT_SIZE * vi_num +
 		       DE3_UI_SCALER_UNIT_SIZE * (channel - vi_num);
diff --git a/drivers/gpu/drm/sun4i/sun8i_vi_layer.c b/drivers/gpu/drm/sun4i/sun8i_vi_layer.c
index 9c09d9c08..3d81d23d0 100644
--- a/drivers/gpu/drm/sun4i/sun8i_vi_layer.c
+++ b/drivers/gpu/drm/sun4i/sun8i_vi_layer.c
@@ -25,7 +25,7 @@ static void sun8i_vi_layer_update_alpha(struct sun8i_mixer *mixer, int channel,
 
 	ch_base = sun8i_channel_base(mixer, channel);
 
-	if (mixer->cfg->is_de3) {
+	if (mixer->cfg->de_type >= sun8i_mixer_de3) {
 		mask = SUN50I_MIXER_CHAN_VI_LAYER_ATTR_ALPHA_MASK |
 		       SUN50I_MIXER_CHAN_VI_LAYER_ATTR_ALPHA_MODE_MASK;
 		val = SUN50I_MIXER_CHAN_VI_LAYER_ATTR_ALPHA
@@ -55,6 +55,7 @@ static int sun8i_vi_layer_update_coord(struct sun8i_mixer *mixer, int channel,
 	struct drm_plane_state *state = plane->state;
 	const struct drm_format_info *format = state->fb->format;
 	u32 src_w, src_h, dst_w, dst_h;
+	struct regmap *bld_regs;
 	u32 bld_base, ch_base;
 	u32 outsize, insize;
 	u32 hphase, vphase;
@@ -66,6 +67,7 @@ static int sun8i_vi_layer_update_coord(struct sun8i_mixer *mixer, int channel,
 			 channel, overlay);
 
 	bld_base = sun8i_blender_base(mixer);
+	bld_regs = sun8i_blender_regmap(mixer);
 	ch_base = sun8i_channel_base(mixer, channel);
 
 	src_w = drm_rect_width(&state->src) >> 16;
@@ -183,10 +185,10 @@ static int sun8i_vi_layer_update_coord(struct sun8i_mixer *mixer, int channel,
 	DRM_DEBUG_DRIVER("Layer destination coordinates X: %d Y: %d\n",
 			 state->dst.x1, state->dst.y1);
 	DRM_DEBUG_DRIVER("Layer destination size W: %d H: %d\n", dst_w, dst_h);
-	regmap_write(mixer->engine.regs,
+	regmap_write(bld_regs,
 		     SUN8I_MIXER_BLEND_ATTR_COORD(bld_base, zpos),
 		     SUN8I_MIXER_COORD(state->dst.x1, state->dst.y1));
-	regmap_write(mixer->engine.regs,
+	regmap_write(bld_regs,
 		     SUN8I_MIXER_BLEND_ATTR_INSIZE(bld_base, zpos),
 		     outsize);
 
@@ -483,7 +485,7 @@ struct sun8i_layer *sun8i_vi_layer_init_one(struct drm_device *drm,
 	if (!layer)
 		return ERR_PTR(-ENOMEM);
 
-	if (mixer->cfg->is_de3) {
+	if (mixer->cfg->de_type >= sun8i_mixer_de3) {
 		formats = sun8i_vi_layer_de3_formats;
 		format_count = ARRAY_SIZE(sun8i_vi_layer_de3_formats);
 	} else {
@@ -507,7 +509,7 @@ struct sun8i_layer *sun8i_vi_layer_init_one(struct drm_device *drm,
 
 	plane_cnt = mixer->cfg->ui_num + mixer->cfg->vi_num;
 
-	if (mixer->cfg->vi_num == 1 || mixer->cfg->is_de3) {
+	if (mixer->cfg->vi_num == 1 || mixer->cfg->de_type >= sun8i_mixer_de3) {
 		ret = drm_plane_create_alpha_property(&layer->plane);
 		if (ret) {
 			dev_err(drm->dev, "Couldn't add alpha property\n");
@@ -524,7 +526,7 @@ struct sun8i_layer *sun8i_vi_layer_init_one(struct drm_device *drm,
 
 	supported_encodings = BIT(DRM_COLOR_YCBCR_BT601) |
 			      BIT(DRM_COLOR_YCBCR_BT709);
-	if (mixer->cfg->is_de3)
+	if (mixer->cfg->de_type >= sun8i_mixer_de3)
 		supported_encodings |= BIT(DRM_COLOR_YCBCR_BT2020);
 
 	supported_ranges = BIT(DRM_COLOR_YCBCR_LIMITED_RANGE) |
diff --git a/drivers/gpu/drm/sun4i/sun8i_vi_scaler.c b/drivers/gpu/drm/sun4i/sun8i_vi_scaler.c
index 7ba75011a..6839fd5ab 100644
--- a/drivers/gpu/drm/sun4i/sun8i_vi_scaler.c
+++ b/drivers/gpu/drm/sun4i/sun8i_vi_scaler.c
@@ -835,7 +835,9 @@ static const u32 bicubic4coefftab32[480] = {
 
 static u32 sun8i_vi_scaler_base(struct sun8i_mixer *mixer, int channel)
 {
-	if (mixer->cfg->is_de3)
+	if (mixer->cfg->de_type == sun8i_mixer_de33)
+		return sun8i_channel_base(mixer, channel) + 0x3000;
+	else if (mixer->cfg->de_type == sun8i_mixer_de3)
 		return DE3_VI_SCALER_UNIT_BASE +
 		       DE3_VI_SCALER_UNIT_SIZE * channel;
 	else
@@ -956,7 +958,7 @@ void sun8i_vi_scaler_setup(struct sun8i_mixer *mixer, int layer,
 		cvphase = vphase;
 	}
 
-	if (mixer->cfg->is_de3) {
+	if (mixer->cfg->de_type >= sun8i_mixer_de3) {
 		u32 val;
 
 		if (format->hsub == 1 && format->vsub == 1)
diff --git a/drivers/input/Kconfig b/drivers/input/Kconfig
index 88ecdf521..d5340645e 100644
--- a/drivers/input/Kconfig
+++ b/drivers/input/Kconfig
@@ -51,6 +51,19 @@ config INPUT_FF_MEMLESS
 	  To compile this driver as a module, choose M here: the
 	  module will be called ff-memless.
 
+config INPUT_POLLDEV
+	tristate "Polled input device skeleton"
+	help
+	  Say Y here if you are using a driver for an input
+	  device that periodically polls hardware state. This
+	  option is only useful for out-of-tree drivers since
+	  in-tree drivers select it automatically.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called input-polldev.
+
 config INPUT_SPARSEKMAP
 	tristate "Sparse keymap support library"
 	help
diff --git a/drivers/input/Makefile b/drivers/input/Makefile
index 930b64d21..32e39889a 100644
--- a/drivers/input/Makefile
+++ b/drivers/input/Makefile
@@ -10,6 +10,7 @@ input-core-y := input.o input-compat.o input-mt.o input-poller.o ff-core.o
 input-core-y += touchscreen.o
 
 obj-$(CONFIG_INPUT_FF_MEMLESS)	+= ff-memless.o
+obj-$(CONFIG_INPUT_POLLDEV)	+= input-polldev.o
 obj-$(CONFIG_INPUT_SPARSEKMAP)	+= sparse-keymap.o
 obj-$(CONFIG_INPUT_MATRIXKMAP)	+= matrix-keymap.o
 obj-$(CONFIG_INPUT_VIVALDIFMAP)	+= vivaldi-fmap.o
diff --git a/drivers/input/input-polldev.c b/drivers/input/input-polldev.c
new file mode 100644
index 000000000..9bf1c9aeb
--- /dev/null
+++ b/drivers/input/input-polldev.c
@@ -0,0 +1,362 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Generic implementation of a polled input device
+
+ * Copyright (c) 2007 Dmitry Torokhov
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/jiffies.h>
+#include <linux/slab.h>
+#include <linux/mutex.h>
+#include <linux/workqueue.h>
+#include <linux/module.h>
+#include <linux/input-polldev.h>
+
+MODULE_AUTHOR("Dmitry Torokhov <dtor@mail.ru>");
+MODULE_DESCRIPTION("Generic implementation of a polled input device");
+MODULE_LICENSE("GPL v2");
+
+static void input_polldev_queue_work(struct input_polled_dev *dev)
+{
+	unsigned long delay;
+
+	delay = msecs_to_jiffies(dev->poll_interval);
+	if (delay >= HZ)
+		delay = round_jiffies_relative(delay);
+
+	queue_delayed_work(system_freezable_wq, &dev->work, delay);
+}
+
+static void input_polled_device_work(struct work_struct *work)
+{
+	struct input_polled_dev *dev =
+		container_of(work, struct input_polled_dev, work.work);
+
+	dev->poll(dev);
+	input_polldev_queue_work(dev);
+}
+
+static int input_open_polled_device(struct input_dev *input)
+{
+	struct input_polled_dev *dev = input_get_drvdata(input);
+
+	if (dev->open)
+		dev->open(dev);
+
+	/* Only start polling if polling is enabled */
+	if (dev->poll_interval > 0) {
+		dev->poll(dev);
+		input_polldev_queue_work(dev);
+	}
+
+	return 0;
+}
+
+static void input_close_polled_device(struct input_dev *input)
+{
+	struct input_polled_dev *dev = input_get_drvdata(input);
+
+	cancel_delayed_work_sync(&dev->work);
+
+	if (dev->close)
+		dev->close(dev);
+}
+
+/* SYSFS interface */
+
+static ssize_t input_polldev_get_poll(struct device *dev,
+				      struct device_attribute *attr, char *buf)
+{
+	struct input_polled_dev *polldev = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%d\n", polldev->poll_interval);
+}
+
+static ssize_t input_polldev_set_poll(struct device *dev,
+				struct device_attribute *attr, const char *buf,
+				size_t count)
+{
+	struct input_polled_dev *polldev = dev_get_drvdata(dev);
+	struct input_dev *input = polldev->input;
+	unsigned int interval;
+	int err;
+
+	err = kstrtouint(buf, 0, &interval);
+	if (err)
+		return err;
+
+	if (interval < polldev->poll_interval_min)
+		return -EINVAL;
+
+	if (interval > polldev->poll_interval_max)
+		return -EINVAL;
+
+	mutex_lock(&input->mutex);
+
+	polldev->poll_interval = interval;
+
+	if (input->users) {
+		cancel_delayed_work_sync(&polldev->work);
+		if (polldev->poll_interval > 0)
+			input_polldev_queue_work(polldev);
+	}
+
+	mutex_unlock(&input->mutex);
+
+	return count;
+}
+
+static DEVICE_ATTR(poll, S_IRUGO | S_IWUSR, input_polldev_get_poll,
+					    input_polldev_set_poll);
+
+
+static ssize_t input_polldev_get_max(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	struct input_polled_dev *polldev = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%d\n", polldev->poll_interval_max);
+}
+
+static DEVICE_ATTR(max, S_IRUGO, input_polldev_get_max, NULL);
+
+static ssize_t input_polldev_get_min(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	struct input_polled_dev *polldev = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%d\n", polldev->poll_interval_min);
+}
+
+static DEVICE_ATTR(min, S_IRUGO, input_polldev_get_min, NULL);
+
+static struct attribute *sysfs_attrs[] = {
+	&dev_attr_poll.attr,
+	&dev_attr_max.attr,
+	&dev_attr_min.attr,
+	NULL
+};
+
+static struct attribute_group input_polldev_attribute_group = {
+	.attrs = sysfs_attrs
+};
+
+static const struct attribute_group *input_polldev_attribute_groups[] = {
+	&input_polldev_attribute_group,
+	NULL
+};
+
+/**
+ * input_allocate_polled_device - allocate memory for polled device
+ *
+ * The function allocates memory for a polled device and also
+ * for an input device associated with this polled device.
+ */
+struct input_polled_dev *input_allocate_polled_device(void)
+{
+	struct input_polled_dev *dev;
+
+	dev = kzalloc(sizeof(struct input_polled_dev), GFP_KERNEL);
+	if (!dev)
+		return NULL;
+
+	dev->input = input_allocate_device();
+	if (!dev->input) {
+		kfree(dev);
+		return NULL;
+	}
+
+	return dev;
+}
+EXPORT_SYMBOL(input_allocate_polled_device);
+
+struct input_polled_devres {
+	struct input_polled_dev *polldev;
+};
+
+static int devm_input_polldev_match(struct device *dev, void *res, void *data)
+{
+	struct input_polled_devres *devres = res;
+
+	return devres->polldev == data;
+}
+
+static void devm_input_polldev_release(struct device *dev, void *res)
+{
+	struct input_polled_devres *devres = res;
+	struct input_polled_dev *polldev = devres->polldev;
+
+	dev_dbg(dev, "%s: dropping reference/freeing %s\n",
+		__func__, dev_name(&polldev->input->dev));
+
+	input_put_device(polldev->input);
+	kfree(polldev);
+}
+
+static void devm_input_polldev_unregister(struct device *dev, void *res)
+{
+	struct input_polled_devres *devres = res;
+	struct input_polled_dev *polldev = devres->polldev;
+
+	dev_dbg(dev, "%s: unregistering device %s\n",
+		__func__, dev_name(&polldev->input->dev));
+	input_unregister_device(polldev->input);
+
+	/*
+	 * Note that we are still holding extra reference to the input
+	 * device so it will stick around until devm_input_polldev_release()
+	 * is called.
+	 */
+}
+
+/**
+ * devm_input_allocate_polled_device - allocate managed polled device
+ * @dev: device owning the polled device being created
+ *
+ * Returns prepared &struct input_polled_dev or %NULL.
+ *
+ * Managed polled input devices do not need to be explicitly unregistered
+ * or freed as it will be done automatically when owner device unbinds
+ * from * its driver (or binding fails). Once such managed polled device
+ * is allocated, it is ready to be set up and registered in the same
+ * fashion as regular polled input devices (using
+ * input_register_polled_device() function).
+ *
+ * If you want to manually unregister and free such managed polled devices,
+ * it can be still done by calling input_unregister_polled_device() and
+ * input_free_polled_device(), although it is rarely needed.
+ *
+ * NOTE: the owner device is set up as parent of input device and users
+ * should not override it.
+ */
+struct input_polled_dev *devm_input_allocate_polled_device(struct device *dev)
+{
+	struct input_polled_dev *polldev;
+	struct input_polled_devres *devres;
+
+	devres = devres_alloc(devm_input_polldev_release, sizeof(*devres),
+			      GFP_KERNEL);
+	if (!devres)
+		return NULL;
+
+	polldev = input_allocate_polled_device();
+	if (!polldev) {
+		devres_free(devres);
+		return NULL;
+	}
+
+	polldev->input->dev.parent = dev;
+	polldev->devres_managed = true;
+
+	devres->polldev = polldev;
+	devres_add(dev, devres);
+
+	return polldev;
+}
+EXPORT_SYMBOL(devm_input_allocate_polled_device);
+
+/**
+ * input_free_polled_device - free memory allocated for polled device
+ * @dev: device to free
+ *
+ * The function frees memory allocated for polling device and drops
+ * reference to the associated input device.
+ */
+void input_free_polled_device(struct input_polled_dev *dev)
+{
+	if (dev) {
+		if (dev->devres_managed)
+			WARN_ON(devres_destroy(dev->input->dev.parent,
+						devm_input_polldev_release,
+						devm_input_polldev_match,
+						dev));
+		input_put_device(dev->input);
+		kfree(dev);
+	}
+}
+EXPORT_SYMBOL(input_free_polled_device);
+
+/**
+ * input_register_polled_device - register polled device
+ * @dev: device to register
+ *
+ * The function registers previously initialized polled input device
+ * with input layer. The device should be allocated with call to
+ * input_allocate_polled_device(). Callers should also set up poll()
+ * method and set up capabilities (id, name, phys, bits) of the
+ * corresponding input_dev structure.
+ */
+int input_register_polled_device(struct input_polled_dev *dev)
+{
+	struct input_polled_devres *devres = NULL;
+	struct input_dev *input = dev->input;
+	int error;
+
+	if (dev->devres_managed) {
+		devres = devres_alloc(devm_input_polldev_unregister,
+				      sizeof(*devres), GFP_KERNEL);
+		if (!devres)
+			return -ENOMEM;
+
+		devres->polldev = dev;
+	}
+
+	input_set_drvdata(input, dev);
+	INIT_DELAYED_WORK(&dev->work, input_polled_device_work);
+
+	if (!dev->poll_interval)
+		dev->poll_interval = 500;
+	if (!dev->poll_interval_max)
+		dev->poll_interval_max = dev->poll_interval;
+
+	input->open = input_open_polled_device;
+	input->close = input_close_polled_device;
+
+	input->dev.groups = input_polldev_attribute_groups;
+
+	error = input_register_device(input);
+	if (error) {
+		devres_free(devres);
+		return error;
+	}
+
+	/*
+	 * Take extra reference to the underlying input device so
+	 * that it survives call to input_unregister_polled_device()
+	 * and is deleted only after input_free_polled_device()
+	 * has been invoked. This is needed to ease task of freeing
+	 * sparse keymaps.
+	 */
+	input_get_device(input);
+
+	if (dev->devres_managed) {
+		dev_dbg(input->dev.parent, "%s: registering %s with devres.\n",
+			__func__, dev_name(&input->dev));
+		devres_add(input->dev.parent, devres);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(input_register_polled_device);
+
+/**
+ * input_unregister_polled_device - unregister polled device
+ * @dev: device to unregister
+ *
+ * The function unregisters previously registered polled input
+ * device from input layer. Polling is stopped and device is
+ * ready to be freed with call to input_free_polled_device().
+ */
+void input_unregister_polled_device(struct input_polled_dev *dev)
+{
+	if (dev->devres_managed)
+		WARN_ON(devres_destroy(dev->input->dev.parent,
+					devm_input_polldev_unregister,
+					devm_input_polldev_match,
+					dev));
+
+	input_unregister_device(dev->input);
+}
+EXPORT_SYMBOL(input_unregister_polled_device);
diff --git a/drivers/input/keyboard/adc-keys.c b/drivers/input/keyboard/adc-keys.c
index f17532074..f86f0b3ac 100644
--- a/drivers/input/keyboard/adc-keys.c
+++ b/drivers/input/keyboard/adc-keys.c
@@ -29,6 +29,27 @@ struct adc_keys_state {
 	const struct adc_keys_button *map;
 };
 
+struct input_dev * joypad_input_g;
+EXPORT_SYMBOL(joypad_input_g);
+
+void rk_send_key_f_key_up(void)
+{
+	if (!joypad_input_g)
+		return;
+
+	input_report_key(joypad_input_g, BTN_MODE, 1);
+	input_sync(joypad_input_g);
+}
+
+void rk_send_key_f_key_down(void)
+{
+	if (!joypad_input_g)
+		return;
+
+	input_report_key(joypad_input_g, BTN_MODE, 0);
+	input_sync(joypad_input_g);
+}
+
 static void adc_keys_poll(struct input_dev *input)
 {
 	struct adc_keys_state *st = input_get_drvdata(input);
@@ -53,11 +74,21 @@ static void adc_keys_poll(struct input_dev *input)
 	if (abs(st->keyup_voltage - value) < closest)
 		keycode = 0;
 
-	if (st->last_key && st->last_key != keycode)
-		input_report_key(input, st->last_key, 0);
+	if (st->last_key && st->last_key != keycode) {
+		if (st->last_key == 316) {
+			rk_send_key_f_key_down();
+		} else {
+			input_report_key(input, st->last_key, 0);
+		}
+	}
 
-	if (keycode)
-		input_report_key(input, keycode, 1);
+	if (keycode) {
+		if (keycode == 316) {
+			rk_send_key_f_key_up();
+		} else {
+			input_report_key(input, keycode, 1);
+		}
+	}
 
 	input_sync(input);
 	st->last_key = keycode;
diff --git a/drivers/phy/allwinner/phy-sun4i-usb.c b/drivers/phy/allwinner/phy-sun4i-usb.c
index 29b8fd4b9..47900ea64 100644
--- a/drivers/phy/allwinner/phy-sun4i-usb.c
+++ b/drivers/phy/allwinner/phy-sun4i-usb.c
@@ -464,6 +464,10 @@ static int sun4i_usb_phy_power_on(struct phy *_phy)
 	struct sun4i_usb_phy_data *data = to_sun4i_usb_phy_data(phy);
 	int ret;
 
+	/* phy0 power is controlled by sun4i_usb_phy0_reroute and id_det state */
+	if (phy->index == 0 && data->cfg->phy0_dual_route)
+		return 0;
+
 	if (!phy->vbus || phy->regulator_on)
 		return 0;
 
@@ -492,6 +496,10 @@ static int sun4i_usb_phy_power_off(struct phy *_phy)
 	struct sun4i_usb_phy *phy = phy_get_drvdata(_phy);
 	struct sun4i_usb_phy_data *data = to_sun4i_usb_phy_data(phy);
 
+	/* phy0 power is controlled by sun4i_usb_phy0_reroute and id_det state */
+	if (phy->index == 0 && data->cfg->phy0_dual_route)
+		return 0;
+
 	if (!phy->vbus || !phy->regulator_on)
 		return 0;
 
@@ -535,6 +543,18 @@ static int sun4i_usb_phy_set_mode(struct phy *_phy,
 		return -EINVAL;
 	}
 
+	if (data->cfg->phy0_dual_route) {
+		/*
+		 For SoCs with dual route the PHY mode is fully determined by 
+		 the selected mux route (i.e. USB controller to use).
+		 As both host (EHCI/OHCI) and peripheral (MUSB) controllers uses
+		 the same PHY, both drivers can try to set PHY mode.
+		 We need to ignore this requests, but not report error in case
+		 of valid mode values.
+		*/
+		return 0;
+	}
+
 	if (new_mode != data->dr_mode) {
 		dev_info(&_phy->dev, "Changing dr_mode to %d\n", new_mode);
 		data->dr_mode = new_mode;
@@ -566,15 +586,33 @@ static const struct phy_ops sun4i_usb_phy_ops = {
 
 static void sun4i_usb_phy0_reroute(struct sun4i_usb_phy_data *data, int id_det)
 {
+	struct phy *phy0 = data->phys[0].phy;
+	struct sun4i_usb_phy *phy;
 	u32 regval;
 
+	if (!phy0)
+		return;
+
+	phy = phy_get_drvdata(phy0);
 	regval = readl(data->base + REG_PHY_OTGCTL);
 	if (id_det == 0) {
 		/* Host mode. Route phy0 to EHCI/OHCI */
 		regval &= ~OTGCTL_ROUTE_MUSB;
+
+		/* Enable VBUS reg */
+		if (phy->vbus && !phy->regulator_on) {
+			regulator_enable(phy->vbus);
+			phy->regulator_on = true;
+		}
 	} else {
 		/* Peripheral mode. Route phy0 to MUSB */
 		regval |= OTGCTL_ROUTE_MUSB;
+		
+		/* Disable VBUS reg */
+		if (phy->vbus && phy->regulator_on) {
+			regulator_disable(phy->vbus);
+			phy->regulator_on = false;
+		}
 	}
 	writel(regval, data->base + REG_PHY_OTGCTL);
 }
@@ -602,6 +640,12 @@ static void sun4i_usb_phy0_id_vbus_det_scan(struct work_struct *work)
 		return;
 	}
 
+	/* Disable internal VBUS reg if there is an external VBUS */
+	if (vbus_det != 0 && phy->vbus && phy->regulator_on) {
+		regulator_disable(phy->vbus);
+		phy->regulator_on = false;
+	}
+
 	force_session_end = data->force_session_end;
 	data->force_session_end = false;
 
diff --git a/drivers/power/supply/axp20x_battery.c b/drivers/power/supply/axp20x_battery.c
index 50ca8e110..d75725cee 100644
--- a/drivers/power/supply/axp20x_battery.c
+++ b/drivers/power/supply/axp20x_battery.c
@@ -886,7 +886,7 @@ static int axp717_battery_prop_writeable(struct power_supply *psy,
 }
 
 static const struct power_supply_desc axp209_batt_ps_desc = {
-	.name = "axp20x-battery",
+	.name = "battery",
 	.type = POWER_SUPPLY_TYPE_BATTERY,
 	.properties = axp20x_battery_props,
 	.num_properties = ARRAY_SIZE(axp20x_battery_props),
@@ -896,7 +896,7 @@ static const struct power_supply_desc axp209_batt_ps_desc = {
 };
 
 static const struct power_supply_desc axp717_batt_ps_desc = {
-	.name = "axp20x-battery",
+	.name = "battery",
 	.type = POWER_SUPPLY_TYPE_BATTERY,
 	.properties = axp717_battery_props,
 	.num_properties = ARRAY_SIZE(axp717_battery_props),
diff --git a/drivers/pwm/Kconfig b/drivers/pwm/Kconfig
index d9bcd1e84..4e6af43d5 100644
--- a/drivers/pwm/Kconfig
+++ b/drivers/pwm/Kconfig
@@ -697,6 +697,16 @@ config PWM_SUN4I
 	  To compile this driver as a module, choose M here: the module
 	  will be called pwm-sun4i.
 
+config PWM_SUN20I
+	tristate "Allwinner D1/H616 PWM support"
+	depends on ARCH_SUNXI || COMPILE_TEST
+	depends on HAS_IOMEM && COMMON_CLK
+	help
+	  Generic PWM framework driver for Newer Allwinner SoCs.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called pwm-sun20i.
+
 config PWM_SUNPLUS
 	tristate "Sunplus PWM support"
 	depends on ARCH_SUNPLUS || COMPILE_TEST
diff --git a/drivers/pwm/Makefile b/drivers/pwm/Makefile
index 96160f425..9e36a0401 100644
--- a/drivers/pwm/Makefile
+++ b/drivers/pwm/Makefile
@@ -64,6 +64,7 @@ obj-$(CONFIG_PWM_STM32)		+= pwm-stm32.o
 obj-$(CONFIG_PWM_STM32_LP)	+= pwm-stm32-lp.o
 obj-$(CONFIG_PWM_STMPE)		+= pwm-stmpe.o
 obj-$(CONFIG_PWM_SUN4I)		+= pwm-sun4i.o
+obj-$(CONFIG_PWM_SUN20I)	+= pwm-sun20i.o
 obj-$(CONFIG_PWM_SUNPLUS)	+= pwm-sunplus.o
 obj-$(CONFIG_PWM_TEGRA)		+= pwm-tegra.o
 obj-$(CONFIG_PWM_TIECAP)	+= pwm-tiecap.o
diff --git a/drivers/pwm/pwm-sun20i.c b/drivers/pwm/pwm-sun20i.c
new file mode 100644
index 000000000..1c4ddaa75
--- /dev/null
+++ b/drivers/pwm/pwm-sun20i.c
@@ -0,0 +1,428 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Driver for Allwinner's new PWM Controller (such as D1 / H616 / T5 series)
+ *
+ * Copyright (C) 2024 Hironori KIKUCHI <kikuchan98@gmail.com>
+ *
+ */
+
+#include <linux/bitops.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/gcd.h>
+#include <linux/io.h>
+#include <linux/jiffies.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/pwm.h>
+#include <linux/reset.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/time.h>
+
+// SoC specific offsets
+#define SUN20I_REG_OFFSET_PER_SUN20I (0x0080)
+#define SUN20I_REG_OFFSET_PCR_SUN20I (0x0100 + 0x0000)
+#define SUN20I_REG_OFFSET_PPR_SUN20I (0x0100 + 0x0004)
+#define SUN20I_REG_OFFSET_PER_SUN50I (0x0040)
+#define SUN20I_REG_OFFSET_PCR_SUN50I (0x0060 + 0x0000)
+#define SUN20I_REG_OFFSET_PPR_SUN50I (0x0060 + 0x0004)
+
+// Register offsets
+#define SUN20I_REG_OFFSET_PCCR(chip, ch) (0x0020 + 0x04 * ((ch) >> 1))
+#define SUN20I_REG_OFFSET_PCGR(chip, ch) (0x0040)
+#define SUN20I_REG_OFFSET_PER(chip, ch)	 ((chip)->data->reg_per)
+#define SUN20I_REG_OFFSET_PCR(chip, ch)	 ((chip)->data->reg_pcr + 0x20 * (ch))
+#define SUN20I_REG_OFFSET_PPR(chip, ch)	 ((chip)->data->reg_ppr + 0x20 * (ch))
+
+// PCCR: PWMxx Clock Configuration Register
+#define SUN20I_REG_PCCR_CLK_SRC_MASK   GENMASK(8, 7)
+#define SUN20I_REG_PCCR_CLK_DIV_M_MASK GENMASK(3, 0)
+#define SUN20I_REG_PCCR_CLK_BYPASS(ch) BIT(5 + ((ch) & 1))
+#define SUN20I_REG_PCCR_CLK_GATING(ch) BIT(4)
+
+// PCGR: PWM Clock Gating Register
+#define SUN20I_REG_PCGR_CLK_BYPASS(ch) BIT(16 + (ch))
+#define SUN20I_REG_PCGR_CLK_GATING(ch) BIT(ch)
+
+// PER: PWM Enable Regsiter
+#define SUN20I_REG_PER_ENABLE(ch) BIT(ch)
+
+// PCR: PWM Control Register
+#define SUN20I_REG_PCR_ACT_STA	      BIT(8)
+#define SUN20I_REG_PCR_PRESCAL_K_MASK GENMASK(7, 0)
+
+// PPR: PWM Period Register
+#define SUN20I_REG_PPR_ENTIRE_CYCLE_MASK GENMASK(31, 16)
+#define SUN20I_REG_PPR_ACT_CYCLE_MASK	 GENMASK(15, 0)
+
+// Constants
+#define SUN20I_PWM_CHANNELS_MAX	   (16)
+#define SUN20I_PWM_CLOCK_SRC_HOSC  (0)
+#define SUN20I_PWM_CLOCK_SRC_APB   (1)
+#define SUN20I_PWM_DIV_M_SHIFT_MAX (8)
+#define SUN20I_PWM_PRESCALE_K_MAX  (256)
+#define SUN20I_PWM_ENT_CYCLE_MAX   (0xffffULL)
+
+// Configuration
+#define SUN20I_PWM_DIV_M_SHIFT_DEFAULT (0)
+#define SUN20I_PWM_CLOCK_SRC_DEFAULT   SUN20I_PWM_CLOCK_SRC_HOSC
+
+struct sun20i_pwm_data {
+	unsigned long reg_per;
+	unsigned long reg_pcr;
+	unsigned long reg_ppr;
+	bool has_pcgr;
+};
+
+struct sun20i_pwm_chip {
+	struct clk *clk_bus;
+	struct clk *clk_hosc;
+	struct clk *clk_apb;
+	struct reset_control *rst;
+	void __iomem *base;
+	spinlock_t ctrl_lock;
+	const struct sun20i_pwm_data *data;
+
+	unsigned int clk_src[(SUN20I_PWM_CHANNELS_MAX + 1) / 2];
+	unsigned int div_m_shift[(SUN20I_PWM_CHANNELS_MAX + 1) / 2];
+};
+
+static inline struct sun20i_pwm_chip *to_sun20i_pwm_chip(struct pwm_chip *chip)
+{
+	return pwmchip_get_drvdata(chip);
+}
+
+static inline u32 sun20i_pwm_readl(struct sun20i_pwm_chip *sun20i_chip, unsigned long offset)
+{
+	return readl(sun20i_chip->base + offset);
+}
+
+static inline void sun20i_pwm_writel(struct sun20i_pwm_chip *sun20i_chip, u32 val, unsigned long offset)
+{
+	writel(val, sun20i_chip->base + offset);
+}
+
+static inline bool sun20i_pwm_is_channel_enabled(struct sun20i_pwm_chip *sun20i_chip, int hwpwm)
+{
+	u32 val;
+	val = sun20i_pwm_readl(sun20i_chip, SUN20I_REG_OFFSET_PER(sun20i_chip, hwpwm));
+	return val & SUN20I_REG_PER_ENABLE(hwpwm) ? true : false;
+}
+
+static inline void sun20i_pwm_enable_channel(struct sun20i_pwm_chip *sun20i_chip, struct pwm_device *pwm, bool enable)
+{
+	u32 val;
+
+	// PWM Clock Configuration Register
+	u32 pccr = sun20i_pwm_readl(sun20i_chip, SUN20I_REG_OFFSET_PCCR(sun20i_chip, pwm->hwpwm));
+	if (enable) {
+		unsigned int idx = pwm->hwpwm / 2;
+		// Set clock source
+		pccr &= ~SUN20I_REG_PCCR_CLK_SRC_MASK;
+		pccr |= FIELD_PREP(SUN20I_REG_PCCR_CLK_SRC_MASK, sun20i_chip->clk_src[idx]);
+
+		// Set DIV_M shift
+		pccr &= ~SUN20I_REG_PCCR_CLK_DIV_M_MASK;
+		pccr |= FIELD_PREP(SUN20I_REG_PCCR_CLK_DIV_M_MASK, sun20i_chip->div_m_shift[idx]);
+	}
+
+	if (sun20i_chip->data->has_pcgr) {
+		// PWM Clock Gating Register
+		val = sun20i_pwm_readl(sun20i_chip, SUN20I_REG_OFFSET_PCGR(sun20i_chip, pwm->hwpwm));
+		if (enable) {
+			val &= ~SUN20I_REG_PCGR_CLK_BYPASS(pwm->hwpwm);
+			val |= SUN20I_REG_PCGR_CLK_GATING(pwm->hwpwm);
+		} else {
+			val &= ~SUN20I_REG_PCGR_CLK_GATING(pwm->hwpwm);
+		}
+		sun20i_pwm_writel(sun20i_chip, val, SUN20I_REG_OFFSET_PCGR(sun20i_chip, pwm->hwpwm));
+	} else {
+		// CLK_BYPASS and CLK_GATING are in PCCR otherwise
+		if (enable) {
+			pccr &= ~SUN20I_REG_PCCR_CLK_BYPASS(pwm->hwpwm);
+			pccr |= SUN20I_REG_PCCR_CLK_GATING(pwm->hwpwm);
+		} else if (!sun20i_pwm_is_channel_enabled(sun20i_chip, pwm->hwpwm ^ 1)) {
+			// drop the flag if and only if the counterpart is disabled
+			pccr &= ~SUN20I_REG_PCCR_CLK_GATING(pwm->hwpwm);
+		}
+	}
+
+	sun20i_pwm_writel(sun20i_chip, pccr, SUN20I_REG_OFFSET_PCCR(sun20i_chip, pwm->hwpwm));
+
+	// PWM Enabling
+	val = sun20i_pwm_readl(sun20i_chip, SUN20I_REG_OFFSET_PER(sun20i_chip, pwm->hwpwm));
+	if (enable)
+		val |= SUN20I_REG_PER_ENABLE(pwm->hwpwm);
+	else
+		val &= ~SUN20I_REG_PER_ENABLE(pwm->hwpwm);
+
+	sun20i_pwm_writel(sun20i_chip, val, SUN20I_REG_OFFSET_PER(sun20i_chip, pwm->hwpwm));
+}
+
+static inline u64 sun20i_pwm_get_clock_rate(struct sun20i_pwm_chip *sun20i_chip, unsigned int clksrc)
+{
+	switch (clksrc) {
+	case SUN20I_PWM_CLOCK_SRC_HOSC:
+		return clk_get_rate(sun20i_chip->clk_hosc);
+
+	case SUN20I_PWM_CLOCK_SRC_APB:
+		return clk_get_rate(sun20i_chip->clk_apb);
+
+	default:
+		return 0;
+	}
+}
+
+static int sun20i_pwm_get_state(struct pwm_chip *chip, struct pwm_device *pwm, struct pwm_state *state)
+{
+	struct sun20i_pwm_chip *sun20i_chip = to_sun20i_pwm_chip(chip);
+	u64 clk_rate;
+
+	u32 pccr = sun20i_pwm_readl(sun20i_chip, SUN20I_REG_OFFSET_PCCR(sun20i_chip, pwm->hwpwm));
+	u32 pcr = sun20i_pwm_readl(sun20i_chip, SUN20I_REG_OFFSET_PCR(sun20i_chip, pwm->hwpwm));
+	u32 ppr = sun20i_pwm_readl(sun20i_chip, SUN20I_REG_OFFSET_PPR(sun20i_chip, pwm->hwpwm));
+
+	clk_rate = sun20i_pwm_get_clock_rate(sun20i_chip, FIELD_GET(SUN20I_REG_PCCR_CLK_SRC_MASK, pccr));
+	if (!clk_rate) {
+		dev_err(pwmchip_parent(chip), "Invalid CLK_SRC is detected\n");
+		return -EINVAL;
+	}
+
+	unsigned int prescale_k = FIELD_GET(SUN20I_REG_PCR_PRESCAL_K_MASK, pcr) + 1;
+	u32 ent_cycle = FIELD_GET(SUN20I_REG_PPR_ENTIRE_CYCLE_MASK, ppr) + 1;
+	u32 act_cycle = min(ent_cycle, FIELD_GET(SUN20I_REG_PPR_ACT_CYCLE_MASK, ppr));
+
+	unsigned int div_m_shift = FIELD_GET(SUN20I_REG_PCCR_CLK_DIV_M_MASK, pccr);
+	if (div_m_shift > SUN20I_PWM_DIV_M_SHIFT_MAX) {
+		dev_err(pwmchip_parent(chip), "Invalid DIV_M is detected\n");
+		return -EINVAL;
+	}
+	unsigned int div_m = 1 << div_m_shift;
+
+	// set to the state
+	state->enabled = sun20i_pwm_is_channel_enabled(sun20i_chip, pwm->hwpwm);
+	state->polarity = (pcr & SUN20I_REG_PCR_ACT_STA) ? PWM_POLARITY_NORMAL : PWM_POLARITY_INVERSED;
+	state->period = DIV_ROUND_CLOSEST_ULL(ent_cycle * prescale_k * div_m * NSEC_PER_SEC, clk_rate);
+	state->duty_cycle = DIV_ROUND_CLOSEST_ULL(act_cycle * prescale_k * div_m * NSEC_PER_SEC, clk_rate);
+
+	return 0;
+}
+
+static inline unsigned long sun20i_pwm_find_prescale_k(unsigned long long ent_cycle, unsigned long long act_cycle)
+{
+	if (ent_cycle == 0 || ent_cycle > SUN20I_PWM_ENT_CYCLE_MAX * SUN20I_PWM_PRESCALE_K_MAX || ent_cycle < act_cycle)
+		return 0;
+
+	return clamp(DIV_ROUND_UP_ULL(ent_cycle, SUN20I_PWM_ENT_CYCLE_MAX), 1, SUN20I_PWM_PRESCALE_K_MAX);
+}
+
+static int sun20i_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm, const struct pwm_state *state)
+{
+	struct sun20i_pwm_chip *sun20i_chip = to_sun20i_pwm_chip(chip);
+	u64 clk_rate;
+	u32 ctrl;
+
+	spin_lock(&sun20i_chip->ctrl_lock);
+
+	// Period and Duty cycle
+	if (state->duty_cycle != pwm->state.duty_cycle || state->period != pwm->state.period) {
+		unsigned int idx = pwm->hwpwm / 2;
+		clk_rate = sun20i_pwm_get_clock_rate(sun20i_chip, sun20i_chip->clk_src[idx]);
+		unsigned long div_m = 1U << sun20i_chip->div_m_shift[idx];
+		unsigned long long ent_cycle = DIV_ROUND_CLOSEST(state->period * clk_rate, NSEC_PER_SEC * div_m);
+		unsigned long long act_cycle = min(DIV_ROUND_CLOSEST(state->duty_cycle * clk_rate, NSEC_PER_SEC * div_m), ent_cycle);
+
+		unsigned long prescale_k = sun20i_pwm_find_prescale_k(ent_cycle, act_cycle);
+		if (!prescale_k)
+			goto err;
+
+		ent_cycle = clamp(DIV_ROUND_CLOSEST_ULL(ent_cycle, prescale_k), 1, SUN20I_PWM_ENT_CYCLE_MAX);
+		act_cycle = clamp(DIV_ROUND_CLOSEST_ULL(act_cycle, prescale_k), 0, ent_cycle);
+
+		// Set prescale_k
+		ctrl = sun20i_pwm_readl(sun20i_chip, SUN20I_REG_OFFSET_PCR(sun20i_chip, pwm->hwpwm));
+		ctrl &= ~SUN20I_REG_PCR_PRESCAL_K_MASK;
+		ctrl |= FIELD_PREP(SUN20I_REG_PCR_PRESCAL_K_MASK, prescale_k - 1);
+		sun20i_pwm_writel(sun20i_chip, ctrl, SUN20I_REG_OFFSET_PCR(sun20i_chip, pwm->hwpwm));
+
+		// Set period and duty cycle
+		ctrl = (((ent_cycle - 1) & 0xFFFF) << 16) | (act_cycle & 0xFFFF);
+		sun20i_pwm_writel(sun20i_chip, ctrl, SUN20I_REG_OFFSET_PPR(sun20i_chip, pwm->hwpwm));
+	}
+
+	// Polarity
+	if (state->polarity != pwm->state.polarity) {
+		ctrl = sun20i_pwm_readl(sun20i_chip, SUN20I_REG_OFFSET_PCR(sun20i_chip, pwm->hwpwm));
+		if (state->polarity == PWM_POLARITY_NORMAL) {
+			ctrl |= SUN20I_REG_PCR_ACT_STA;
+		} else {
+			ctrl &= ~SUN20I_REG_PCR_ACT_STA;
+		}
+		sun20i_pwm_writel(sun20i_chip, ctrl, SUN20I_REG_OFFSET_PCR(sun20i_chip, pwm->hwpwm));
+	}
+
+	// Enable
+	if (state->enabled != pwm->state.enabled)
+		sun20i_pwm_enable_channel(sun20i_chip, pwm, state->enabled);
+
+	spin_unlock(&sun20i_chip->ctrl_lock);
+	return 0;
+
+err:
+	spin_unlock(&sun20i_chip->ctrl_lock);
+	return -EINVAL;
+}
+
+static const struct pwm_ops sun20i_pwm_ops = {
+	.apply = sun20i_pwm_apply,
+	.get_state = sun20i_pwm_get_state,
+};
+
+static const struct sun20i_pwm_data sun20i_d1_pwm_data = {
+	.reg_per = SUN20I_REG_OFFSET_PER_SUN20I,
+	.reg_pcr = SUN20I_REG_OFFSET_PCR_SUN20I,
+	.reg_ppr = SUN20I_REG_OFFSET_PPR_SUN20I,
+	.has_pcgr = true,
+};
+
+static const struct sun20i_pwm_data sun50i_h616_pwm_data = {
+	.reg_per = SUN20I_REG_OFFSET_PER_SUN50I,
+	.reg_pcr = SUN20I_REG_OFFSET_PCR_SUN50I,
+	.reg_ppr = SUN20I_REG_OFFSET_PPR_SUN50I,
+	.has_pcgr = false,
+};
+
+static const struct of_device_id sun20i_pwm_dt_ids[] = {
+	{
+		.compatible = "allwinner,sun20i-d1-pwm",
+		.data = &sun20i_d1_pwm_data,
+	},
+	{
+		.compatible = "allwinner,sun50i-h616-pwm",
+		.data = &sun50i_h616_pwm_data,
+	},
+	{
+		/* sentinel */
+	},
+};
+MODULE_DEVICE_TABLE(of, sun20i_pwm_dt_ids);
+
+static int sun20i_pwm_probe(struct platform_device *pdev)
+{
+	struct pwm_chip *chip;
+	const struct sun20i_pwm_data *data;
+	struct sun20i_pwm_chip *sun20i_chip;
+	u32 npwm;
+	int ret;
+
+	struct device_node *node = pdev->dev.of_node;
+
+	data = of_device_get_match_data(&pdev->dev);
+	if (!data)
+		return -ENODEV;
+
+	ret = of_property_read_u32(node, "allwinner,pwm-channels", &npwm);
+	if (ret)
+		return dev_err_probe(&pdev->dev, -EINVAL, "No PWM channels are configured\n");
+
+	if (npwm > SUN20I_PWM_CHANNELS_MAX)
+		return dev_err_probe(&pdev->dev, -EINVAL, "Too many PWM channels are configured\n");
+
+	chip = devm_pwmchip_alloc(&pdev->dev, npwm, sizeof(*sun20i_chip));
+	if (IS_ERR(chip))
+		return PTR_ERR(chip);
+	sun20i_chip = to_sun20i_pwm_chip(chip);
+
+	sun20i_chip->data = data;
+
+	for (int i = 0; i < (npwm + 1) / 2; i++) {
+		sun20i_chip->clk_src[i] = SUN20I_PWM_CLOCK_SRC_DEFAULT;
+		sun20i_chip->div_m_shift[i] = SUN20I_PWM_DIV_M_SHIFT_DEFAULT;
+
+		const char *source;
+		ret = of_property_read_string_index(node, "allwinner,pwm-paired-channel-clock-sources", i, &source);
+		if (!ret) {
+			if (!strcasecmp(source, "hosc"))
+				sun20i_chip->clk_src[i] = SUN20I_PWM_CLOCK_SRC_HOSC;
+			else if (!strcasecmp(source, "apb"))
+				sun20i_chip->clk_src[i] = SUN20I_PWM_CLOCK_SRC_APB;
+			else
+				return dev_err_probe(&pdev->dev, -EINVAL, "Unknown clock source: %s\n", source);
+		}
+
+		u32 value;
+		ret = of_property_read_u32_index(node, "allwinner,pwm-paired-channel-clock-prescales", i, &value);
+		if (!ret) {
+			if (value <= SUN20I_PWM_DIV_M_SHIFT_MAX)
+				sun20i_chip->div_m_shift[i] = value;
+			else
+				return dev_err_probe(&pdev->dev, -EINVAL, "Invalid prescale value: %u\n", value);
+		}
+	}
+
+	sun20i_chip->base = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(sun20i_chip->base))
+		return PTR_ERR(sun20i_chip->base);
+
+	sun20i_chip->clk_bus = devm_clk_get_enabled(&pdev->dev, "bus");
+	if (IS_ERR(sun20i_chip->clk_bus))
+		return dev_err_probe(&pdev->dev, PTR_ERR(sun20i_chip->clk_bus), "Failed to get `bus` clock\n");
+
+	sun20i_chip->clk_hosc = devm_clk_get_enabled(&pdev->dev, "hosc");
+	if (IS_ERR(sun20i_chip->clk_hosc))
+		return dev_err_probe(&pdev->dev, PTR_ERR(sun20i_chip->clk_hosc), "Failed to get `hosc` clock\n");
+
+	sun20i_chip->clk_apb = devm_clk_get_enabled(&pdev->dev, "apb");
+	if (IS_ERR(sun20i_chip->clk_apb))
+		return dev_err_probe(&pdev->dev, PTR_ERR(sun20i_chip->clk_apb), "Failed to get `apb` clock\n");
+
+	sun20i_chip->rst = devm_reset_control_get_exclusive(&pdev->dev, NULL);
+	if (IS_ERR(sun20i_chip->rst))
+		return dev_err_probe(&pdev->dev, PTR_ERR(sun20i_chip->rst), "Failed to get bus reset\n");
+
+	ret = reset_control_deassert(sun20i_chip->rst);
+	if (ret)
+		return dev_err_probe(&pdev->dev, ret, "Failed to deassert reset control\n");
+
+	chip->ops = &sun20i_pwm_ops;
+
+	spin_lock_init(&sun20i_chip->ctrl_lock);
+
+	ret = pwmchip_add(chip);
+	if (ret < 0) {
+		reset_control_assert(sun20i_chip->rst);
+		return dev_err_probe(&pdev->dev, ret, "Failed to add PWM chip\n");
+	}
+
+	platform_set_drvdata(pdev, chip);
+
+	return 0;
+}
+
+static void sun20i_pwm_remove(struct platform_device *pdev)
+{
+	struct pwm_chip *chip = platform_get_drvdata(pdev);
+	struct sun20i_pwm_chip *sun20i_chip = to_sun20i_pwm_chip(chip);
+
+	pwmchip_remove(chip);
+
+	reset_control_assert(sun20i_chip->rst);
+}
+
+static struct platform_driver sun20i_pwm_driver = {
+	.driver = {
+		.name = "sun20i-pwm",
+		.of_match_table = sun20i_pwm_dt_ids,
+	},
+	.probe = sun20i_pwm_probe,
+	.remove = sun20i_pwm_remove,
+};
+module_platform_driver(sun20i_pwm_driver);
+
+MODULE_ALIAS("platform:sun20i-pwm");
+MODULE_AUTHOR("Hironori KIKUCHI <kikuchan98@gmail.com>");
+MODULE_DESCRIPTION("Allwinner sun20i PWM driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/usb/musb/musb_gadget.c b/drivers/usb/musb/musb_gadget.c
index caf4d4cd4..7986d87da 100644
--- a/drivers/usb/musb/musb_gadget.c
+++ b/drivers/usb/musb/musb_gadget.c
@@ -1162,19 +1162,12 @@ void musb_free_request(struct usb_ep *ep, struct usb_request *req)
  */
 void musb_ep_restart(struct musb *musb, struct musb_request *req)
 {
-	u16 csr;
-	void __iomem *epio = req->ep->hw_ep->regs;
-
 	trace_musb_req_start(req);
 	musb_ep_select(musb->mregs, req->epnum);
-	if (req->tx) {
+	if (req->tx)
 		txstate(musb, req);
-	} else {
-		csr = musb_readw(epio, MUSB_RXCSR);
-		csr |= MUSB_RXCSR_FLUSHFIFO | MUSB_RXCSR_P_WZC_BITS;
-		musb_writew(epio, MUSB_RXCSR, csr);
-		musb_writew(epio, MUSB_RXCSR, csr);
-	}
+	else
+		rxstate(musb, req);
 }
 
 static int musb_ep_restart_resume_work(struct musb *musb, void *data)
diff --git a/include/dt-bindings/clock/sun8i-tcon-top.h b/include/dt-bindings/clock/sun8i-tcon-top.h
index 25164d767..2a12d047d 100644
--- a/include/dt-bindings/clock/sun8i-tcon-top.h
+++ b/include/dt-bindings/clock/sun8i-tcon-top.h
@@ -7,5 +7,7 @@
 #define CLK_TCON_TOP_TV0	0
 #define CLK_TCON_TOP_TV1	1
 #define CLK_TCON_TOP_DSI	2
+#define CLK_TCON_TOP_LCD0	3
+#define CLK_TCON_TOP_LCD1	4
 
 #endif /* _DT_BINDINGS_CLOCK_SUN8I_TCON_TOP_H_ */
diff --git a/include/linux/input-polldev.h b/include/linux/input-polldev.h
new file mode 100644
index 000000000..14821fd23
--- /dev/null
+++ b/include/linux/input-polldev.h
@@ -0,0 +1,58 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+#ifndef _INPUT_POLLDEV_H
+#define _INPUT_POLLDEV_H
+
+/*
+ * Copyright (c) 2007 Dmitry Torokhov
+ */
+
+#include <linux/input.h>
+#include <linux/workqueue.h>
+
+/**
+ * struct input_polled_dev - simple polled input device
+ * @private: private driver data.
+ * @open: driver-supplied method that prepares device for polling
+ *	(enabled the device and maybe flushes device state).
+ * @close: driver-supplied method that is called when device is no
+ *	longer being polled. Used to put device into low power mode.
+ * @poll: driver-supplied method that polls the device and posts
+ *	input events (mandatory).
+ * @poll_interval: specifies how often the poll() method should be called.
+ *	Defaults to 500 msec unless overridden when registering the device.
+ * @poll_interval_max: specifies upper bound for the poll interval.
+ *	Defaults to the initial value of @poll_interval.
+ * @poll_interval_min: specifies lower bound for the poll interval.
+ *	Defaults to 0.
+ * @input: input device structure associated with the polled device.
+ *	Must be properly initialized by the driver (id, name, phys, bits).
+ *
+ * Polled input device provides a skeleton for supporting simple input
+ * devices that do not raise interrupts but have to be periodically
+ * scanned or polled to detect changes in their state.
+ */
+struct input_polled_dev {
+	void *private;
+
+	void (*open)(struct input_polled_dev *dev);
+	void (*close)(struct input_polled_dev *dev);
+	void (*poll)(struct input_polled_dev *dev);
+	unsigned int poll_interval; /* msec */
+	unsigned int poll_interval_max; /* msec */
+	unsigned int poll_interval_min; /* msec */
+
+	struct input_dev *input;
+
+/* private: */
+	struct delayed_work work;
+
+	bool devres_managed;
+};
+
+struct input_polled_dev *input_allocate_polled_device(void);
+struct input_polled_dev *devm_input_allocate_polled_device(struct device *dev);
+void input_free_polled_device(struct input_polled_dev *dev);
+int input_register_polled_device(struct input_polled_dev *dev);
+void input_unregister_polled_device(struct input_polled_dev *dev);
+
+#endif
diff --git a/include/linux/of_gpio.h b/include/linux/of_gpio.h
index d0f66a5e1..5c4c7e1a3 100644
--- a/include/linux/of_gpio.h
+++ b/include/linux/of_gpio.h
@@ -17,8 +17,26 @@
 
 struct device_node;
 
+/*
+ * This is Linux-specific flags. By default controllers' and Linux' mapping
+ * match, but GPIO controllers are free to translate their own flags to
+ * Linux-specific in their .xlate callback. Though, 1:1 mapping is recommended.
+ */
+enum of_gpio_flags {
+        OF_GPIO_ACTIVE_LOW = 0x1,
+        OF_GPIO_SINGLE_ENDED = 0x2,
+        OF_GPIO_OPEN_DRAIN = 0x4,
+        OF_GPIO_TRANSITORY = 0x8,
+        OF_GPIO_PULL_UP = 0x10,
+        OF_GPIO_PULL_DOWN = 0x20,
+        OF_GPIO_PULL_DISABLE = 0x40,
+};
+
 #ifdef CONFIG_OF_GPIO
 
+extern int of_get_named_gpio_flags(const struct device_node *np,
+                const char *list_name, int index, enum of_gpio_flags *flags);
+
 extern int of_get_named_gpio(const struct device_node *np,
 			     const char *list_name, int index);
 
@@ -26,13 +44,30 @@ extern int of_get_named_gpio(const struct device_node *np,
 
 #include <linux/errno.h>
 
-/* Drivers may not strictly depend on the GPIO support, so let them link. */
 static inline int of_get_named_gpio(const struct device_node *np,
                                    const char *propname, int index)
 {
+        return -ENOSYS;
+}
+
+/* Drivers may not strictly depend on the GPIO support, so let them link. */
+static inline int of_get_named_gpio_flags(const struct device_node *np,
+		const char *list_name, int index, enum of_gpio_flags *flags)
+{
+	if (flags)
+		*flags = 0;
+
 	return -ENOSYS;
 }
 
 #endif /* CONFIG_OF_GPIO */
 
+static inline int of_get_gpio_flags(const struct device_node *np, int index,
+		      enum of_gpio_flags *flags)
+{
+	return of_get_named_gpio_flags(np, "gpios", index, flags);
+}
+
+//#endif /* CONFIG_OF_GPIO */
+
 #endif /* __LINUX_OF_GPIO_H */
diff --git a/include/linux/of_gpio_legacy.h b/include/linux/of_gpio_legacy.h
new file mode 100644
index 000000000..ce58afecb
--- /dev/null
+++ b/include/linux/of_gpio_legacy.h
@@ -0,0 +1,304 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * OF helpers for the GPIO API
+ *
+ * Copyright (c) 2007-2008  MontaVista Software, Inc.
+ *
+ * Author: Anton Vorontsov <avorontsov@ru.mvista.com>
+ */
+
+#ifndef __LINUX_OF_GPIO_H
+#define __LINUX_OF_GPIO_H
+
+#include <linux/compiler.h>
+#include <linux/gpio/driver.h>
+#include <linux/gpio.h>		/* FIXME: Shouldn't be here */
+#include <linux/of.h>
+
+struct device_node;
+
+/*
+ * This is Linux-specific flags. By default controllers' and Linux' mapping
+ * match, but GPIO controllers are free to translate their own flags to
+ * Linux-specific in their .xlate callback. Though, 1:1 mapping is recommended.
+ */
+enum of_gpio_flags {
+	OF_GPIO_ACTIVE_LOW = 0x1,
+	OF_GPIO_SINGLE_ENDED = 0x2,
+	OF_GPIO_OPEN_DRAIN = 0x4,
+	OF_GPIO_TRANSITORY = 0x8,
+	OF_GPIO_PULL_UP = 0x10,
+	OF_GPIO_PULL_DOWN = 0x20,
+};
+
+#ifdef CONFIG_OF_GPIO
+
+#include <linux/kernel.h>
+
+/*
+ * OF GPIO chip for memory mapped banks
+ */
+struct of_mm_gpio_chip {
+	struct gpio_chip gc;
+	void (*save_regs)(struct of_mm_gpio_chip *mm_gc);
+	void __iomem *regs;
+};
+
+static inline struct of_mm_gpio_chip *to_of_mm_gpio_chip(struct gpio_chip *gc)
+{
+	return container_of(gc, struct of_mm_gpio_chip, gc);
+}
+
+extern int of_get_named_gpio_flags(const struct device_node *np,
+		const char *list_name, int index, enum of_gpio_flags *flags);
+
+extern int of_mm_gpiochip_add_data(struct device_node *np,
+				   struct of_mm_gpio_chip *mm_gc,
+				   void *data);
+static inline int of_mm_gpiochip_add(struct device_node *np,
+				     struct of_mm_gpio_chip *mm_gc)
+{
+	return of_mm_gpiochip_add_data(np, mm_gc, NULL);
+}
+extern void of_mm_gpiochip_remove(struct of_mm_gpio_chip *mm_gc);
+
+#else /* CONFIG_OF_GPIO */
+
+#include <linux/errno.h>
+
+/* Drivers may not strictly depend on the GPIO support, so let them link. */
+static inline int of_get_named_gpio_flags(const struct device_node *np,
+		const char *list_name, int index, enum of_gpio_flags *flags)
+{
+	if (flags)
+		*flags = 0;
+
+	return -ENOSYS;
+}
+
+#endif /* CONFIG_OF_GPIO */
+
+/**
+ * of_gpio_named_count() - Count GPIOs for a device
+ * @np:		device node to count GPIOs for
+ * @propname:	property name containing gpio specifier(s)
+ *
+ * The function returns the count of GPIOs specified for a node.
+ * Note that the empty GPIO specifiers count too. Returns either
+ *   Number of gpios defined in property,
+ *   -EINVAL for an incorrectly formed gpios property, or
+ *   -ENOENT for a missing gpios property
+ *
+ * Example:
+ * gpios = <0
+ *          &gpio1 1 2
+ *          0
+ *          &gpio2 3 4>;
+ *
+ * The above example defines four GPIOs, two of which are not specified.
+ * This function will return '4'
+ */
+static inline int of_gpio_named_count(const struct device_node *np,
+				      const char *propname)
+{
+	return of_count_phandle_with_args(np, propname, "#gpio-cells");
+}
+
+/**
+ * of_gpio_count() - Count GPIOs for a device
+ * @np:		device node to count GPIOs for
+ *
+ * Same as of_gpio_named_count, but hard coded to use the 'gpios' property
+ */
+static inline int of_gpio_count(const struct device_node *np)
+{
+	return of_gpio_named_count(np, "gpios");
+}
+
+static inline int of_get_gpio_flags(const struct device_node *np, int index,
+		      enum of_gpio_flags *flags)
+{
+	return of_get_named_gpio_flags(np, "gpios", index, flags);
+}
+
+/**
+ * of_get_named_gpio() - Get a GPIO number to use with GPIO API
+ * @np:		device node to get GPIO from
+ * @propname:	Name of property containing gpio specifier(s)
+ * @index:	index of the GPIO
+ *
+ * Returns GPIO number to use with Linux generic GPIO API, or one of the errno
+ * value on the error condition.
+ */
+static inline int of_get_named_gpio(const struct device_node *np,
+                                   const char *propname, int index)
+{
+	return of_get_named_gpio_flags(np, propname, index, NULL);
+}
+
+/**
+ * of_get_gpio() - Get a GPIO number to use with GPIO API
+ * @np:		device node to get GPIO from
+ * @index:	index of the GPIO
+ *
+ * Returns GPIO number to use with Linux generic GPIO API, or one of the errno
+ * value on the error condition.
+ */
+static inline int of_get_gpio(const struct device_node *np, int index)
+{
+	return of_get_gpio_flags(np, index, NULL);
+}
+
+#endif /* __LINUX_OF_GPIO_H */
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * OF helpers for the GPIO API
+ *
+ * Copyright (c) 2007-2008  MontaVista Software, Inc.
+ *
+ * Author: Anton Vorontsov <avorontsov@ru.mvista.com>
+ */
+
+#ifndef __LINUX_OF_GPIO_H
+#define __LINUX_OF_GPIO_H
+
+#include <linux/compiler.h>
+#include <linux/gpio/driver.h>
+#include <linux/gpio.h>		/* FIXME: Shouldn't be here */
+#include <linux/of.h>
+
+struct device_node;
+
+/*
+ * This is Linux-specific flags. By default controllers' and Linux' mapping
+ * match, but GPIO controllers are free to translate their own flags to
+ * Linux-specific in their .xlate callback. Though, 1:1 mapping is recommended.
+ */
+enum of_gpio_flags {
+	OF_GPIO_ACTIVE_LOW = 0x1,
+	OF_GPIO_SINGLE_ENDED = 0x2,
+	OF_GPIO_OPEN_DRAIN = 0x4,
+	OF_GPIO_TRANSITORY = 0x8,
+	OF_GPIO_PULL_UP = 0x10,
+	OF_GPIO_PULL_DOWN = 0x20,
+};
+
+#ifdef CONFIG_OF_GPIO
+
+#include <linux/kernel.h>
+
+/*
+ * OF GPIO chip for memory mapped banks
+ */
+struct of_mm_gpio_chip {
+	struct gpio_chip gc;
+	void (*save_regs)(struct of_mm_gpio_chip *mm_gc);
+	void __iomem *regs;
+};
+
+static inline struct of_mm_gpio_chip *to_of_mm_gpio_chip(struct gpio_chip *gc)
+{
+	return container_of(gc, struct of_mm_gpio_chip, gc);
+}
+
+extern int of_get_named_gpio_flags(const struct device_node *np,
+		const char *list_name, int index, enum of_gpio_flags *flags);
+
+extern int of_mm_gpiochip_add_data(struct device_node *np,
+				   struct of_mm_gpio_chip *mm_gc,
+				   void *data);
+static inline int of_mm_gpiochip_add(struct device_node *np,
+				     struct of_mm_gpio_chip *mm_gc)
+{
+	return of_mm_gpiochip_add_data(np, mm_gc, NULL);
+}
+extern void of_mm_gpiochip_remove(struct of_mm_gpio_chip *mm_gc);
+
+#else /* CONFIG_OF_GPIO */
+
+#include <linux/errno.h>
+
+/* Drivers may not strictly depend on the GPIO support, so let them link. */
+static inline int of_get_named_gpio_flags(const struct device_node *np,
+		const char *list_name, int index, enum of_gpio_flags *flags)
+{
+	if (flags)
+		*flags = 0;
+
+	return -ENOSYS;
+}
+
+#endif /* CONFIG_OF_GPIO */
+
+/**
+ * of_gpio_named_count() - Count GPIOs for a device
+ * @np:		device node to count GPIOs for
+ * @propname:	property name containing gpio specifier(s)
+ *
+ * The function returns the count of GPIOs specified for a node.
+ * Note that the empty GPIO specifiers count too. Returns either
+ *   Number of gpios defined in property,
+ *   -EINVAL for an incorrectly formed gpios property, or
+ *   -ENOENT for a missing gpios property
+ *
+ * Example:
+ * gpios = <0
+ *          &gpio1 1 2
+ *          0
+ *          &gpio2 3 4>;
+ *
+ * The above example defines four GPIOs, two of which are not specified.
+ * This function will return '4'
+ */
+static inline int of_gpio_named_count(const struct device_node *np,
+				      const char *propname)
+{
+	return of_count_phandle_with_args(np, propname, "#gpio-cells");
+}
+
+/**
+ * of_gpio_count() - Count GPIOs for a device
+ * @np:		device node to count GPIOs for
+ *
+ * Same as of_gpio_named_count, but hard coded to use the 'gpios' property
+ */
+static inline int of_gpio_count(const struct device_node *np)
+{
+	return of_gpio_named_count(np, "gpios");
+}
+
+static inline int of_get_gpio_flags(const struct device_node *np, int index,
+		      enum of_gpio_flags *flags)
+{
+	return of_get_named_gpio_flags(np, "gpios", index, flags);
+}
+
+/**
+ * of_get_named_gpio() - Get a GPIO number to use with GPIO API
+ * @np:		device node to get GPIO from
+ * @propname:	Name of property containing gpio specifier(s)
+ * @index:	index of the GPIO
+ *
+ * Returns GPIO number to use with Linux generic GPIO API, or one of the errno
+ * value on the error condition.
+ */
+static inline int of_get_named_gpio(const struct device_node *np,
+                                   const char *propname, int index)
+{
+	return of_get_named_gpio_flags(np, propname, index, NULL);
+}
+
+/**
+ * of_get_gpio() - Get a GPIO number to use with GPIO API
+ * @np:		device node to get GPIO from
+ * @index:	index of the GPIO
+ *
+ * Returns GPIO number to use with Linux generic GPIO API, or one of the errno
+ * value on the error condition.
+ */
+static inline int of_get_gpio(const struct device_node *np, int index)
+{
+	return of_get_gpio_flags(np, index, NULL);
+}
+
+#endif /* __LINUX_OF_GPIO_H */
diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index 63a17d2b4..c45fd19ca 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -139,6 +139,12 @@ static inline bool pwm_is_enabled(const struct pwm_device *pwm)
 	return state.enabled;
 }
 
+static inline void pwm_set_period(struct pwm_device *pwm, u64 period)
+{
+	if (pwm)
+		pwm->state.period = period;
+}
+
 static inline u64 pwm_get_period(const struct pwm_device *pwm)
 {
 	struct pwm_state state;
diff --git a/sound/soc/Kconfig b/sound/soc/Kconfig
index 1b983c700..098372a41 100644
--- a/sound/soc/Kconfig
+++ b/sound/soc/Kconfig
@@ -134,6 +134,7 @@ source "sound/soc/starfive/Kconfig"
 source "sound/soc/sti/Kconfig"
 source "sound/soc/stm/Kconfig"
 source "sound/soc/sunxi/Kconfig"
+source "sound/soc/sunxi_v2/Kconfig"
 source "sound/soc/tegra/Kconfig"
 source "sound/soc/ti/Kconfig"
 source "sound/soc/uniphier/Kconfig"
diff --git a/sound/soc/Makefile b/sound/soc/Makefile
index 462322c38..31faf39bb 100644
--- a/sound/soc/Makefile
+++ b/sound/soc/Makefile
@@ -76,6 +76,7 @@ obj-$(CONFIG_SND_SOC)	+= starfive/
 obj-$(CONFIG_SND_SOC)	+= sti/
 obj-$(CONFIG_SND_SOC)	+= stm/
 obj-$(CONFIG_SND_SOC)	+= sunxi/
+obj-$(CONFIG_SND_SOC)	+= sunxi_v2/
 obj-$(CONFIG_SND_SOC)	+= tegra/
 obj-$(CONFIG_SND_SOC)	+= ti/
 obj-$(CONFIG_SND_SOC)	+= uniphier/
diff --git a/sound/soc/sunxi_v2/Kconfig b/sound/soc/sunxi_v2/Kconfig
new file mode 100644
index 000000000..37fc579ba
--- /dev/null
+++ b/sound/soc/sunxi_v2/Kconfig
@@ -0,0 +1,48 @@
+# common
+config SND_SOC_SUNXI_MACH
+	tristate
+
+# ahub dam
+config SND_SOC_SUNXI_AHUB_DAM
+	tristate
+
+config SND_SOC_SUNXI_INTERNALCODEC
+	tristate
+
+config SND_SOC_SUNXI_SUN50IW9_CODEC
+	tristate
+
+# menu select
+menu "Allwinner SoC Audio support V2"
+	depends on ARCH_SUNXI
+
+# aaudio
+config SND_SOC_SUNXI_AAUDIO
+	tristate "Allwinner AAUDIO support"
+	select REGMAP_MMIO
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	select SND_SOC_SUNXI_MACH
+	select SND_SOC_SUNXI_INTERNALCODEC
+	select SND_SOC_SUNXI_SUN50IW9_CODEC
+	depends on ARCH_SUNXI
+	help
+	    Select Y or M to support analog-audio Module in the Allwinner SoCs.
+
+# ahub
+config SND_SOC_SUNXI_AHUB
+	tristate "Allwinner AHUB Support"
+	select REGMAP_MMIO
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	select SND_SOC_SUNXI_MACH
+	select SND_SOC_SUNXI_AHUB_DAM
+	depends on ARCH_SUNXI
+	help
+	    Select Y or M to support audio-hub Module in Allwinner SoCs.
+
+config SND_SOC_SUNXI_DEBUG
+	tristate "Components Debug"
+	depends on SND_SOC_SUNXI_COMPONENTS
+	help
+	    Select Y or M to support debug components.
+
+endmenu
diff --git a/sound/soc/sunxi_v2/Makefile b/sound/soc/sunxi_v2/Makefile
new file mode 100644
index 000000000..c7c2ef8f9
--- /dev/null
+++ b/sound/soc/sunxi_v2/Makefile
@@ -0,0 +1,11 @@
+# platform -> ahub
+snd_soc_sunxi_ahub_dam-objs			+= snd_sunxi_ahub_dam.o
+obj-$(CONFIG_SND_SOC_SUNXI_AHUB_DAM)		+= snd_soc_sunxi_ahub_dam.o
+
+snd_soc_sunxi_ahub-objs				+= snd_sunxi_ahub.o
+obj-$(CONFIG_SND_SOC_SUNXI_AHUB)		+= snd_soc_sunxi_ahub.o
+
+# common -> machine (note: Finally compile, save system startup time)
+snd_soc_sunxi_machine-objs			+= snd_sunxi_mach.o
+snd_soc_sunxi_machine-objs			+= snd_sunxi_mach_utils.o
+obj-$(CONFIG_SND_SOC_SUNXI_MACH)		+= snd_soc_sunxi_machine.o
diff --git a/sound/soc/sunxi_v2/drv_hdmi.h b/sound/soc/sunxi_v2/drv_hdmi.h
new file mode 100644
index 000000000..2e05489b0
--- /dev/null
+++ b/sound/soc/sunxi_v2/drv_hdmi.h
@@ -0,0 +1,63 @@
+/*
+ * Allwinner SoCs hdmi driver.
+ *
+ * Copyright (C) 2016 Allwinner.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __DRV_HDMI_H__
+#define __DRV_HDMI_H__
+
+typedef struct {
+	__u8    hw_intf;        /* 0:iis  1:spdif 2:pcm */
+	__u16	fs_between;     /* fs */
+	__u32   sample_rate;    /*sample rate*/
+	__u8    clk_edge;       /* 0:*/
+	__u8    ch0_en;         /* 1 */
+	__u8    ch1_en;         /* 0 */
+	__u8	ch2_en;         /* 0 */
+	__u8	ch3_en;         /* 0 */
+	__u8	word_length;    /* 32 */
+	__u8    shift_ctl;      /* 0 */
+	__u8    dir_ctl;        /* 0 */
+	__u8    ws_pol;
+	__u8    just_pol;
+	__u8    channel_num;
+	__u8	data_raw;
+	__u8    sample_bit;
+	__u8    ca;     /* channel allocation */
+} hdmi_audio_t;
+
+typedef struct {
+	__s32 (*hdmi_audio_enable)(__u8 mode, __u8 channel);
+	__s32 (*hdmi_set_audio_para)(hdmi_audio_t *audio_para);
+	__s32 (*hdmi_is_playback)(void);
+} __audio_hdmi_func;
+
+enum hdmi_hpd_status {
+	STATUE_CLOSE = 0,
+	STATUE_OPEN = 1,
+};
+
+void audio_set_hdmi_func(__audio_hdmi_func *hdmi_func);
+#if defined(CONFIG_SND_SUNXI_SOC_AUDIOHUB_INTERFACE)
+void audio_set_muti_hdmi_func(__audio_hdmi_func *hdmi_func);
+#endif
+
+/******************** SND_HDMI for sunxi_v2 begain ***************************/
+#if IS_ENABLED(CONFIG_HDMI2_DISP2_SUNXI)
+extern int snd_hdmi_get_func(__audio_hdmi_func *hdmi_func);
+#else
+static inline int snd_hdmi_get_func(__audio_hdmi_func *hdmi_func)
+{
+		pr_err("HDMI Audio API is disable\n");
+
+			return -1;
+}
+#endif
+/******************** SND_HDMI for sunxi_v2 end ******************************/
+
+#endif
diff --git a/sound/soc/sunxi_v2/snd_sunxi_ahub.c b/sound/soc/sunxi_v2/snd_sunxi_ahub.c
new file mode 100644
index 000000000..659b997d2
--- /dev/null
+++ b/sound/soc/sunxi_v2/snd_sunxi_ahub.c
@@ -0,0 +1,1475 @@
+/*
+ * sound\soc\sunxi\snd_sunxi_ahub.c
+ * (C) Copyright 2021-2025
+ * AllWinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Dby <dby@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/regulator/consumer.h>
+#include <linux/of.h>
+#include <linux/clk.h>
+#include <linux/reset.h>
+#include <linux/device.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/ioport.h>
+#include <linux/regmap.h>
+#include <linux/of_address.h>
+#include <linux/of_gpio.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+#include <sound/dmaengine_pcm.h>
+
+#include "snd_sunxi_log.h"
+#include "snd_sunxi_ahub.h"
+
+#define HLOG		"AHUB"
+#define DRV_NAME	"sunxi-snd-plat-ahub"
+
+static int sunxi_ahub_dai_startup(struct snd_pcm_substream *substream,
+				  struct snd_soc_dai *dai)
+{
+	struct sunxi_ahub_info *ahub_info = snd_soc_dai_get_drvdata(dai);
+	struct regmap *regmap = NULL;
+	unsigned int apb_num, tdm_num;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	regmap = ahub_info->mem_info.regmap;
+	apb_num = ahub_info->dts_info.apb_num;
+	tdm_num = ahub_info->dts_info.tdm_num;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		snd_soc_dai_set_dma_data(dai, substream,
+					 &ahub_info->playback_dma_param);
+	} else {
+		snd_soc_dai_set_dma_data(dai, substream,
+					 &ahub_info->capture_dma_param);
+	}
+
+	/* APBIF & I2S of RST and GAT */
+	if (tdm_num > 3 || apb_num > 2) {
+		SND_LOG_ERR(HLOG, "unspport tdm num or apbif num\n");
+		return -EINVAL;
+	}
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		regmap_update_bits(regmap, SUNXI_AHUB_RST,
+				   0x1 << (APBIF_TXDIF0_RST - apb_num),
+				   0x1 << (APBIF_TXDIF0_RST - apb_num));
+		regmap_update_bits(regmap, SUNXI_AHUB_GAT,
+				   0x1 << (APBIF_TXDIF0_GAT - apb_num),
+				   0x1 << (APBIF_TXDIF0_GAT - apb_num));
+	} else {
+		regmap_update_bits(regmap, SUNXI_AHUB_RST,
+				   0x1 << (APBIF_RXDIF0_RST - apb_num),
+				   0x1 << (APBIF_RXDIF0_RST - apb_num));
+		regmap_update_bits(regmap, SUNXI_AHUB_GAT,
+				   0x1 << (APBIF_RXDIF0_GAT - apb_num),
+				   0x1 << (APBIF_RXDIF0_GAT - apb_num));
+	}
+
+	return 0;
+}
+
+static int sunxi_ahub_dai_set_pll(struct snd_soc_dai *dai,
+				  int pll_id, int source,
+				  unsigned int freq_in, unsigned int freq_out)
+{
+	struct sunxi_ahub_info *ahub_info = snd_soc_dai_get_drvdata(dai);
+	struct sunxi_ahub_clk_info *clk_info = NULL;
+
+	SND_LOG_DEBUG(HLOG, "stream -> %s, freq_in ->%u, freq_out ->%u\n",
+		      pll_id ? "IN" : "OUT", freq_in, freq_out);
+
+	if (IS_ERR_OR_NULL(ahub_info)) {
+		SND_LOG_ERR(HLOG, "ahub_info is null.\n");
+		return -ENOMEM;
+	}
+	clk_info = &ahub_info->clk_info;
+
+	if (freq_in > 24576000) {
+		//if (clk_set_parent(clk_info->clk_module, clk_info->clk_pllx4)) {
+		//	SND_LOG_ERR(HLOG, "set parent of clk_module to pllx4 failed\n");
+		//	return -EINVAL;
+		//}
+
+		if (clk_set_rate(clk_info->clk_pll, freq_in / 2)) {
+			SND_LOG_ERR(HLOG, "freq : %u pllx4 clk unsupport\n", freq_in);
+			return -EINVAL;
+		}
+	} else {
+		//if (clk_set_parent(clk_info->clk_module, clk_info->clk_pll)) {
+		//	SND_LOG_ERR(HLOG, "set parent of clk_module to pll failed\n");
+		//	return -EINVAL;
+		//}
+		if (clk_set_rate(clk_info->clk_pll, freq_in / 2)) {
+			SND_LOG_ERR(HLOG, "freq : %u pll clk unsupport\n", freq_in);
+			return -EINVAL;
+		}
+	}
+	if (clk_set_rate(clk_info->clk_module, freq_out / 4)) {
+		SND_LOG_ERR(HLOG, "freq : %u module clk unsupport\n", freq_out);
+		return -EINVAL;
+	}
+
+	ahub_info->pllclk_freq = freq_in;
+	ahub_info->mclk_freq = freq_out;
+
+	return 0;
+}
+
+static int sunxi_ahub_dai_set_sysclk(struct snd_soc_dai *dai, int clk_id,
+				     unsigned int freq, int dir)
+{
+	struct sunxi_ahub_info *ahub_info = snd_soc_dai_get_drvdata(dai);
+	struct regmap *regmap = NULL;
+	unsigned int tdm_num;
+	unsigned int mclk_ratio, mclk_ratio_map;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	if (IS_ERR_OR_NULL(ahub_info)) {
+		SND_LOG_ERR(HLOG, "ahub_info is null.\n");
+		return -ENOMEM;
+	}
+	regmap = ahub_info->mem_info.regmap;
+	tdm_num = ahub_info->dts_info.tdm_num;
+
+	if (freq == 0) {
+		regmap_update_bits(regmap, SUNXI_AHUB_I2S_CLKD(tdm_num),
+				   0x1 << I2S_CLKD_MCLK, 0x0 << I2S_CLKD_MCLK);
+		SND_LOG_DEBUG(HLOG, "mclk freq: 0\n");
+		return 0;
+	}
+	if (ahub_info->pllclk_freq == 0) {
+		SND_LOG_ERR(HLOG, "pllclk freq is invalid\n");
+		return -ENOMEM;
+	}
+	mclk_ratio = ahub_info->pllclk_freq / freq;
+
+	switch (mclk_ratio) {
+	case 1:
+		mclk_ratio_map = 1;
+		break;
+	case 2:
+		mclk_ratio_map = 2;
+		break;
+	case 4:
+		mclk_ratio_map = 3;
+		break;
+	case 6:
+		mclk_ratio_map = 4;
+		break;
+	case 8:
+		mclk_ratio_map = 5;
+		break;
+	case 12:
+		mclk_ratio_map = 6;
+		break;
+	case 16:
+		mclk_ratio_map = 7;
+		break;
+	case 24:
+		mclk_ratio_map = 8;
+		break;
+	case 32:
+		mclk_ratio_map = 9;
+		break;
+	case 48:
+		mclk_ratio_map = 10;
+		break;
+	case 64:
+		mclk_ratio_map = 11;
+		break;
+	case 96:
+		mclk_ratio_map = 12;
+		break;
+	case 128:
+		mclk_ratio_map = 13;
+		break;
+	case 176:
+		mclk_ratio_map = 14;
+		break;
+	case 192:
+		mclk_ratio_map = 15;
+		break;
+	default:
+		regmap_update_bits(regmap, SUNXI_AHUB_I2S_CLKD(tdm_num),
+				   0x1 << I2S_CLKD_MCLK, 0x0 << I2S_CLKD_MCLK);
+		SND_LOG_ERR(HLOG, "mclk freq div unsupport\n");
+		return -EINVAL;
+	}
+
+	regmap_update_bits(regmap, SUNXI_AHUB_I2S_CLKD(tdm_num),
+			   0xf << I2S_CLKD_MCLKDIV,
+			   mclk_ratio_map << I2S_CLKD_MCLKDIV);
+	regmap_update_bits(regmap, SUNXI_AHUB_I2S_CLKD(tdm_num),
+			   0x1 << I2S_CLKD_MCLK, 0x1 << I2S_CLKD_MCLK);
+
+	return 0;
+}
+
+static int sunxi_ahub_dai_set_bclk_ratio(struct snd_soc_dai *dai, unsigned int ratio)
+{
+	struct sunxi_ahub_info *ahub_info = snd_soc_dai_get_drvdata(dai);
+	struct regmap *regmap = NULL;
+	unsigned int tdm_num;
+	unsigned int bclk_ratio;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	if (IS_ERR_OR_NULL(ahub_info)) {
+		SND_LOG_ERR(HLOG, "ahub_info is null.\n");
+		return -ENOMEM;
+	}
+	regmap = ahub_info->mem_info.regmap;
+	tdm_num = ahub_info->dts_info.tdm_num;
+
+	/* ratio -> cpudai pllclk / pcm rate */
+	switch (ratio) {
+	case 1:
+		bclk_ratio = 1;
+		break;
+	case 2:
+		bclk_ratio = 2;
+		break;
+	case 4:
+		bclk_ratio = 3;
+		break;
+	case 6:
+		bclk_ratio = 4;
+		break;
+	case 8:
+		bclk_ratio = 5;
+		break;
+	case 12:
+		bclk_ratio = 6;
+		break;
+	case 16:
+		bclk_ratio = 7;
+		break;
+	case 24:
+		bclk_ratio = 8;
+		break;
+	case 32:
+		bclk_ratio = 9;
+		break;
+	case 48:
+		bclk_ratio = 10;
+		break;
+	case 64:
+		bclk_ratio = 11;
+		break;
+	case 96:
+		bclk_ratio = 12;
+		break;
+	case 128:
+		bclk_ratio = 13;
+		break;
+	case 176:
+		bclk_ratio = 14;
+		break;
+	case 192:
+		bclk_ratio = 15;
+		break;
+	default:
+		SND_LOG_ERR(HLOG, "bclk freq div unsupport\n");
+		return -EINVAL;
+	}
+
+	regmap_update_bits(regmap, SUNXI_AHUB_I2S_CLKD(tdm_num),
+			   0xf << I2S_CLKD_BCLKDIV,
+			   (bclk_ratio - 2) << I2S_CLKD_BCLKDIV);
+
+	return 0;
+}
+
+static int sunxi_ahub_dai_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
+{
+	struct sunxi_ahub_info *ahub_info = snd_soc_dai_get_drvdata(dai);
+	struct regmap *regmap = NULL;
+	unsigned int tdm_num, tx_pin, rx_pin;
+	unsigned int mode, offset;
+	unsigned int lrck_polarity, brck_polarity;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	ahub_info->fmt = fmt;
+
+	if (IS_ERR_OR_NULL(ahub_info)) {
+		SND_LOG_ERR(HLOG, "ahub_info is null.\n");
+		return -ENOMEM;
+	}
+	regmap = ahub_info->mem_info.regmap;
+	tdm_num = ahub_info->dts_info.tdm_num;
+	tx_pin = ahub_info->dts_info.tx_pin;
+	rx_pin = ahub_info->dts_info.rx_pin;
+
+	/* set TDM format */
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case	SND_SOC_DAIFMT_I2S:
+		mode = 1;
+		offset = 1;
+		break;
+	case	SND_SOC_DAIFMT_RIGHT_J:
+		mode = 2;
+		offset = 0;
+		break;
+	case	SND_SOC_DAIFMT_LEFT_J:
+		mode = 1;
+		offset = 0;
+		break;
+	case	SND_SOC_DAIFMT_DSP_A:
+		mode = 0;
+		offset = 1;
+		/* L data MSB after FRM LRC (short frame) */
+		regmap_update_bits(regmap, SUNXI_AHUB_I2S_FMT0(tdm_num),
+				   0x1 << I2S_FMT0_LRCK_WIDTH,
+				   0x0 << I2S_FMT0_LRCK_WIDTH);
+		break;
+	case	SND_SOC_DAIFMT_DSP_B:
+		mode = 0;
+		offset = 0;
+		/* L data MSB during FRM LRC (long frame) */
+		regmap_update_bits(regmap, SUNXI_AHUB_I2S_FMT0(tdm_num),
+				   0x1 << I2S_FMT0_LRCK_WIDTH,
+				   0x1 << I2S_FMT0_LRCK_WIDTH);
+		break;
+	default:
+		SND_LOG_ERR(HLOG, "format setting failed\n");
+		return -EINVAL;
+	}
+	regmap_update_bits(regmap, SUNXI_AHUB_I2S_CTL(tdm_num),
+			   0x3 << I2S_CTL_MODE, mode << I2S_CTL_MODE);
+	/* regmap_update_bits(regmap, SUNXI_AHUB_I2S_OUT_SLOT(tdm_num, tx_pin),
+	 *		   0x3 << I2S_OUT_OFFSET, offset << I2S_OUT_OFFSET);
+	 */
+	regmap_update_bits(regmap, SUNXI_AHUB_I2S_OUT_SLOT(tdm_num, 0),
+			   0x3 << I2S_OUT_OFFSET, offset << I2S_OUT_OFFSET);
+	regmap_update_bits(regmap, SUNXI_AHUB_I2S_OUT_SLOT(tdm_num, 1),
+			   0x3 << I2S_OUT_OFFSET, offset << I2S_OUT_OFFSET);
+	regmap_update_bits(regmap, SUNXI_AHUB_I2S_OUT_SLOT(tdm_num, 2),
+			   0x3 << I2S_OUT_OFFSET, offset << I2S_OUT_OFFSET);
+	regmap_update_bits(regmap, SUNXI_AHUB_I2S_OUT_SLOT(tdm_num, 3),
+			   0x3 << I2S_OUT_OFFSET, offset << I2S_OUT_OFFSET);
+	regmap_update_bits(regmap, SUNXI_AHUB_I2S_IN_SLOT(tdm_num),
+			   0x3 << I2S_IN_OFFSET, offset << I2S_IN_OFFSET);
+
+	/* set lrck & bclk polarity */
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case	SND_SOC_DAIFMT_NB_NF:
+		lrck_polarity = 0;
+		brck_polarity = 0;
+		break;
+	case	SND_SOC_DAIFMT_NB_IF:
+		lrck_polarity = 1;
+		brck_polarity = 0;
+		break;
+	case	SND_SOC_DAIFMT_IB_NF:
+		lrck_polarity = 0;
+		brck_polarity = 1;
+		break;
+	case	SND_SOC_DAIFMT_IB_IF:
+		lrck_polarity = 1;
+		brck_polarity = 1;
+		break;
+	default:
+		SND_LOG_ERR(HLOG, "invert clk setting failed\n");
+		return -EINVAL;
+	}
+	if (((fmt & SND_SOC_DAIFMT_FORMAT_MASK) == SND_SOC_DAIFMT_DSP_A) ||
+	    ((fmt & SND_SOC_DAIFMT_FORMAT_MASK) == SND_SOC_DAIFMT_DSP_B))
+		regmap_update_bits(regmap, SUNXI_AHUB_I2S_FMT0(tdm_num),
+				   0x1 << I2S_FMT0_LRCK_POLARITY,
+				   (lrck_polarity^1) << I2S_FMT0_LRCK_POLARITY);
+	else
+		regmap_update_bits(regmap, SUNXI_AHUB_I2S_FMT0(tdm_num),
+				   0x1 << I2S_FMT0_LRCK_POLARITY,
+				   lrck_polarity << I2S_FMT0_LRCK_POLARITY);
+	regmap_update_bits(regmap, SUNXI_AHUB_I2S_FMT0(tdm_num),
+			   0x1 << I2S_FMT0_BCLK_POLARITY,
+			   brck_polarity << I2S_FMT0_BCLK_POLARITY);
+
+	/* set master/slave */
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case	SND_SOC_DAIFMT_CBP_CFP:
+		/* lrck & bclk dir output */
+		regmap_update_bits(regmap, SUNXI_AHUB_I2S_CTL(tdm_num),
+				   0x1 << I2S_CTL_CLK_OUT, 0x0 << I2S_CTL_CLK_OUT);
+		break;
+	case	SND_SOC_DAIFMT_CBC_CFC:
+		/* lrck & bclk dir input */
+		regmap_update_bits(regmap, SUNXI_AHUB_I2S_CTL(tdm_num),
+				   0x1 << I2S_CTL_CLK_OUT, 0x1 << I2S_CTL_CLK_OUT);
+		break;
+	default:
+		SND_LOG_ERR(HLOG, "unknown master/slave format\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sunxi_ahub_dai_set_tdm_slot(struct snd_soc_dai *dai,
+				       unsigned int tx_mask, unsigned int rx_mask,
+				       int slots, int slot_width)
+{
+	struct sunxi_ahub_info *ahub_info = snd_soc_dai_get_drvdata(dai);
+	struct regmap *regmap = NULL;
+	unsigned int tdm_num, tx_pin, rx_pin;
+	unsigned int slot_width_map, lrck_width_map;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	if (IS_ERR_OR_NULL(ahub_info)) {
+		SND_LOG_ERR(HLOG, "ahub_info is null\n");
+		return -ENOMEM;
+	}
+	regmap = ahub_info->mem_info.regmap;
+	tdm_num = ahub_info->dts_info.tdm_num;
+	tx_pin = ahub_info->dts_info.tx_pin;
+	rx_pin = ahub_info->dts_info.rx_pin;
+
+	switch (slot_width) {
+	case 8:
+		slot_width_map = 1;
+		break;
+	case 12:
+		slot_width_map = 2;
+		break;
+	case 16:
+		slot_width_map = 3;
+		break;
+	case 20:
+		slot_width_map = 4;
+		break;
+	case 24:
+		slot_width_map = 5;
+		break;
+	case 28:
+		slot_width_map = 6;
+		break;
+	case 32:
+		slot_width_map = 7;
+		break;
+	default:
+		SND_LOG_ERR(HLOG, "unknown slot width\n");
+		return -EINVAL;
+	}
+	regmap_update_bits(regmap, SUNXI_AHUB_I2S_FMT0(tdm_num),
+			   0x7 << I2S_FMT0_SW, slot_width_map << I2S_FMT0_SW);
+
+	/* bclk num of per channel
+	 * I2S/RIGHT_J/LEFT_J	-> lrck long total is lrck_width_map * 2
+	 * DSP_A/DAP_B		-> lrck long total is lrck_width_map * 1
+	 */
+	switch (ahub_info->fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case    SND_SOC_DAIFMT_I2S:
+	case    SND_SOC_DAIFMT_RIGHT_J:
+	case    SND_SOC_DAIFMT_LEFT_J:
+		slots /= 2;
+		break;
+	case    SND_SOC_DAIFMT_DSP_A:
+	case    SND_SOC_DAIFMT_DSP_B:
+		break;
+	default:
+		SND_LOG_ERR(HLOG, "unsupoort format\n");
+		return -EINVAL;
+	}
+	lrck_width_map = slots * slot_width - 1;
+	regmap_update_bits(regmap, SUNXI_AHUB_I2S_FMT0(tdm_num),
+			   0x3ff << I2S_FMT0_LRCK_PERIOD,
+			   lrck_width_map << I2S_FMT0_LRCK_PERIOD);
+
+	return 0;
+}
+
+static int sunxi_ahub_dai_hw_params(struct snd_pcm_substream *substream,
+				    struct snd_pcm_hw_params *params,
+				    struct snd_soc_dai *dai)
+{
+	struct sunxi_ahub_info *ahub_info = snd_soc_dai_get_drvdata(dai);
+	struct regmap *regmap = NULL;
+	unsigned int apb_num, tdm_num, tx_pin, rx_pin;
+	unsigned int channels;
+	unsigned int channels_en[16] = {
+		0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,
+		0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff
+	};
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	if (IS_ERR_OR_NULL(ahub_info)) {
+		SND_LOG_ERR(HLOG, "ahub_info is null.\n");
+		return -ENOMEM;
+	}
+	regmap = ahub_info->mem_info.regmap;
+	apb_num = ahub_info->dts_info.apb_num;
+	tdm_num = ahub_info->dts_info.tdm_num;
+	tx_pin = ahub_info->dts_info.tx_pin;
+	rx_pin = ahub_info->dts_info.rx_pin;
+
+	/* configure DMA */
+	switch (params_physical_width(params)) {
+	case 16:
+		ahub_info->playback_dma_param.addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+		ahub_info->capture_dma_param.addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+		break;
+	case 24:
+	case 32:
+		ahub_info->playback_dma_param.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+		ahub_info->capture_dma_param.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+		break;
+	default:
+		dev_err(dai->dev, "Unsupported physical sample width: %d\n",
+			params_physical_width(params));
+		return -EINVAL;
+	}
+
+	/* set bits */
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		/* apbifn bits */
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			regmap_update_bits(regmap,
+					   SUNXI_AHUB_APBIF_TX_CTL(apb_num),
+					   0x7 << APBIF_TX_WS,
+					   0x3 << APBIF_TX_WS);
+			regmap_update_bits(regmap,
+					   SUNXI_AHUB_APBIF_TXFIFO_CTL(apb_num),
+					   0x1 << APBIF_TX_TXIM,
+					   0x1 << APBIF_TX_TXIM);
+		} else {
+			regmap_update_bits(regmap,
+					   SUNXI_AHUB_APBIF_RX_CTL(apb_num),
+					   0x7 << APBIF_RX_WS,
+					   0x3 << APBIF_RX_WS);
+			regmap_update_bits(regmap,
+					   SUNXI_AHUB_APBIF_RXFIFO_CTL(apb_num),
+					   0x3 << APBIF_RX_RXOM,
+					   0x1 << APBIF_RX_RXOM);
+		}
+
+		regmap_update_bits(regmap,
+				   SUNXI_AHUB_I2S_FMT0(tdm_num),
+				   0x7 << I2S_FMT0_SR,
+				   0x3 << I2S_FMT0_SR);
+		break;
+	case SNDRV_PCM_FORMAT_S20_3LE:
+	case SNDRV_PCM_FORMAT_S24_LE:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			regmap_update_bits(regmap, SUNXI_AHUB_APBIF_TX_CTL(apb_num),
+					   0x7 << APBIF_TX_WS, 0x5 << APBIF_TX_WS);
+			regmap_update_bits(regmap, SUNXI_AHUB_APBIF_TXFIFO_CTL(apb_num),
+					   0x1 << APBIF_TX_TXIM, 0x1 << APBIF_TX_TXIM);
+		} else {
+			regmap_update_bits(regmap, SUNXI_AHUB_APBIF_RX_CTL(apb_num),
+					   0x7 << APBIF_RX_WS, 0x5 << APBIF_RX_WS);
+			regmap_update_bits(regmap, SUNXI_AHUB_APBIF_RXFIFO_CTL(apb_num),
+					   0x3 << APBIF_RX_RXOM, 0x1 << APBIF_RX_RXOM);
+		}
+		regmap_update_bits(regmap, SUNXI_AHUB_I2S_FMT0(tdm_num),
+				   0x7 << I2S_FMT0_SR, 0x5 << I2S_FMT0_SR);
+		break;
+	case SNDRV_PCM_FORMAT_S32_LE:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			regmap_update_bits(regmap, SUNXI_AHUB_APBIF_TX_CTL(apb_num),
+					   0x7 << APBIF_TX_WS, 0x7 << APBIF_TX_WS);
+			regmap_update_bits(regmap, SUNXI_AHUB_APBIF_TXFIFO_CTL(apb_num),
+					   0x1 << APBIF_TX_TXIM, 0x1 << APBIF_TX_TXIM);
+		} else {
+			regmap_update_bits(regmap, SUNXI_AHUB_APBIF_RX_CTL(apb_num),
+					   0x7 << APBIF_RX_WS, 0x7 << APBIF_RX_WS);
+			regmap_update_bits(regmap, SUNXI_AHUB_APBIF_RXFIFO_CTL(apb_num),
+					   0x3 << APBIF_RX_RXOM, 0x1 << APBIF_RX_RXOM);
+		}
+		regmap_update_bits(regmap, SUNXI_AHUB_I2S_FMT0(tdm_num),
+				   0x7 << I2S_FMT0_SR, 0x7 << I2S_FMT0_SR);
+		break;
+	default:
+		SND_LOG_ERR(HLOG, "unrecognized format bits\n");
+		return -EINVAL;
+	}
+
+	/* set channels */
+	channels = params_channels(params);
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		/* apbifn channels */
+		regmap_update_bits(regmap, SUNXI_AHUB_APBIF_TX_CTL(apb_num),
+				   0xf << APBIF_TX_CHAN_NUM,
+				   (channels - 1) << APBIF_TX_CHAN_NUM);
+		/* tdmn channels */
+		regmap_update_bits(regmap, SUNXI_AHUB_I2S_CHCFG(tdm_num),
+				   0xf << I2S_CHCFG_TX_CHANNUM,
+				   (channels - 1) << I2S_CHCFG_TX_CHANNUM);
+
+		regmap_update_bits(regmap,
+				   SUNXI_AHUB_I2S_OUT_SLOT(tdm_num, tx_pin),
+				   0xf << I2S_OUT_SLOT_NUM,
+				   (channels - 1) << I2S_OUT_SLOT_NUM);
+		regmap_update_bits(regmap,
+				   SUNXI_AHUB_I2S_OUT_SLOT(tdm_num, tx_pin),
+				   0xffff << I2S_OUT_SLOT_EN,
+				   channels_en[channels - 1] << I2S_OUT_SLOT_EN);
+	} else {
+		/* apbifn channels */
+		regmap_update_bits(regmap, SUNXI_AHUB_APBIF_RX_CTL(apb_num),
+				   0xf << APBIF_RX_CHAN_NUM,
+				   (channels - 1) << APBIF_RX_CHAN_NUM);
+		/* tdmn channels */
+		regmap_update_bits(regmap, SUNXI_AHUB_I2S_CHCFG(tdm_num),
+				   0xf << I2S_CHCFG_RX_CHANNUM,
+				   (channels - 1) << I2S_CHCFG_RX_CHANNUM);
+		regmap_update_bits(regmap, SUNXI_AHUB_I2S_IN_SLOT(tdm_num),
+				   0xf << I2S_IN_SLOT_NUM,
+				   (channels - 1) << I2S_IN_SLOT_NUM);
+	}
+
+	return 0;
+}
+
+static void sunxi_ahub_dai_tx_route(struct sunxi_ahub_info *ahub_info,
+				    bool enable)
+{
+	struct regmap *regmap = NULL;
+	unsigned int tdm_num, tx_pin;
+	unsigned int apb_num;
+
+	SND_LOG_DEBUG(HLOG, "%s\n", enable ? "on" : "off");
+
+	regmap = ahub_info->mem_info.regmap;
+	tdm_num = ahub_info->dts_info.tdm_num;
+	tx_pin = ahub_info->dts_info.tx_pin;
+	apb_num = ahub_info->dts_info.apb_num;
+
+	if (enable)
+		goto tx_route_enable;
+	else
+		goto tx_route_disable;
+
+tx_route_enable:
+	regmap_update_bits(regmap, SUNXI_AHUB_I2S_CTL(tdm_num),
+			   0x1 << (I2S_CTL_SDO0_EN + tx_pin),
+			   0x1 << (I2S_CTL_SDO0_EN + tx_pin));
+	regmap_update_bits(regmap, SUNXI_AHUB_I2S_CTL(tdm_num),
+			   0x1 << I2S_CTL_TXEN, 0x1 << I2S_CTL_TXEN);
+	regmap_update_bits(regmap, SUNXI_AHUB_I2S_CTL(tdm_num),
+			   0x1 << I2S_CTL_OUT_MUTE, 0x0 << I2S_CTL_OUT_MUTE);
+	/* start apbif tx */
+	regmap_update_bits(regmap, SUNXI_AHUB_APBIF_TX_CTL(apb_num),
+			   0x1 << APBIF_TX_START, 0x1 << APBIF_TX_START);
+	/* enable tx drq */
+	regmap_update_bits(regmap, SUNXI_AHUB_APBIF_TX_IRQ_CTL(apb_num),
+			   0x1 << APBIF_TX_DRQ, 0x1 << APBIF_TX_DRQ);
+	return;
+
+tx_route_disable:
+	regmap_update_bits(regmap, SUNXI_AHUB_I2S_CTL(tdm_num),
+			   0x1 << I2S_CTL_OUT_MUTE, 0x1 << I2S_CTL_OUT_MUTE);
+	regmap_update_bits(regmap, SUNXI_AHUB_I2S_CTL(tdm_num),
+			   0x1 << I2S_CTL_TXEN, 0x0 << I2S_CTL_TXEN);
+	regmap_update_bits(regmap, SUNXI_AHUB_I2S_CTL(tdm_num),
+			   0x1 << (I2S_CTL_SDO0_EN + tx_pin),
+			   0x0 << (I2S_CTL_SDO0_EN + tx_pin));
+	/* stop apbif tx */
+	regmap_update_bits(regmap, SUNXI_AHUB_APBIF_TX_CTL(apb_num),
+			   0x1 << APBIF_TX_START, 0x0 << APBIF_TX_START);
+	/* disable tx drq */
+	regmap_update_bits(regmap, SUNXI_AHUB_APBIF_TX_IRQ_CTL(apb_num),
+			   0x1 << APBIF_TX_DRQ, 0x0 << APBIF_TX_DRQ);
+	return;
+}
+
+static void sunxi_ahub_dai_rx_route(struct sunxi_ahub_info *ahub_info,
+				    bool enable)
+{
+	struct regmap *regmap = NULL;
+	unsigned int tdm_num, rx_pin;
+	unsigned int apb_num;
+
+	SND_LOG_DEBUG(HLOG, "%s\n", enable ? "on" : "off");
+
+	regmap = ahub_info->mem_info.regmap;
+	tdm_num = ahub_info->dts_info.tdm_num;
+	rx_pin = ahub_info->dts_info.rx_pin;
+	apb_num = ahub_info->dts_info.apb_num;
+
+	if (enable)
+		goto rx_route_enable;
+	else
+		goto rx_route_disable;
+
+rx_route_enable:
+	regmap_update_bits(regmap, SUNXI_AHUB_I2S_CTL(tdm_num),
+			   0x1 << (I2S_CTL_SDI0_EN + rx_pin),
+			   0x1 << (I2S_CTL_SDI0_EN + rx_pin));
+	regmap_update_bits(regmap, SUNXI_AHUB_I2S_CTL(tdm_num),
+			   0x1 << I2S_CTL_RXEN, 0x1 << I2S_CTL_RXEN);
+	/* start apbif rx */
+	regmap_update_bits(regmap, SUNXI_AHUB_APBIF_RX_CTL(apb_num),
+			   0x1 << APBIF_RX_START, 0x1 << APBIF_RX_START);
+	/* enable rx drq */
+	regmap_update_bits(regmap, SUNXI_AHUB_APBIF_RX_IRQ_CTL(apb_num),
+			   0x1 << APBIF_RX_DRQ, 0x1 << APBIF_RX_DRQ);
+	return;
+
+rx_route_disable:
+	regmap_update_bits(regmap, SUNXI_AHUB_I2S_CTL(tdm_num),
+			   0x1 << I2S_CTL_RXEN, 0x0 << I2S_CTL_RXEN);
+	regmap_update_bits(regmap, SUNXI_AHUB_I2S_CTL(tdm_num),
+			   0x1 << (I2S_CTL_SDI0_EN + rx_pin),
+			   0x0 << (I2S_CTL_SDI0_EN + rx_pin));
+	/* stop apbif rx */
+	regmap_update_bits(regmap, SUNXI_AHUB_APBIF_RX_CTL(apb_num),
+			   0x1 << APBIF_RX_START, 0x0 << APBIF_RX_START);
+	/* disable rx drq */
+	regmap_update_bits(regmap, SUNXI_AHUB_APBIF_RX_IRQ_CTL(apb_num),
+			   0x1 << APBIF_RX_DRQ, 0x0 << APBIF_RX_DRQ);
+	return;
+}
+
+static int sunxi_ahub_dai_trigger(struct snd_pcm_substream *substream,
+				  int cmd,
+				  struct snd_soc_dai *dai)
+{
+	struct sunxi_ahub_info *ahub_info = snd_soc_dai_get_drvdata(dai);
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	if (IS_ERR_OR_NULL(ahub_info)) {
+		SND_LOG_ERR(HLOG, "ahub_info is null.\n");
+		return -ENOMEM;
+	}
+
+	switch (cmd) {
+	case	SNDRV_PCM_TRIGGER_START:
+	case	SNDRV_PCM_TRIGGER_RESUME:
+	case	SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			sunxi_ahub_dai_tx_route(ahub_info, true);
+		} else {
+			sunxi_ahub_dai_rx_route(ahub_info, true);
+		}
+		break;
+	case	SNDRV_PCM_TRIGGER_STOP:
+	case	SNDRV_PCM_TRIGGER_SUSPEND:
+	case	SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			sunxi_ahub_dai_tx_route(ahub_info, false);
+		} else {
+			sunxi_ahub_dai_rx_route(ahub_info, false);
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sunxi_ahub_dai_prepare(struct snd_pcm_substream *substream,
+				  struct snd_soc_dai *dai)
+{
+	struct sunxi_ahub_info *ahub_info = snd_soc_dai_get_drvdata(dai);
+	struct regmap *regmap = NULL;
+	unsigned int apb_num;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	if (IS_ERR_OR_NULL(ahub_info)) {
+		SND_LOG_ERR(HLOG, "ahub_info is null.\n");
+		return -ENOMEM;
+	}
+	regmap = ahub_info->mem_info.regmap;
+	apb_num = ahub_info->dts_info.apb_num;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		/* clear txfifo */
+		regmap_update_bits(regmap, SUNXI_AHUB_APBIF_TXFIFO_CTL(apb_num),
+				   0x1 << APBIF_TX_FTX, 0x1 << APBIF_TX_FTX);
+		/* clear tx o/u irq */
+		regmap_write(regmap, SUNXI_AHUB_APBIF_TX_IRQ_STA(apb_num),
+			     (0x1 << APBIF_TX_OV_PEND) | (0x1 << APBIF_TX_EM_PEND));
+		/* clear tx fifo cnt */
+		regmap_write(regmap, SUNXI_AHUB_APBIF_TXFIFO_CNT(apb_num), 0);
+	} else {
+		/* clear rxfifo */
+		regmap_update_bits(regmap, SUNXI_AHUB_APBIF_RXFIFO_CTL(apb_num),
+				   0x1 << APBIF_RX_FRX, 0x1 << APBIF_RX_FRX);
+		/* clear rx o/u irq */
+		regmap_write(regmap, SUNXI_AHUB_APBIF_RX_IRQ_STA(apb_num),
+			     (0x1 << APBIF_RX_UV_PEND) | (0x1 << APBIF_RX_AV_PEND));
+		/* clear rx fifo cnt */
+		regmap_write(regmap, SUNXI_AHUB_APBIF_RXFIFO_CNT(apb_num), 0);
+	}
+
+	return 0;
+}
+
+static void sunxi_ahub_dai_shutdown(struct snd_pcm_substream *substream,
+				    struct snd_soc_dai *dai)
+{
+	struct sunxi_ahub_info *ahub_info = snd_soc_dai_get_drvdata(dai);
+	struct regmap *regmap = NULL;
+	unsigned int apb_num, tdm_num;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	regmap = ahub_info->mem_info.regmap;
+	apb_num = ahub_info->dts_info.apb_num;
+	tdm_num = ahub_info->dts_info.tdm_num;
+
+	/* APBIF & I2S of RST and GAT */
+	if (tdm_num > 3 || apb_num > 2) {
+		SND_LOG_ERR(HLOG, "unspport tdm num or apbif num\n");
+		return;
+	}
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		regmap_update_bits(regmap, SUNXI_AHUB_RST,
+				   0x1 << (APBIF_TXDIF0_RST - apb_num),
+				   0x0 << (APBIF_TXDIF0_RST - apb_num));
+		regmap_update_bits(regmap, SUNXI_AHUB_GAT,
+				   0x1 << (APBIF_TXDIF0_GAT - apb_num),
+				   0x0 << (APBIF_TXDIF0_GAT - apb_num));
+	} else {
+		regmap_update_bits(regmap, SUNXI_AHUB_RST,
+				   0x1 << (APBIF_RXDIF0_RST - apb_num),
+				   0x0 << (APBIF_RXDIF0_RST - apb_num));
+		regmap_update_bits(regmap, SUNXI_AHUB_GAT,
+				   0x1 << (APBIF_RXDIF0_GAT - apb_num),
+				   0x0 << (APBIF_RXDIF0_GAT - apb_num));
+	}
+}
+
+static void snd_soc_sunxi_ahub_init(struct sunxi_ahub_info *ahub_info)
+{
+	struct regmap *regmap = NULL;
+	unsigned int apb_num, tdm_num, tx_pin, rx_pin;
+	unsigned int reg_val = 0;
+	unsigned int rx_pin_map = 0;
+	unsigned int tdm_to_apb = 0;
+	unsigned int apb_to_tdm = 0;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	regmap = ahub_info->mem_info.regmap;
+	apb_num = ahub_info->dts_info.apb_num;
+	tdm_num = ahub_info->dts_info.tdm_num;
+	tx_pin = ahub_info->dts_info.tx_pin;
+	rx_pin = ahub_info->dts_info.rx_pin;
+
+	regmap_update_bits(regmap, SUNXI_AHUB_I2S_CTL(tdm_num),
+			   0x1 << I2S_CTL_GEN, 0x1 << I2S_CTL_GEN);
+	regmap_update_bits(regmap, SUNXI_AHUB_RST,
+			   0x1 << (I2S0_RST - tdm_num),
+			   0x1 << (I2S0_RST - tdm_num));
+	regmap_update_bits(regmap, SUNXI_AHUB_GAT,
+			   0x1 << (I2S0_GAT - tdm_num),
+			   0x1 << (I2S0_GAT - tdm_num));
+
+	/* tdm tx channels map */
+	regmap_write(regmap, SUNXI_AHUB_I2S_OUT_CHMAP0(tdm_num, tx_pin), 0x76543210);
+	regmap_write(regmap, SUNXI_AHUB_I2S_OUT_CHMAP1(tdm_num, tx_pin), 0xFEDCBA98);
+
+	/* tdm rx channels map */
+	rx_pin_map = (rx_pin << 4) | (rx_pin << 12) | (rx_pin << 20) | (rx_pin << 28);
+	reg_val = 0x03020100 | rx_pin_map;
+	regmap_write(regmap, SUNXI_AHUB_I2S_IN_CHMAP0(tdm_num), reg_val);
+	reg_val = 0x07060504 | rx_pin_map;
+	regmap_write(regmap, SUNXI_AHUB_I2S_IN_CHMAP1(tdm_num), reg_val);
+	reg_val = 0x0B0A0908 | rx_pin_map;
+	regmap_write(regmap, SUNXI_AHUB_I2S_IN_CHMAP2(tdm_num), reg_val);
+	reg_val = 0x0F0E0D0C | rx_pin_map;
+	regmap_write(regmap, SUNXI_AHUB_I2S_IN_CHMAP3(tdm_num), reg_val);
+
+	/* tdm tx & rx data fmt
+	 * 1. MSB first
+	 * 2. transfer 0 after each sample in each slot
+	 * 3. linear PCM
+	 */
+	regmap_write(regmap, SUNXI_AHUB_I2S_FMT1(tdm_num), 0x30);
+
+	/* apbif tx & rx data fmt
+	 * 1. MSB first
+	 * 2. trigger level tx -> 0x20, rx -> 0x40
+	 */
+	regmap_update_bits(regmap, SUNXI_AHUB_APBIF_TXFIFO_CTL(apb_num),
+			   0x1 << APBIF_TX_TXIM, 0x0 << APBIF_TX_TXIM);
+	regmap_update_bits(regmap, SUNXI_AHUB_APBIF_TXFIFO_CTL(apb_num),
+			   0x3f << APBIF_TX_LEVEL, 0x20 << APBIF_TX_LEVEL);
+	regmap_update_bits(regmap, SUNXI_AHUB_APBIF_RXFIFO_CTL(apb_num),
+			   0x3 << APBIF_RX_RXOM, 0x0 << APBIF_RX_RXOM);
+	regmap_update_bits(regmap, SUNXI_AHUB_APBIF_RXFIFO_CTL(apb_num),
+			   0x7f << APBIF_RX_LEVEL, 0x40 << APBIF_RX_LEVEL);
+
+	/* apbif <-> tdm */
+	switch (tdm_num)
+	{
+	case 0:
+		tdm_to_apb = APBIF_RX_I2S0_TXDIF;
+		break;
+	case 1:
+		tdm_to_apb = APBIF_RX_I2S1_TXDIF;
+		break;
+	case 2:
+		tdm_to_apb = APBIF_RX_I2S2_TXDIF;
+		break;
+	case 3:
+		tdm_to_apb = APBIF_RX_I2S3_TXDIF;
+		break;
+	default:
+		SND_LOG_ERR(HLOG, "unspport tdm num\n");
+		return;
+	}
+	regmap_write(regmap, SUNXI_AHUB_APBIF_RXFIFO_CONT(apb_num), 0x1 << tdm_to_apb);
+
+	switch (apb_num)
+	{
+	case 0:
+		apb_to_tdm = I2S_RX_APBIF_TXDIF0;
+		break;
+	case 1:
+		apb_to_tdm = I2S_RX_APBIF_TXDIF1;
+		break;
+	case 2:
+		apb_to_tdm = I2S_RX_APBIF_TXDIF2;
+		break;
+	default:
+		SND_LOG_ERR(HLOG, "unspport apb num\n");
+		return;
+	}
+	regmap_write(regmap, SUNXI_AHUB_I2S_RXCONT(tdm_num), 0x1 << apb_to_tdm);
+
+	return;
+}
+
+static int sunxi_ahub_dai_probe(struct snd_soc_dai *dai)
+{
+	struct sunxi_ahub_info *ahub_info = snd_soc_dai_get_drvdata(dai);
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	/* pcm_new will using the dma_param about the cma and fifo params. */
+	snd_soc_dai_init_dma_data(dai,
+				  &ahub_info->playback_dma_param,
+				  &ahub_info->capture_dma_param);
+
+	snd_soc_sunxi_ahub_init(ahub_info);
+
+	return 0;
+}
+
+static int sunxi_ahub_dai_remove(struct snd_soc_dai *dai)
+{
+	struct sunxi_ahub_info *ahub_info = snd_soc_dai_get_drvdata(dai);
+	struct regmap *regmap = NULL;
+	unsigned int tdm_num;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	regmap = ahub_info->mem_info.regmap;
+	tdm_num = ahub_info->dts_info.tdm_num;
+
+	regmap_update_bits(regmap, SUNXI_AHUB_I2S_CTL(tdm_num),
+			   0x1 << I2S_CTL_GEN, 0x0 << I2S_CTL_GEN);
+	regmap_update_bits(regmap, SUNXI_AHUB_RST,
+			   0x1 << (I2S0_RST - tdm_num),
+			   0x0 << (I2S0_RST - tdm_num));
+	regmap_update_bits(regmap, SUNXI_AHUB_GAT,
+			   0x1 << (I2S0_GAT - tdm_num),
+			   0x0 << (I2S0_GAT - tdm_num));
+
+	return 0;
+}
+
+static const struct snd_soc_dai_ops sunxi_ahub_dai_ops = {
+	/* call by machine */
+	.set_pll	= sunxi_ahub_dai_set_pll,	// set pllclk
+	.set_sysclk	= sunxi_ahub_dai_set_sysclk,	// set mclk
+	.set_bclk_ratio	= sunxi_ahub_dai_set_bclk_ratio,// set bclk freq
+	.set_tdm_slot	= sunxi_ahub_dai_set_tdm_slot,	// set slot num and width
+	.set_fmt	= sunxi_ahub_dai_set_fmt,	// set tdm fmt
+	/* call by asoc */
+	.probe		= sunxi_ahub_dai_probe,
+	.startup	= sunxi_ahub_dai_startup,
+	.hw_params	= sunxi_ahub_dai_hw_params,	// set hardware params
+	.prepare	= sunxi_ahub_dai_prepare,	// clean irq and fifo
+	.trigger	= sunxi_ahub_dai_trigger,	// set drq
+	.remove		= sunxi_ahub_dai_remove,
+	.shutdown	= sunxi_ahub_dai_shutdown,
+};
+
+static struct snd_soc_dai_driver sunxi_ahub_dai = {
+	.name		= "ahub_plat",
+	.playback = {
+		.stream_name	= "Playback",
+		.channels_min	= 1,
+		.channels_max	= 2,
+		.rates		= SNDRV_PCM_RATE_8000_192000
+				| SNDRV_PCM_RATE_KNOT,
+		.formats	= SNDRV_PCM_FMTBIT_S16_LE
+				| SNDRV_PCM_FMTBIT_S24_LE
+				| SNDRV_PCM_FMTBIT_S32_LE,
+	},
+	.capture = {
+		.stream_name	= "Capture",
+		.channels_min	= 1,
+		.channels_max	= 2,
+		.rates		= SNDRV_PCM_RATE_8000_192000
+				| SNDRV_PCM_RATE_KNOT,
+		.formats	= SNDRV_PCM_FMTBIT_S16_LE
+				| SNDRV_PCM_FMTBIT_S24_LE
+				| SNDRV_PCM_FMTBIT_S32_LE,
+	},
+	.ops = &sunxi_ahub_dai_ops,
+};
+
+static int sunxi_ahub_probe(struct snd_soc_component *component)
+{
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	return 0;
+}
+
+static int sunxi_ahub_suspend(struct snd_soc_component *component)
+{
+	struct sunxi_ahub_info *ahub_info = snd_soc_component_get_drvdata(component);
+	struct regmap *regmap = NULL;
+	unsigned int apb_num, tdm_num;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	regmap = ahub_info->mem_info.regmap;
+	apb_num = ahub_info->dts_info.apb_num;
+	tdm_num = ahub_info->dts_info.tdm_num;
+
+	return 0;
+}
+
+static int sunxi_ahub_resume(struct snd_soc_component *component)
+{
+	struct sunxi_ahub_info *ahub_info = snd_soc_component_get_drvdata(component);
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	snd_soc_sunxi_ahub_init(ahub_info);
+
+	return 0;
+}
+
+int sunxi_loopback_debug_get(struct snd_kcontrol *kcontrol,
+			     struct snd_ctl_elem_value *ucontrol)
+{
+	unsigned int reg_val;
+	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
+	struct sunxi_ahub_info *ahub_info = snd_soc_component_get_drvdata(component);
+	struct sunxi_ahub_mem_info *mem_info = &ahub_info->mem_info;
+	struct sunxi_ahub_dts_info *dts_info = &ahub_info->dts_info;
+
+	regmap_read(mem_info->regmap, SUNXI_AHUB_I2S_CTL(dts_info->tdm_num), &reg_val);
+	ucontrol->value.integer.value[0] = ((reg_val & (1 << I2S_CTL_LOOP0)) ? 1 : 0);
+
+	return 0;
+}
+
+int sunxi_loopback_debug_set(struct snd_kcontrol *kcontrol,
+			     struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
+	struct sunxi_ahub_info *ahub_info = snd_soc_component_get_drvdata(component);
+	struct sunxi_ahub_mem_info *mem_info = &ahub_info->mem_info;
+	struct sunxi_ahub_dts_info *dts_info = &ahub_info->dts_info;
+
+	switch (ucontrol->value.integer.value[0]) {
+	case	0:
+		regmap_update_bits(mem_info->regmap,
+				   SUNXI_AHUB_I2S_CTL(dts_info->tdm_num),
+				   1 << I2S_CTL_LOOP0, 0 << I2S_CTL_LOOP0);
+		break;
+	case	1:
+		regmap_update_bits(mem_info->regmap,
+				   SUNXI_AHUB_I2S_CTL(dts_info->tdm_num),
+				   1 << I2S_CTL_LOOP0, 1 << I2S_CTL_LOOP0);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static const struct snd_kcontrol_new sunxi_ahub_controls[] = {
+	SOC_SINGLE_EXT("loopback debug", SND_SOC_NOPM, 0, 1, 0,
+		       sunxi_loopback_debug_get, sunxi_loopback_debug_set),
+};
+
+static struct snd_soc_component_driver sunxi_ahub_component = {
+	.name		= DRV_NAME,
+	.probe		= sunxi_ahub_probe,
+	.suspend	= sunxi_ahub_suspend,
+	.resume		= sunxi_ahub_resume,
+	.controls	= sunxi_ahub_controls,
+	.num_controls	= ARRAY_SIZE(sunxi_ahub_controls),
+};
+
+/*******************************************************************************
+ * for kernel source
+ ******************************************************************************/
+static int snd_soc_sunxi_ahub_pin_init(struct platform_device *pdev,
+				       struct device_node *np,
+				       struct sunxi_ahub_pinctl_info *pin_info)
+{
+	int ret = 0;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	if (of_property_read_bool(np, "pinctrl_used")) {
+		pin_info->pinctrl_used = 1;
+	} else {
+		pin_info->pinctrl_used = 0;
+		SND_LOG_DEBUG(HLOG, "unused pinctrl\n");
+		return 0;
+	}
+
+	pin_info->pinctrl = devm_pinctrl_get(&pdev->dev);
+	if (IS_ERR_OR_NULL(pin_info->pinctrl)) {
+		SND_LOG_ERR(HLOG, "pinctrl get failed\n");
+		ret = -EINVAL;
+		return ret;
+	}
+	pin_info->pinstate = pinctrl_lookup_state(pin_info->pinctrl,
+						  PINCTRL_STATE_DEFAULT);
+	if (IS_ERR_OR_NULL(pin_info->pinstate)) {
+		SND_LOG_ERR(HLOG, "pinctrl default state get fail\n");
+		ret = -EINVAL;
+		goto err_loopup_pinstate;
+	}
+	pin_info->pinstate_sleep = pinctrl_lookup_state(pin_info->pinctrl,
+							PINCTRL_STATE_SLEEP);
+	if (IS_ERR_OR_NULL(pin_info->pinstate_sleep)) {
+		SND_LOG_ERR(HLOG, "pinctrl sleep state get failed\n");
+		ret = -EINVAL;
+		goto err_loopup_pin_sleep;
+	}
+	ret = pinctrl_select_state(pin_info->pinctrl, pin_info->pinstate);
+	if (ret < 0) {
+		SND_LOG_ERR(HLOG, "daudio set pinctrl default state fail\n");
+		ret = -EBUSY;
+		goto err_pinctrl_select_default;
+	}
+
+	return 0;
+
+err_pinctrl_select_default:
+err_loopup_pin_sleep:
+err_loopup_pinstate:
+	devm_pinctrl_put(pin_info->pinctrl);
+	return ret;
+}
+
+static int snd_soc_sunxi_ahub_dts_params_init(struct platform_device *pdev,
+					      struct device_node *np,
+					      struct sunxi_ahub_dts_info *dts_info)
+{
+	int ret = 0;
+	unsigned int temp_val = 0;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	/* get tdm fmt of apb_num & tdm_num & tx/rx_pin */
+	ret = of_property_read_u32(np, "apb_num", &temp_val);
+	if (ret < 0) {
+		SND_LOG_WARN(HLOG, "apb_num config missing\n");
+		dts_info->apb_num = 0;
+	} else {
+		if (temp_val > 2) {	/* APBIFn (n = 0~2) */
+			dts_info->apb_num = 0;
+			SND_LOG_WARN(HLOG, "apb_num config invalid\n");
+		} else {
+			dts_info->apb_num = temp_val;
+		}
+	}
+	ret = of_property_read_u32(np, "tdm_num", &temp_val);
+	if (ret < 0) {
+		SND_LOG_WARN(HLOG, "tdm_num config missing\n");
+		dts_info->tdm_num = 0;
+	} else {
+		if (temp_val > 3) {	/* I2Sn (n = 0~3) */
+			dts_info->tdm_num = 0;
+			SND_LOG_WARN(HLOG, "tdm_num config invalid\n");
+		} else {
+			dts_info->tdm_num = temp_val;
+		}
+	}
+	ret = of_property_read_u32(np, "tx_pin", &temp_val);
+	if (ret < 0) {
+		SND_LOG_WARN(HLOG, "tx_pin config missing\n");
+		dts_info->tx_pin = 0;
+	} else {
+		if (temp_val > 3) {	/* I2S_DOUTn (n = 0~3) */
+			dts_info->tx_pin = 0;
+			SND_LOG_WARN(HLOG, "tx_pin config invalid\n");
+		} else {
+			dts_info->tx_pin = temp_val;
+		}
+	}
+	ret = of_property_read_u32(np, "rx_pin", &temp_val);
+	if (ret < 0) {
+		SND_LOG_WARN(HLOG, "rx_pin config missing\n");
+		dts_info->rx_pin = 0;
+	} else {
+		if (temp_val > 3) {	/* I2S_DINTn (n = 0~3) */
+			dts_info->rx_pin = 0;
+			SND_LOG_WARN(HLOG, "rx_pin config invalid\n");
+		} else {
+			dts_info->rx_pin = temp_val;
+		}
+	}
+
+	SND_LOG_DEBUG(HLOG, "playback_cma : %lu\n", dts_info->playback_cma);
+	SND_LOG_DEBUG(HLOG, "capture_cma  : %lu\n", dts_info->capture_cma);
+	SND_LOG_DEBUG(HLOG, "tx_fifo_size : %lu\n", dts_info->playback_fifo_size);
+	SND_LOG_DEBUG(HLOG, "rx_fifo_size : %lu\n", dts_info->capture_fifo_size);
+	SND_LOG_DEBUG(HLOG, "apb_num      : %u\n", dts_info->apb_num);
+	SND_LOG_DEBUG(HLOG, "tdm_num      : %u\n", dts_info->tdm_num);
+	SND_LOG_DEBUG(HLOG, "tx_pin       : %u\n", dts_info->tx_pin);
+	SND_LOG_DEBUG(HLOG, "rx_pin       : %u\n", dts_info->rx_pin);
+
+	return 0;
+};
+
+static int snd_soc_sunxi_ahub_regulator_init(struct platform_device *pdev,
+					     struct device_node *np,
+					     struct sunxi_ahub_regulator_info *regulator_info)
+{
+	int ret = 0;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	regulator_info->regulator_name = NULL;
+	if (of_property_read_string(np, "ahub_regulator", &regulator_info->regulator_name)) {
+		SND_LOG_DEBUG(HLOG, "regulator missing\n");
+		regulator_info->regulator = NULL;
+		return 0;
+	}
+
+	regulator_info->regulator = regulator_get(NULL, regulator_info->regulator_name);
+	if (IS_ERR_OR_NULL(regulator_info->regulator)) {
+		SND_LOG_ERR(HLOG, "get duaido vcc-pin failed\n");
+		ret = -EFAULT;
+		goto err_regulator_get;
+	}
+	ret = regulator_set_voltage(regulator_info->regulator, 3300000, 3300000);
+	if (ret < 0) {
+		SND_LOG_ERR(HLOG, "set duaido voltage failed\n");
+		ret = -EFAULT;
+		goto err_regulator_set_vol;
+	}
+	ret = regulator_enable(regulator_info->regulator);
+	if (ret < 0) {
+		SND_LOG_ERR(HLOG, "enable duaido vcc-pin failed\n");
+		ret = -EFAULT;
+		goto err_regulator_enable;
+	}
+
+	return 0;
+
+err_regulator_enable:
+err_regulator_set_vol:
+	if (regulator_info->regulator)
+		regulator_put(regulator_info->regulator);
+err_regulator_get:
+	return ret;
+};
+
+static void snd_soc_sunxi_dma_params_init(struct sunxi_ahub_info *ahub_info)
+{
+	struct resource *res = ahub_info->mem_info.res;
+	struct sunxi_ahub_dts_info *dts_info = &ahub_info->dts_info;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	ahub_info->playback_dma_param.addr =
+		res->start + SUNXI_AHUB_APBIF_TXFIFO(dts_info->apb_num);
+	ahub_info->playback_dma_param.maxburst = 8;
+	//ahub_info->playback_dma_param.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+
+	ahub_info->capture_dma_param.addr =
+		res->start + SUNXI_AHUB_APBIF_RXFIFO(dts_info->apb_num);
+	ahub_info->capture_dma_param.maxburst = 8;
+	//ahub_info->capture_dma_param.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+};
+
+static int sunxi_ahub_dev_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct device_node *np = pdev->dev.of_node;
+	struct sunxi_ahub_info *ahub_info = NULL;
+	struct sunxi_ahub_mem_info *mem_info = NULL;
+	struct sunxi_ahub_clk_info *clk_info = NULL;
+	struct sunxi_ahub_pinctl_info *pin_info = NULL;
+	struct sunxi_ahub_dts_info *dts_info = NULL;
+	struct sunxi_ahub_regulator_info *regulator_info = NULL;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	ahub_info = devm_kzalloc(&pdev->dev,
+				  sizeof(struct sunxi_ahub_info),
+				  GFP_KERNEL);
+	if (IS_ERR_OR_NULL(ahub_info)) {
+		SND_LOG_ERR(HLOG, "alloc sunxi_ahub_info failed\n");
+		ret = -ENOMEM;
+		goto err_devm_malloc_sunxi_daudio;
+	}
+	dev_set_drvdata(&pdev->dev, ahub_info);
+	ahub_info->dev = &pdev->dev;
+	mem_info = &ahub_info->mem_info;
+	clk_info = &ahub_info->clk_info;
+	pin_info = &ahub_info->pin_info;
+	dts_info = &ahub_info->dts_info;
+	regulator_info = &ahub_info->regulator_info;
+
+	ret = snd_soc_sunxi_ahub_mem_get(mem_info);
+	if (ret) {
+		SND_LOG_ERR(HLOG, "remap get failed\n");
+		ret = -EINVAL;
+		goto err_snd_soc_sunxi_ahub_mem_get;
+	}
+
+	ret = snd_soc_sunxi_ahub_clk_get(clk_info);
+	if (ret) {
+		SND_LOG_ERR(HLOG, "clk get failed\n");
+		ret = -EINVAL;
+		goto err_snd_soc_sunxi_ahub_clk_get;
+	}
+
+	ret = snd_soc_sunxi_ahub_dts_params_init(pdev, np, dts_info);
+	if (ret) {
+		SND_LOG_ERR(HLOG, "dts init failed\n");
+		ret = -EINVAL;
+		goto err_snd_soc_sunxi_ahub_dts_params_init;
+	}
+
+	ret = snd_soc_sunxi_ahub_pin_init(pdev, np, pin_info);
+	if (ret) {
+		SND_LOG_ERR(HLOG, "pinctrl init failed\n");
+		ret = -EINVAL;
+		goto err_snd_soc_sunxi_ahub_pin_init;
+	}
+
+	ret = snd_soc_sunxi_ahub_regulator_init(pdev, np, regulator_info);
+	if (ret) {
+		SND_LOG_ERR(HLOG, "regulator_info init failed\n");
+		ret = -EINVAL;
+		goto err_snd_soc_sunxi_ahub_regulator_init;
+	}
+
+	snd_soc_sunxi_dma_params_init(ahub_info);
+
+	ret = snd_soc_register_component(&pdev->dev,
+					 &sunxi_ahub_component,
+					 &sunxi_ahub_dai, 1);
+	if (ret) {
+		SND_LOG_ERR(HLOG, "component register failed\n");
+		ret = -ENOMEM;
+		goto err_snd_soc_register_component;
+	}
+
+        ret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);
+        if (ret) {
+		SND_LOG_ERR(HLOG, "register ASoC platform failed\n");
+		ret = -ENOMEM;
+		goto err_snd_soc_sunxi_dma_platform_register;
+        }
+
+	SND_LOG_DEBUG(HLOG, "register ahub platform success\n");
+
+	return 0;
+
+err_snd_soc_sunxi_dma_platform_register:
+	snd_soc_unregister_component(&pdev->dev);
+err_snd_soc_register_component:
+err_snd_soc_sunxi_ahub_regulator_init:
+err_snd_soc_sunxi_ahub_dts_params_init:
+err_snd_soc_sunxi_ahub_pin_init:
+err_snd_soc_sunxi_ahub_clk_get:
+err_snd_soc_sunxi_ahub_mem_get:
+	devm_kfree(&pdev->dev, ahub_info);
+err_devm_malloc_sunxi_daudio:
+	of_node_put(np);
+	return ret;
+}
+
+static void sunxi_ahub_dev_remove(struct platform_device *pdev)
+{
+	struct sunxi_ahub_info *ahub_info = dev_get_drvdata(&pdev->dev);
+	struct sunxi_ahub_pinctl_info *pin_info = &ahub_info->pin_info;
+	struct sunxi_ahub_regulator_info *regulator_info = &ahub_info->regulator_info;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	snd_soc_unregister_component(&pdev->dev);
+
+	if (regulator_info->regulator) {
+		if (!IS_ERR_OR_NULL(regulator_info->regulator)) {
+			regulator_disable(regulator_info->regulator);
+			regulator_put(regulator_info->regulator);
+		}
+	}
+	if (pin_info->pinctrl_used) {
+		devm_pinctrl_put(pin_info->pinctrl);
+	}
+
+	devm_kfree(&pdev->dev, ahub_info);
+
+	SND_LOG_DEBUG(HLOG, "unregister ahub platform success\n");
+}
+
+static const struct of_device_id sunxi_ahub_of_match[] = {
+	{ .compatible = "allwinner," DRV_NAME, },
+	{},
+};
+MODULE_DEVICE_TABLE(of, sunxi_ahub_of_match);
+
+static struct platform_driver sunxi_ahub_driver = {
+	.driver	= {
+		.name		= DRV_NAME,
+		.owner		= THIS_MODULE,
+		.of_match_table	= sunxi_ahub_of_match,
+	},
+	.probe	= sunxi_ahub_dev_probe,
+	.remove	= sunxi_ahub_dev_remove,
+};
+
+int __init sunxi_ahub_dev_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&sunxi_ahub_driver);
+	if (ret != 0) {
+		SND_LOG_ERR(HLOG, "platform driver register failed\n");
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+void __exit sunxi_ahub_dev_exit(void)
+{
+	platform_driver_unregister(&sunxi_ahub_driver);
+}
+
+late_initcall(sunxi_ahub_dev_init);
+module_exit(sunxi_ahub_dev_exit);
+
+MODULE_AUTHOR("Dby@allwinnertech.com");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("sunxi soundcard platform of ahub");
diff --git a/sound/soc/sunxi_v2/snd_sunxi_ahub.h b/sound/soc/sunxi_v2/snd_sunxi_ahub.h
new file mode 100644
index 000000000..ee5df6480
--- /dev/null
+++ b/sound/soc/sunxi_v2/snd_sunxi_ahub.h
@@ -0,0 +1,67 @@
+/* sound\soc\sunxi\snd_sunxi_ahub.h
+ * (C) Copyright 2021-2025
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Dby <dby@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#ifndef __SND_SUNXI_AHUB_H
+#define __SND_SUNXI_AHUB_H
+
+#include "snd_sunxi_ahub_dam.h"
+
+struct sunxi_ahub_pinctl_info {
+	struct pinctrl *pinctrl;
+	struct pinctrl_state *pinstate;
+	struct pinctrl_state *pinstate_sleep;
+
+	bool pinctrl_used;
+};
+
+struct sunxi_ahub_dts_info {
+	unsigned int dai_type;
+	unsigned int apb_num;
+	unsigned int tdm_num;
+	unsigned int tx_pin;
+	unsigned int rx_pin;
+
+	/* value must be (2^n)Kbyte */
+	size_t playback_cma;
+	size_t playback_fifo_size;
+	size_t capture_cma;
+	size_t capture_fifo_size;
+};
+
+struct sunxi_ahub_regulator_info {
+	struct regulator *regulator;
+	const char *regulator_name;
+};
+
+struct sunxi_ahub_info {
+	struct device *dev;
+
+	struct sunxi_ahub_mem_info mem_info;
+	struct sunxi_ahub_clk_info clk_info;
+	struct sunxi_ahub_pinctl_info pin_info;
+	struct sunxi_ahub_dts_info dts_info;
+	struct sunxi_ahub_regulator_info regulator_info;
+
+	//struct sunxi_dma_params playback_dma_param;
+	//struct sunxi_dma_params capture_dma_param;
+        struct snd_dmaengine_dai_dma_data playback_dma_param;
+        struct snd_dmaengine_dai_dma_data capture_dma_param;
+
+	/* for Hardware param setting */
+	unsigned int fmt;
+	unsigned int pllclk_freq;
+	unsigned int moduleclk_freq;
+	unsigned int mclk_freq;
+	unsigned int lrck_freq;
+	unsigned int bclk_freq;
+};
+
+#endif /* __SND_SUNXI_AHUB_H */
diff --git a/sound/soc/sunxi_v2/snd_sunxi_ahub_dam.c b/sound/soc/sunxi_v2/snd_sunxi_ahub_dam.c
new file mode 100644
index 000000000..f3c7bb3c7
--- /dev/null
+++ b/sound/soc/sunxi_v2/snd_sunxi_ahub_dam.c
@@ -0,0 +1,532 @@
+/*
+ * sound\soc\sunxi\snd_sunxi_ahub_dam.c
+ * (C) Copyright 2021-2025
+ * AllWinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Dby <dby@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <sound/soc.h>
+#include <linux/regulator/consumer.h>
+#include <linux/of.h>
+#include <linux/clk.h>
+#include <linux/reset.h>
+#include <linux/device.h>
+#include <linux/ioport.h>
+#include <linux/regmap.h>
+#include <linux/of_address.h>
+#include <linux/of_gpio.h>
+#include <sound/soc.h>
+
+#include "snd_sunxi_log.h"
+#include "snd_sunxi_ahub_dam.h"
+
+#define HLOG		"AHUB_DAM"
+#define DRV_NAME	"sunxi-snd-plat-ahub_dam"
+
+static struct resource g_res;
+struct sunxi_ahub_mem_info g_mem_info = {
+	.res = &g_res,
+};
+static struct sunxi_ahub_clk_info g_clk_info;
+static struct regmap_config g_regmap_config = {
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.max_register = SUNXI_AHUB_MAX_REG,
+	.cache_type = REGCACHE_NONE,
+};
+
+static struct snd_soc_dai_driver sunxi_ahub_dam_dai = {
+	.name           = "ahub_dam",
+};
+
+static int sunxi_ahub_dam_probe(struct snd_soc_component *component)
+{
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	return 0;
+}
+
+static int sunxi_ahub_dam_suspend(struct snd_soc_component *component)
+{
+	struct sunxi_ahub_clk_info *clk_info = &g_clk_info;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	clk_disable_unprepare(clk_info->clk_module);
+	clk_disable_unprepare(clk_info->clk_pll);
+	//clk_disable_unprepare(clk_info->clk_pllx4);
+	clk_disable_unprepare(clk_info->clk_bus);
+	reset_control_assert(clk_info->clk_rst);
+
+	return 0;
+}
+
+static int sunxi_ahub_dam_resume(struct snd_soc_component *component)
+{
+	struct sunxi_ahub_clk_info *clk_info = &g_clk_info;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	if (reset_control_deassert(clk_info->clk_rst)) {
+		SND_LOG_ERR(HLOG, "clk rst deassert failed\n");
+		return -EINVAL;
+	}
+	if (clk_prepare_enable(clk_info->clk_bus)) {
+		SND_LOG_ERR(HLOG, "clk bus enable failed\n");
+		return -EBUSY;
+	}
+	if (clk_prepare_enable(clk_info->clk_pll)) {
+		SND_LOG_ERR(HLOG, "clk_pll enable failed\n");
+		return -EBUSY;
+	}
+	//if (clk_prepare_enable(clk_info->clk_pllx4)) {
+	//	SND_LOG_ERR(HLOG, "clk_pllx4 enable failed\n");
+	//	return -EBUSY;
+	//}
+	if (clk_prepare_enable(clk_info->clk_module)) {
+		SND_LOG_ERR(HLOG, "clk_module enable failed\n");
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+struct str_conv {
+	char *str;
+	unsigned int reg;
+};
+static struct str_conv ahub_mux_name[] = {
+	{"APBIF0 Src Select",	SUNXI_AHUB_APBIF_RXFIFO_CONT(0)},
+	{"APBIF1 Src Select",	SUNXI_AHUB_APBIF_RXFIFO_CONT(1)},
+	{"APBIF2 Src Select",	SUNXI_AHUB_APBIF_RXFIFO_CONT(2)},
+	{"I2S0 Src Select",	SUNXI_AHUB_I2S_RXCONT(0)},
+	{"I2S1 Src Select",	SUNXI_AHUB_I2S_RXCONT(1)},
+	{"I2S2 Src Select",	SUNXI_AHUB_I2S_RXCONT(2)},
+	{"I2S3 Src Select",	SUNXI_AHUB_I2S_RXCONT(3)},
+	{"DAM0C0 Src Select",	SUNXI_AHUB_DAM_RX0_SRC(0)},
+	{"DAM0C1 Src Select",	SUNXI_AHUB_DAM_RX1_SRC(0)},
+	{"DAM0C2 Src Select",	SUNXI_AHUB_DAM_RX2_SRC(0)},
+	{"DAM1C0 Src Select",	SUNXI_AHUB_DAM_RX0_SRC(1)},
+	{"DAM1C1 Src Select",	SUNXI_AHUB_DAM_RX1_SRC(1)},
+	{"DAM1C2 Src Select",	SUNXI_AHUB_DAM_RX2_SRC(1)},
+};
+static const char *ahub_mux_text[] = {
+	"NONE",
+	"APBIF_TXDIF0",
+	"APBIF_TXDIF1",
+	"APBIF_TXDIF2",
+	"I2S0_TXDIF",
+	"I2S1_TXDIF",
+	"I2S2_TXDIF",
+	"I2S3_TXDIF",
+	"DAM0_TXDIF",
+	"DAM1_TXDIF",
+};
+static const unsigned int ahub_mux_values[] = {
+	0,
+	1 << I2S_RX_APBIF_TXDIF0,
+	1 << I2S_RX_APBIF_TXDIF1,
+	1 << I2S_RX_APBIF_TXDIF2,
+	1 << I2S_RX_I2S0_TXDIF,
+	1 << I2S_RX_I2S1_TXDIF,
+	1 << I2S_RX_I2S2_TXDIF,
+	1 << I2S_RX_I2S3_TXDIF,
+	1 << I2S_RX_DAM0_TXDIF,
+	1 << I2S_RX_DAM1_TXDIF,
+};
+static SOC_ENUM_SINGLE_EXT_DECL(ahub_mux, ahub_mux_text);
+
+static int sunxi_ahub_mux_get(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	int i;
+	unsigned int reg_val;
+	unsigned int src_reg;
+	struct regmap *regmap = g_mem_info.regmap;
+
+	for (i = 0; i < ARRAY_SIZE(ahub_mux_name); i++) {
+		if (!strncmp(ahub_mux_name[i].str, kcontrol->id.name,
+			     strlen(ahub_mux_name[i].str))) {
+			src_reg = ahub_mux_name[i].reg;
+			regmap_read(regmap, src_reg, &reg_val);
+			reg_val &= 0xffffc000;
+			break;
+		}
+	}
+
+	for (i = 1; i < ARRAY_SIZE(ahub_mux_values); i++) {
+		if (reg_val & ahub_mux_values[i]) {
+			ucontrol->value.integer.value[0] = i;
+			return 0;
+		}
+	}
+	ucontrol->value.integer.value[0] = 0;
+
+	return 0;
+}
+
+static int sunxi_ahub_mux_set(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	int i;
+	unsigned int src_reg, src_regbit;
+	struct regmap *regmap = g_mem_info.regmap;
+
+	if (ucontrol->value.integer.value[0] > ARRAY_SIZE(ahub_mux_name))
+		return -EINVAL;
+
+	src_regbit = ahub_mux_values[ucontrol->value.integer.value[0]];
+	for (i = 0; i < ARRAY_SIZE(ahub_mux_name); i++) {
+		if (!strncmp(ahub_mux_name[i].str, kcontrol->id.name,
+			     strlen(ahub_mux_name[i].str))) {
+			src_reg = ahub_mux_name[i].reg;
+			regmap_update_bits(regmap, src_reg, 0xffffc000, src_regbit);
+			break;
+		}
+	}
+
+	return 0;
+}
+
+static const struct snd_kcontrol_new sunxi_ahub_dam_controls[] = {
+	SOC_ENUM_EXT("APBIF0 Src Select", ahub_mux, sunxi_ahub_mux_get, sunxi_ahub_mux_set),
+	SOC_ENUM_EXT("APBIF1 Src Select", ahub_mux, sunxi_ahub_mux_get, sunxi_ahub_mux_set),
+	SOC_ENUM_EXT("APBIF2 Src Select", ahub_mux, sunxi_ahub_mux_get, sunxi_ahub_mux_set),
+	SOC_ENUM_EXT("I2S0 Src Select", ahub_mux, sunxi_ahub_mux_get, sunxi_ahub_mux_set),
+	SOC_ENUM_EXT("I2S1 Src Select", ahub_mux, sunxi_ahub_mux_get, sunxi_ahub_mux_set),
+	SOC_ENUM_EXT("I2S2 Src Select", ahub_mux, sunxi_ahub_mux_get, sunxi_ahub_mux_set),
+	SOC_ENUM_EXT("I2S3 Src Select", ahub_mux, sunxi_ahub_mux_get, sunxi_ahub_mux_set),
+	SOC_ENUM_EXT("DAM0C0 Src Select", ahub_mux, sunxi_ahub_mux_get, sunxi_ahub_mux_set),
+	SOC_ENUM_EXT("DAM0C1 Src Select", ahub_mux, sunxi_ahub_mux_get, sunxi_ahub_mux_set),
+	SOC_ENUM_EXT("DAM0C2 Src Select", ahub_mux, sunxi_ahub_mux_get, sunxi_ahub_mux_set),
+	SOC_ENUM_EXT("DAM1C0 Src Select", ahub_mux, sunxi_ahub_mux_get, sunxi_ahub_mux_set),
+	SOC_ENUM_EXT("DAM1C1 Src Select", ahub_mux, sunxi_ahub_mux_get, sunxi_ahub_mux_set),
+	SOC_ENUM_EXT("DAM1C2 Src Select", ahub_mux, sunxi_ahub_mux_get, sunxi_ahub_mux_set),
+};
+
+static struct snd_soc_component_driver sunxi_ahub_dam_dev = {
+	.name		= DRV_NAME,
+	.probe		= sunxi_ahub_dam_probe,
+	.suspend	= sunxi_ahub_dam_suspend,
+	.resume		= sunxi_ahub_dam_resume,
+	.controls	= sunxi_ahub_dam_controls,
+	.num_controls	= ARRAY_SIZE(sunxi_ahub_dam_controls),
+};
+
+/*******************************************************************************
+ * for kernel source
+ ******************************************************************************/
+int snd_soc_sunxi_ahub_mem_get(struct sunxi_ahub_mem_info *mem_info)
+{
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	if (IS_ERR_OR_NULL(g_mem_info.regmap)) {
+		SND_LOG_ERR(HLOG, "regmap is invalid\n");
+		return -EINVAL;
+	}
+	if (IS_ERR_OR_NULL(g_mem_info.res)) {
+		SND_LOG_ERR(HLOG, "res is invalid\n");
+		return -EINVAL;
+	}
+
+	mem_info->regmap = g_mem_info.regmap;
+	mem_info->res = g_mem_info.res;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_sunxi_ahub_mem_get);
+
+int snd_soc_sunxi_ahub_clk_get(struct sunxi_ahub_clk_info *clk_info)
+{
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	if (IS_ERR_OR_NULL(g_clk_info.clk_pll)) {
+		SND_LOG_ERR(HLOG, "clk_pll is invalid\n");
+		return -EINVAL;
+	}
+	//if (IS_ERR_OR_NULL(g_clk_info.clk_pllx4)) {
+	//	SND_LOG_ERR(HLOG, "clk_pllx4 is invalid\n");
+	//	return -EINVAL;
+	//}
+	if (IS_ERR_OR_NULL(g_clk_info.clk_module)) {
+		SND_LOG_ERR(HLOG, "clk_module is invalid\n");
+		return -EINVAL;
+	}
+
+	clk_info->clk_pll = g_clk_info.clk_pll;
+	//clk_info->clk_pllx4 = g_clk_info.clk_pllx4;
+	clk_info->clk_module = g_clk_info.clk_module;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_sunxi_ahub_clk_get);
+
+static int snd_soc_sunxi_ahub_mem_init(struct platform_device *pdev,
+				       struct device_node *np,
+				       struct sunxi_ahub_mem_info *mem_info)
+{
+	int ret = 0;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	ret = of_address_to_resource(np, 0, mem_info->res);
+	if (ret) {
+		SND_LOG_ERR(HLOG, "parse device node resource failed\n");
+		ret = -EINVAL;
+		goto err_of_addr_to_resource;
+	}
+
+	mem_info->memregion = devm_request_mem_region(&pdev->dev,
+					mem_info->res->start,
+					resource_size(mem_info->res),
+					DRV_NAME);
+	if (IS_ERR_OR_NULL(mem_info->memregion)) {
+		SND_LOG_ERR(HLOG, "memory region already claimed\n");
+		ret = -EBUSY;
+		goto err_devm_request_region;
+	}
+
+	mem_info->membase = devm_ioremap(&pdev->dev,
+					 mem_info->memregion->start,
+					 resource_size(mem_info->memregion));
+	if (IS_ERR_OR_NULL(mem_info->membase)) {
+		SND_LOG_ERR(HLOG, "ioremap failed\n");
+		ret = -EBUSY;
+		goto err_devm_ioremap;
+	}
+
+	mem_info->regmap = devm_regmap_init_mmio(&pdev->dev,
+						 mem_info->membase,
+						 &g_regmap_config);
+	if (IS_ERR_OR_NULL(mem_info->regmap)) {
+		SND_LOG_ERR(HLOG, "regmap init failed\n");
+		ret = -EINVAL;
+		goto err_devm_regmap_init;
+	}
+
+	return 0;
+
+err_devm_regmap_init:
+	devm_iounmap(&pdev->dev, mem_info->membase);
+err_devm_ioremap:
+	devm_release_mem_region(&pdev->dev, mem_info->memregion->start,
+				resource_size(mem_info->memregion));
+err_devm_request_region:
+err_of_addr_to_resource:
+	return ret;
+};
+
+static int snd_soc_sunxi_ahub_clk_init(struct platform_device *pdev,
+				       struct device_node *np,
+				       struct sunxi_ahub_clk_info *clk_info)
+{
+	int ret = 0;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	/* deassert rst clk */
+	clk_info->clk_rst = devm_reset_control_get(&pdev->dev, NULL);
+	if (IS_ERR_OR_NULL(clk_info->clk_rst)) {
+		SND_LOG_ERR(HLOG, "clk rst get failed\n");
+		ret = -EBUSY;
+		goto err_rst_clk;
+	}
+	if (reset_control_deassert(clk_info->clk_rst)) {
+		SND_LOG_ERR(HLOG, "deassert reset clk failed\n");
+		ret = -EBUSY;
+		goto err_rst_clk;
+	}
+
+	/* enable ahub bus clk */
+	clk_info->clk_bus = of_clk_get_by_name(np, "clk_bus_audio_hub");
+	if (IS_ERR_OR_NULL(clk_info->clk_bus)) {
+		SND_LOG_ERR(HLOG, "clk bus get failed\n");
+		ret = -EBUSY;
+		goto err_bus_clk;
+	}
+	if (clk_prepare_enable(clk_info->clk_bus)) {
+		SND_LOG_ERR(HLOG, "ahub clk bus enable failed\n");
+		ret = -EBUSY;
+		goto err_bus_clk;
+	}
+
+	/* get clk of ahub */
+	clk_info->clk_module = of_clk_get_by_name(np, "clk_audio_hub");
+	if (IS_ERR_OR_NULL(clk_info->clk_module)) {
+		SND_LOG_ERR(HLOG, "clk module get failed\n");
+		ret = -EBUSY;
+		goto err_module_clk;
+	}
+	clk_info->clk_pll = of_clk_get_by_name(np, "clk_pll_audio");
+	if (IS_ERR_OR_NULL(clk_info->clk_pll)) {
+		SND_LOG_ERR(HLOG, "clk pll get failed\n");
+		ret = -EBUSY;
+		goto err_pll_clk;
+	}
+	//clk_info->clk_pllx4 = of_clk_get_by_name(np, "clk_pll_audio_4x");
+	//if (IS_ERR_OR_NULL(clk_info->clk_pllx4)) {
+	//	SND_LOG_ERR(HLOG, "clk pllx4 get failed\n");
+	//	ret = -EBUSY;
+	//	goto err_pllx4_clk;
+	//}
+
+	/* set ahub clk parent */
+	//if (clk_set_parent(clk_info->clk_module, clk_info->clk_pllx4)) {
+	//	SND_LOG_ERR(HLOG, "set parent of clk_module to pllx4 failed\n");
+	//	ret = -EINVAL;
+	//	goto err_set_parent_clk;
+	//}
+
+	/* enable clk of ahub */
+	if (clk_prepare_enable(clk_info->clk_pll)) {
+		SND_LOG_ERR(HLOG, "clk_pll enable failed\n");
+		ret = -EBUSY;
+		goto err_pll_clk_enable;
+	}
+	//if (clk_prepare_enable(clk_info->clk_pllx4)) {
+	//	SND_LOG_ERR(HLOG, "clk_pllx4 enable failed\n");
+	//	ret = -EBUSY;
+	//	goto err_pllx4_clk_enable;
+	//}
+	if (clk_prepare_enable(clk_info->clk_module)) {
+		SND_LOG_ERR(HLOG, "clk_module enable failed\n");
+		ret = -EBUSY;
+		goto err_module_clk_enable;
+	}
+
+	return 0;
+
+err_module_clk_enable:
+//	clk_disable_unprepare(clk_info->clk_pllx4);
+//err_pllx4_clk_enable:
+	clk_disable_unprepare(clk_info->clk_pll);
+err_pll_clk_enable:
+//err_set_parent_clk:
+//	clk_put(clk_info->clk_pllx4);
+//err_pllx4_clk:
+//	clk_put(clk_info->clk_pll);
+err_pll_clk:
+	clk_put(clk_info->clk_module);
+err_module_clk:
+	clk_disable_unprepare(clk_info->clk_bus);
+	clk_put(clk_info->clk_bus);
+err_bus_clk:
+	reset_control_assert(clk_info->clk_rst);
+err_rst_clk:
+	return ret;
+}
+
+static int sunxi_ahub_dam_dev_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct device_node *np = pdev->dev.of_node;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	ret = snd_soc_sunxi_ahub_mem_init(pdev, np, &g_mem_info);
+	if (ret) {
+		SND_LOG_ERR(HLOG, "remap init failed\n");
+		ret = -EINVAL;
+		goto err_snd_soc_sunxi_ahub_mem_init;
+	}
+
+	ret = snd_soc_sunxi_ahub_clk_init(pdev, np, &g_clk_info);
+	if (ret) {
+		SND_LOG_ERR(HLOG, "clk init failed\n");
+		ret = -EINVAL;
+		goto err_snd_soc_sunxi_ahub_clk_init;
+	}
+
+	ret = snd_soc_register_component(&pdev->dev,
+					 &sunxi_ahub_dam_dev,
+					 &sunxi_ahub_dam_dai, 1);
+	if (ret) {
+		SND_LOG_ERR(HLOG, "component register failed\n");
+		ret = -ENOMEM;
+		goto err_snd_soc_register_component;
+	}
+
+	SND_LOG_DEBUG(HLOG, "register ahub_dam platform success\n");
+
+	return 0;
+
+err_snd_soc_register_component:
+err_snd_soc_sunxi_ahub_clk_init:
+err_snd_soc_sunxi_ahub_mem_init:
+	of_node_put(np);
+	return ret;
+}
+
+static void sunxi_ahub_dam_dev_remove(struct platform_device *pdev)
+{
+	struct sunxi_ahub_mem_info *mem_info = &g_mem_info;
+	struct sunxi_ahub_clk_info *clk_info = &g_clk_info;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	snd_soc_unregister_component(&pdev->dev);
+
+	devm_iounmap(&pdev->dev, mem_info->membase);
+	devm_release_mem_region(&pdev->dev, mem_info->memregion->start,
+				resource_size(mem_info->memregion));
+
+	clk_disable_unprepare(clk_info->clk_module);
+	clk_put(clk_info->clk_module);
+	clk_disable_unprepare(clk_info->clk_pll);
+	clk_put(clk_info->clk_pll);
+	//clk_disable_unprepare(clk_info->clk_pllx4);
+	//clk_put(clk_info->clk_pllx4);
+	clk_disable_unprepare(clk_info->clk_bus);
+	clk_put(clk_info->clk_bus);
+	reset_control_assert(clk_info->clk_rst);
+
+	SND_LOG_DEBUG(HLOG, "unregister ahub_dam platform success\n");
+}
+
+static const struct of_device_id sunxi_ahub_dam_of_match[] = {
+	{ .compatible = "allwinner," DRV_NAME, },
+	{},
+};
+MODULE_DEVICE_TABLE(of, sunxi_ahub_dam_of_match);
+
+static struct platform_driver sunxi_ahub_dam_driver = {
+	.driver	= {
+		.name		= DRV_NAME,
+		.owner		= THIS_MODULE,
+		.of_match_table	= sunxi_ahub_dam_of_match,
+	},
+	.probe	= sunxi_ahub_dam_dev_probe,
+	.remove	= sunxi_ahub_dam_dev_remove,
+};
+
+int __init sunxi_ahub_dam_dev_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&sunxi_ahub_dam_driver);
+	if (ret != 0) {
+		SND_LOG_ERR(HLOG, "platform driver register failed\n");
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+void __exit sunxi_ahub_dam_dev_exit(void)
+{
+	platform_driver_unregister(&sunxi_ahub_dam_driver);
+}
+
+late_initcall(sunxi_ahub_dam_dev_init);
+module_exit(sunxi_ahub_dam_dev_exit);
+
+MODULE_AUTHOR("Dby@allwinnertech.com");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("sunxi soundcard platform of ahub_dam");
diff --git a/sound/soc/sunxi_v2/snd_sunxi_ahub_dam.h b/sound/soc/sunxi_v2/snd_sunxi_ahub_dam.h
new file mode 100644
index 000000000..b7679bf54
--- /dev/null
+++ b/sound/soc/sunxi_v2/snd_sunxi_ahub_dam.h
@@ -0,0 +1,291 @@
+/* sound\soc\sunxi\snd_sunxi_ahub_dam.h
+ * (C) Copyright 2021-2025
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Dby <dby@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+#ifndef __SND_SUNXI_AHUB_DAM_H
+#define __SND_SUNXI_AHUB_DAM_H
+
+/* SUNXI Audio Hub registers list */
+#define SUNXI_AHUB_CTL				0x00
+#define SUNXI_AHUB_VER				0x04
+#define SUNXI_AHUB_RST				0x08
+#define SUNXI_AHUB_GAT				0x0c
+
+#define SUNXI_AHUB_APBIF_TX_CTL(n)		(0x10 + ((n) * 0x30))
+#define SUNXI_AHUB_APBIF_TX_IRQ_CTL(n)		(0x14 + ((n) * 0x30))
+#define SUNXI_AHUB_APBIF_TX_IRQ_STA(n)		(0x18 + ((n) * 0x30))
+
+#define SUNXI_AHUB_APBIF_TXFIFO_CTL(n)		(0x20 + ((n) * 0x30))
+#define SUNXI_AHUB_APBIF_TXFIFO_STA(n)		(0x24 + ((n) * 0x30))
+
+#define SUNXI_AHUB_APBIF_TXFIFO(n)		(0x30 + ((n) * 0x30))
+#define SUNXI_AHUB_APBIF_TXFIFO_CNT(n)		(0x34 + ((n) * 0x30))
+
+#define SUNXI_AHUB_APBIF_RX_CTL(n)		(0x100 + ((n) * 0x30))
+#define SUNXI_AHUB_APBIF_RX_IRQ_CTL(n)		(0x104 + ((n) * 0x30))
+#define SUNXI_AHUB_APBIF_RX_IRQ_STA(n)		(0x108 + ((n) * 0x30))
+
+#define SUNXI_AHUB_APBIF_RXFIFO_CTL(n)		(0x110 + ((n) * 0x30))
+#define SUNXI_AHUB_APBIF_RXFIFO_STA(n)		(0x114 + ((n) * 0x30))
+#define SUNXI_AHUB_APBIF_RXFIFO_CONT(n)		(0x118 + ((n) * 0x30))
+
+#define SUNXI_AHUB_APBIF_RXFIFO(n)		(0x120 + ((n) * 0x30))
+#define SUNXI_AHUB_APBIF_RXFIFO_CNT(n)		(0x124 + ((n) * 0x30))
+
+#define SUNXI_AHUB_I2S_CTL(n)			(0x200 + ((n) << 8))
+#define SUNXI_AHUB_I2S_FMT0(n)			(0x204 + ((n) << 8))
+#define SUNXI_AHUB_I2S_FMT1(n)			(0x208 + ((n) << 8))
+#define SUNXI_AHUB_I2S_CLKD(n)			(0x20c + ((n) << 8))
+
+#define SUNXI_AHUB_I2S_RXCONT(n)		(0x220 + ((n) << 8))
+#define SUNXI_AHUB_I2S_CHCFG(n)			(0x224 + ((n) << 8))
+#define SUNXI_AHUB_I2S_IRQ_CTL(n)		(0x228 + ((n) << 8))
+#define SUNXI_AHUB_I2S_IRQ_STA(n)		(0x22C + ((n) << 8))
+#define SUNXI_AHUB_I2S_OUT_SLOT(n, m)		(0x230 + ((n) << 8) + ((m) << 4))
+#define SUNXI_AHUB_I2S_OUT_CHMAP0(n, m)		(0x234 + ((n) << 8) + ((m) << 4))
+#define SUNXI_AHUB_I2S_OUT_CHMAP1(n, m)		(0x238 + ((n) << 8) + ((m) << 4))
+
+#define SUNXI_AHUB_I2S_IN_SLOT(n)		(0x270 + ((n) << 8))
+#define SUNXI_AHUB_I2S_IN_CHMAP0(n)		(0x274 + ((n) << 8))
+#define SUNXI_AHUB_I2S_IN_CHMAP1(n)		(0x278 + ((n) << 8))
+#define SUNXI_AHUB_I2S_IN_CHMAP2(n)		(0x27C + ((n) << 8))
+#define SUNXI_AHUB_I2S_IN_CHMAP3(n)		(0x280 + ((n) << 8))
+
+#define SUNXI_AHUB_DAM_CTL(n)			(0xA00 + ((n) << 7))
+
+#define SUNXI_AHUB_DAM_RX0_SRC(n)		(0xA10 + ((n) << 7))
+#define SUNXI_AHUB_DAM_RX1_SRC(n)		(0xA14 + ((n) << 7))
+#define SUNXI_AHUB_DAM_RX2_SRC(n)		(0xA18 + ((n) << 7))
+
+#define SUNXI_AHUB_DAM_MIX_CTL0(n)		(0xA30 + ((n) << 7))
+#define SUNXI_AHUB_DAM_MIX_CTL1(n)		(0xA34 + ((n) << 7))
+#define SUNXI_AHUB_DAM_MIX_CTL2(n)		(0xA38 + ((n) << 7))
+#define SUNXI_AHUB_DAM_MIX_CTL3(n)		(0xA3C + ((n) << 7))
+#define SUNXI_AHUB_DAM_MIX_CTL4(n)		(0xA40 + ((n) << 7))
+#define SUNXI_AHUB_DAM_MIX_CTL5(n)		(0xA44 + ((n) << 7))
+#define SUNXI_AHUB_DAM_MIX_CTL6(n)		(0xA48 + ((n) << 7))
+#define SUNXI_AHUB_DAM_MIX_CTL7(n)		(0xA4C + ((n) << 7))
+#define SUNXI_AHUB_DAM_GAIN_CTL0(n)		(0xA50 + ((n) << 7))
+#define SUNXI_AHUB_DAM_GAIN_CTL1(n)		(0xA54 + ((n) << 7))
+#define SUNXI_AHUB_DAM_GAIN_CTL2(n)		(0xA58 + ((n) << 7))
+#define SUNXI_AHUB_DAM_GAIN_CTL3(n)		(0xA5C + ((n) << 7))
+#define SUNXI_AHUB_DAM_GAIN_CTL4(n)		(0xA60 + ((n) << 7))
+#define SUNXI_AHUB_DAM_GAIN_CTL5(n)		(0xA64 + ((n) << 7))
+#define SUNXI_AHUB_DAM_GAIN_CTL6(n)		(0xA68 + ((n) << 7))
+#define SUNXI_AHUB_DAM_GAIN_CTL7(n)		(0xA6C + ((n) << 7))
+
+#define SUNXI_AHUB_MAX_REG			SUNXI_AHUB_DAM_GAIN_CTL7(1)
+
+/* SUNXI_AHUB_CTL */
+#define HDMI_SRC_SEL			0x04
+
+/* SUNXI_AHUB_RST */
+#define APBIF_TXDIF0_RST		31
+#define APBIF_TXDIF1_RST		30
+#define APBIF_TXDIF2_RST		29
+#define APBIF_RXDIF0_RST		27
+#define APBIF_RXDIF1_RST		26
+#define APBIF_RXDIF2_RST		25
+#define I2S0_RST			23
+#define I2S1_RST			22
+#define I2S2_RST			21
+#define I2S3_RST			20
+#define DAM0_RST			15
+#define DAM1_RST			14
+
+/* SUNXI_AHUB_GAT */
+#define APBIF_TXDIF0_GAT		31
+#define APBIF_TXDIF1_GAT		30
+#define APBIF_TXDIF2_GAT		29
+#define APBIF_RXDIF0_GAT		27
+#define APBIF_RXDIF1_GAT		26
+#define APBIF_RXDIF2_GAT		25
+#define I2S0_GAT			23
+#define I2S1_GAT			22
+#define I2S2_GAT			21
+#define I2S3_GAT			20
+#define DAM0_GAT			15
+#define DAM1_GAT			14
+
+/* SUNXI_AHUB_APBIF_TX_CTL */
+#define APBIF_TX_WS			16
+#define APBIF_TX_CHAN_NUM		8
+#define	APBIF_TX_START			4
+
+/* SUNXI_AHUB_APBIF_TX_IRQ_CTL */
+#define APBIF_TX_DRQ			3
+#define APBIF_TX_OVEN			1
+#define APBIF_TX_EMEN			0
+
+/* SUNXI_AHUB_APBIF_TX_IRQ_STA */
+#define APBIF_TX_OV_PEND		2
+#define APBIF_TX_EM_PEND		0
+
+/* SUNXI_AHUB_APBIF_TXFIFO_CTL */
+#define APBIF_TX_FTX			12
+#define APBIF_TX_LEVEL			4
+#define APBIF_TX_TXIM			0
+
+/* SUNXI_AHUB_APBIF_TXFIFO_STA */
+#define APBIF_TX_EMPTY			8
+#define APBIF_TX_EMCNT			0
+
+/* SUNXI_AHUB_APBIF_RX_CTL */
+#define APBIF_RX_WS			16
+#define APBIF_RX_CHAN_NUM		8
+#define	APBIF_RX_START			4
+
+/* SUNXI_AHUB_APBIF_RX_IRQ_CTL */
+#define APBIF_RX_DRQ			3
+#define APBIF_RX_UVEN			2
+#define APBIF_RX_AVEN			0
+
+/* SUNXI_AHUB_APBIF_RX_IRQ_STA */
+#define APBIF_RX_UV_PEND		2
+#define APBIF_RX_AV_PEND		0
+
+/* SUNXI_AHUB_APBIF_RXFIFO_CTL */
+#define APBIF_RX_FRX			12
+#define APBIF_RX_LEVEL			4
+#define APBIF_RX_RXOM			0
+
+/* SUNXI_AHUB_APBIF_RXFIFO_STA */
+#define APBIF_RX_AVAIL			8
+#define APBIF_RX_AVCNT			0
+
+/* SUNXI_AHUB_APBIF_RXFIFO_CONT */
+#define APBIF_RX_APBIF_TXDIF0		31
+#define APBIF_RX_APBIF_TXDIF1		30
+#define APBIF_RX_APBIF_TXDIF2		29
+#define APBIF_RX_I2S0_TXDIF		27
+#define APBIF_RX_I2S1_TXDIF		26
+#define APBIF_RX_I2S2_TXDIF		25
+#define APBIF_RX_I2S3_TXDIF		23
+#define APBIF_RX_DAM0_TXDIF		19
+#define APBIF_RX_DAM1_TXDIF		15
+
+/* SUNXI_AHUB_I2S_CTL */
+#define I2S_CTL_LOOP3			23
+#define I2S_CTL_LOOP2			22
+#define I2S_CTL_LOOP1			21
+#define I2S_CTL_LOOP0			20
+#define I2S_CTL_SDI3_EN			15
+#define I2S_CTL_SDI2_EN			14
+#define I2S_CTL_SDI1_EN			13
+#define I2S_CTL_SDI0_EN			12
+#define I2S_CTL_CLK_OUT			18
+#define I2S_CTL_SDO3_EN			11
+#define I2S_CTL_SDO2_EN			10
+#define I2S_CTL_SDO1_EN			9
+#define I2S_CTL_SDO0_EN			8
+#define I2S_CTL_OUT_MUTE		6
+#define I2S_CTL_MODE			4
+#define I2S_CTL_TXEN			2
+#define I2S_CTL_RXEN			1
+#define I2S_CTL_GEN			0
+
+/* SUNXI_AHUB_I2S_FMT0 */
+#define I2S_FMT0_LRCK_WIDTH		30
+#define I2S_FMT0_LRCK_POLARITY		19
+#define I2S_FMT0_LRCK_PERIOD		8
+#define I2S_FMT0_BCLK_POLARITY		7
+#define I2S_FMT0_SR			4
+#define I2S_FMT0_EDGE			3
+#define I2S_FMT0_SW			0
+
+/* SUNXI_AHUB_I2S_FMT1 */
+#define I2S_FMT1_RX_LSB			7
+#define I2S_FMT1_TX_LSB			6
+#define I2S_FMT1_EXT			4
+#define I2S_FMT1_RX_PDM			2
+#define I2S_FMT1_TX_PDM			0
+
+/* SUNXI_AHUB_I2S_CLKD */
+#define I2S_CLKD_MCLK			8
+#define	I2S_CLKD_BCLKDIV		4
+#define I2S_CLKD_MCLKDIV		0
+
+/* SUNXI_AHUB_I2S_RXCONT */
+#define I2S_RX_APBIF_TXDIF0		31
+#define I2S_RX_APBIF_TXDIF1		30
+#define I2S_RX_APBIF_TXDIF2		29
+#define I2S_RX_I2S0_TXDIF		27
+#define I2S_RX_I2S1_TXDIF		26
+#define I2S_RX_I2S2_TXDIF		25
+#define I2S_RX_I2S3_TXDIF		23
+#define I2S_RX_DAM0_TXDIF		19
+#define I2S_RX_DAM1_TXDIF		15
+
+/* SUNXI_AHUB_I2S_CHCFG */
+#define I2S_CHCFG_HIZ			9
+#define	I2S_CHCFG_TX_STATE		8
+#define I2S_CHCFG_RX_CHANNUM		4
+#define I2S_CHCFG_TX_CHANNUM		0
+
+/* SUNXI_AHUB_I2S_IRQ_CTL */
+#define I2S_IRQ_RXOV_EN			1
+#define I2S_IRQ_TXUV_EN			0
+
+/* SUNXI_AHUB_I2S_IRQ_STA */
+#define I2S_IRQ_RXOV_PEND		1
+#define I2S_IRQ_TXUV_PEND		0
+
+/* SUNXI_AHUB_I2S_OUT_SLOT */
+#define I2S_OUT_OFFSET			20
+#define I2S_OUT_SLOT_NUM		16
+#define I2S_OUT_SLOT_EN			0
+
+/* SUNXI_AHUB_I2S_IN_SLOT */
+#define I2S_IN_OFFSET			20
+#define I2S_IN_SLOT_NUM			16
+
+/* SUNXI_AHUB_DAM_CTL */
+#define DAM_CTL_RX2_NUM			24
+#define DAM_CTL_RX1_NUM			20
+#define DAM_CTL_RX0_NUM			16
+#define DAM_CTL_TX_NUM			8
+#define DAM_CTL_RX2EN			6
+#define DAM_CTL_RX1EN			5
+#define DAM_CTL_RX0EN			4
+#define DAM_CTL_TXEN			0
+
+/* SUNXI_AHUB_DAM_RX##chan##_SRC */
+#define DAM_RX_APBIF_TXDIF0		31
+#define DAM_RX_APBIF_TXDIF1		30
+#define DAM_RX_APBIF_TXDIF2		29
+#define DAM_RX_I2S0_TXDIF		27
+#define DAM_RX_I2S1_TXDIF		26
+#define DAM_RX_I2S2_TXDIF		25
+#define DAM_RX_I2S3_TXDIF		23
+#define DAM_RX_DAM0_TXDIF		19
+#define DAM_RX_DAM1_TXDIF		15
+
+struct sunxi_ahub_mem_info {
+	char *dev_name;
+	struct resource *res;
+	void __iomem *membase;
+	struct resource *memregion;
+	struct regmap *regmap;
+};
+
+struct sunxi_ahub_clk_info {
+	struct clk *clk_pll;
+	struct clk *clk_pllx4;
+	struct clk *clk_module;
+	struct clk *clk_bus;
+	struct reset_control *clk_rst;
+};
+
+extern int snd_soc_sunxi_ahub_mem_get(struct sunxi_ahub_mem_info *mem_info);
+extern int snd_soc_sunxi_ahub_clk_get(struct sunxi_ahub_clk_info *clk_info);
+
+#endif /* __SND_SUNXI_AHUB_DAM_H */
\ No newline at end of file
diff --git a/sound/soc/sunxi_v2/snd_sunxi_common.c b/sound/soc/sunxi_v2/snd_sunxi_common.c
new file mode 100644
index 000000000..410ab75ae
--- /dev/null
+++ b/sound/soc/sunxi_v2/snd_sunxi_common.c
@@ -0,0 +1,267 @@
+/*
+ * sound\soc\sunxi\snd_sunxi_common.c
+ * (C) Copyright 2021-2025
+ * AllWinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Dby <dby@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/regulator/consumer.h>
+#include <linux/of.h>
+#include <linux/clk.h>
+#include <linux/reset.h>
+#include <linux/device.h>
+#include <linux/ioport.h>
+#include <linux/regmap.h>
+#include <linux/of_address.h>
+#include <linux/of_gpio.h>
+
+#include "snd_sunxi_log.h"
+#include "snd_sunxi_common.h"
+
+#define HLOG		"COMMON"
+
+/* for regmap */
+int snd_sunxi_mem_init(struct platform_device *pdev,
+		       struct sunxi_mem_info *mem_info)
+{
+	int ret = 0;
+	struct device_node *np = pdev->dev.of_node;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	ret = of_address_to_resource(np, 0, mem_info->res);
+	if (ret) {
+		SND_LOG_ERR(HLOG, "parse device node resource failed\n");
+		ret = -EINVAL;
+		goto err_of_addr_to_resource;
+	}
+
+	mem_info->memregion = devm_request_mem_region(&pdev->dev,
+					mem_info->res->start,
+					resource_size(mem_info->res),
+					mem_info->dev_name);
+	if (IS_ERR_OR_NULL(mem_info->memregion)) {
+		SND_LOG_ERR(HLOG, "memory region already claimed\n");
+		ret = -EBUSY;
+		goto err_devm_request_region;
+	}
+
+	mem_info->membase = devm_ioremap(&pdev->dev,
+					 mem_info->memregion->start,
+					 resource_size(mem_info->memregion));
+	if (IS_ERR_OR_NULL(mem_info->membase)) {
+		SND_LOG_ERR(HLOG, "ioremap failed\n");
+		ret = -EBUSY;
+		goto err_devm_ioremap;
+	}
+
+	mem_info->regmap = devm_regmap_init_mmio(&pdev->dev,
+						 mem_info->membase,
+						 mem_info->regmap_config);
+	if (IS_ERR_OR_NULL(mem_info->regmap)) {
+		SND_LOG_ERR(HLOG, "regmap init failed\n");
+		ret = -EINVAL;
+		goto err_devm_regmap_init;
+	}
+
+	return 0;
+
+err_devm_regmap_init:
+	devm_iounmap(&pdev->dev, mem_info->membase);
+err_devm_ioremap:
+	devm_release_mem_region(&pdev->dev, mem_info->memregion->start,
+				resource_size(mem_info->memregion));
+err_devm_request_region:
+err_of_addr_to_resource:
+	return ret;
+}
+
+void snd_sunxi_mem_exit(struct platform_device *pdev,
+			struct sunxi_mem_info *mem_info)
+{
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	devm_iounmap(&pdev->dev, mem_info->membase);
+	devm_release_mem_region(&pdev->dev, mem_info->memregion->start,
+				resource_size(mem_info->memregion));
+}
+
+/* for reg labels */
+int snd_sunxi_save_reg(struct regmap *regmap, struct reg_label *reg_labels)
+{
+	int i = 0;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	while (reg_labels[i].name != NULL) {
+		regmap_read(regmap,
+			    reg_labels[i].address, &(reg_labels[i].value));
+		i++;
+	}
+
+	return i;
+}
+
+int snd_sunxi_echo_reg(struct regmap *regmap, struct reg_label *reg_labels)
+{
+	int i = 0;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	while (reg_labels[i].name != NULL) {
+		regmap_write(regmap,
+			     reg_labels[i].address, reg_labels[i].value);
+		i++;
+	}
+
+	return i;
+}
+
+/* for pa config */
+struct pa_config *snd_sunxi_pa_pin_init(struct platform_device *pdev,
+					u32 *pa_pin_max)
+{
+	int ret, i;
+	u32 pin_max;
+	u32 gpio_tmp;
+	u32 temp_val;
+	char str[20] = {0};
+	struct pa_config *pa_cfg;
+	struct device_node *np = pdev->dev.of_node;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	*pa_pin_max = 0;
+	ret = of_property_read_u32(np, "pa_pin_max", &temp_val);
+	if (ret < 0) {
+		SND_LOG_WARN(HLOG, "pa_pin_max get failed, default 0\n");
+		return NULL;
+	} else {
+		pin_max = temp_val;
+	}
+
+	pa_cfg = kzalloc(sizeof(struct pa_config) * pin_max, GFP_KERNEL);
+	if (!pa_cfg) {
+		SND_LOG_ERR(HLOG, "can't pa_config memory\n");
+		return NULL;
+	}
+
+	for (i = 0; i < pin_max; i++) {
+		sprintf(str, "pa_pin_%d", i);
+		ret = of_get_named_gpio(np, str, 0);
+		if (ret < 0) {
+			SND_LOG_ERR(HLOG, "pa_pin_%u get failed\n", i);
+			pa_cfg[i].used = 0;
+			continue;
+		}
+		gpio_tmp = ret;
+		if (!gpio_is_valid(gpio_tmp)) {
+			SND_LOG_ERR(HLOG, "pa_pin_%u (%u) is invalid\n",
+				    i, gpio_tmp);
+			pa_cfg[i].used = 0;
+			continue;
+		}
+		ret = devm_gpio_request(&pdev->dev, gpio_tmp, str);
+		if (ret) {
+			SND_LOG_ERR(HLOG, "pa_pin_%u (%u) request failed\n",
+				    i, gpio_tmp);
+			pa_cfg[i].used = 0;
+			continue;
+		}
+		pa_cfg[i].used = 1;
+		pa_cfg[i].pin = gpio_tmp;
+
+		sprintf(str, "pa_pin_level_%d", i);
+		ret = of_property_read_u32(np, str, &temp_val);
+		if (ret < 0) {
+			SND_LOG_WARN(HLOG, "%s get failed, default low\n", str);
+			pa_cfg[i].level = 0;
+		} else {
+			if (temp_val > 0)
+				pa_cfg[i].level = 1;
+		}
+		sprintf(str, "pa_pin_msleep_%d", i);
+		ret = of_property_read_u32(np, str, &temp_val);
+		if (ret < 0) {
+			SND_LOG_WARN(HLOG, "%s get failed, default 0\n", str);
+			pa_cfg[i].msleep = 0;
+		} else {
+			pa_cfg[i].msleep = temp_val;
+		}
+	}
+
+	*pa_pin_max = pin_max;
+	snd_sunxi_pa_pin_disable(pa_cfg, pin_max);
+
+	return pa_cfg;
+}
+
+void snd_sunxi_pa_pin_exit(struct platform_device *pdev,
+			   struct pa_config *pa_cfg, u32 pa_pin_max)
+{
+	int i;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	snd_sunxi_pa_pin_disable(pa_cfg, pa_pin_max);
+
+	for (i = 0; i < pa_pin_max; i++) {
+		if (!pa_cfg[i].used)
+			continue;
+
+		gpio_free(pa_cfg[i].pin);
+	}
+
+	if (pa_cfg)
+		kfree(pa_cfg);
+}
+
+int snd_sunxi_pa_pin_enable(struct pa_config *pa_cfg, u32 pa_pin_max)
+{
+	int i;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	if (pa_pin_max < 1) {
+		SND_LOG_DEBUG(HLOG, "no pa pin config\n");
+		return 0;
+	}
+
+	for (i = 0; i < pa_pin_max; i++) {
+		if (!pa_cfg[i].used)
+			continue;
+
+		gpio_direction_output(pa_cfg[i].pin, 1);
+		gpio_set_value(pa_cfg[i].pin, pa_cfg[i].level);
+	}
+
+	return 0;
+}
+
+void snd_sunxi_pa_pin_disable(struct pa_config *pa_cfg, u32 pa_pin_max)
+{
+	int i;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	if (pa_pin_max < 1) {
+		SND_LOG_DEBUG(HLOG, "no pa pin config\n");
+		return;
+	}
+
+	for (i = 0; i < pa_pin_max; i++) {
+		if (!pa_cfg[i].used)
+			continue;
+
+		gpio_direction_output(pa_cfg[i].pin, 1);
+		gpio_set_value(pa_cfg[i].pin, !pa_cfg[i].level);
+	}
+}
diff --git a/sound/soc/sunxi_v2/snd_sunxi_common.h b/sound/soc/sunxi_v2/snd_sunxi_common.h
new file mode 100644
index 000000000..7b88d20c2
--- /dev/null
+++ b/sound/soc/sunxi_v2/snd_sunxi_common.h
@@ -0,0 +1,67 @@
+/* sound\soc\sunxi\snd_sunxi_common.h
+ * (C) Copyright 2021-2025
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Dby <dby@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#ifndef __SND_SUNXI_COMMON_H
+#define __SND_SUNXI_COMMON_H
+
+/* for regmap */
+struct sunxi_mem_info {
+	char *dev_name;
+	struct resource *res;
+	struct regmap_config *regmap_config;
+
+	void __iomem *membase;
+	struct resource *memregion;
+	struct regmap *regmap;
+};
+
+int snd_sunxi_mem_init(struct platform_device *pdev,
+		       struct sunxi_mem_info *mem_info);
+void snd_sunxi_mem_exit(struct platform_device *pdev,
+			struct sunxi_mem_info *mem_info);
+
+/* for reg debug */
+#define REG_LABEL(constant)	{#constant, constant, 0}
+#define REG_LABEL_END		{NULL, 0, 0}
+
+struct reg_label {
+	const char *name;
+	const unsigned int address;
+	unsigned int value;
+};
+
+/* EX:
+ * static struct reg_label reg_labels[] = {
+ * 	REG_LABEL(SUNXI_REG_0),
+ * 	REG_LABEL(SUNXI_REG_1),
+ * 	REG_LABEL(SUNXI_REG_n),
+ * 	REG_LABEL_END,
+ * };
+ */
+int snd_sunxi_save_reg(struct regmap *regmap, struct reg_label *reg_labels);
+int snd_sunxi_echo_reg(struct regmap *regmap, struct reg_label *reg_labels);
+
+/* for pa config */
+struct pa_config {
+	u32 pin;
+	u32 msleep;
+	bool used;
+	bool level;
+};
+
+struct pa_config *snd_sunxi_pa_pin_init(struct platform_device *pdev,
+					u32 *pa_pin_max);
+void snd_sunxi_pa_pin_exit(struct platform_device *pdev,
+			   struct pa_config *pa_cfg, u32 pa_pin_max);
+int snd_sunxi_pa_pin_enable(struct pa_config *pa_cfg, u32 pa_pin_max);
+void snd_sunxi_pa_pin_disable(struct pa_config *pa_cfg, u32 pa_pin_max);
+
+#endif /* __SND_SUNXI_COMMON_H */
\ No newline at end of file
diff --git a/sound/soc/sunxi_v2/snd_sunxi_log.h b/sound/soc/sunxi_v2/snd_sunxi_log.h
new file mode 100644
index 000000000..ee26c2997
--- /dev/null
+++ b/sound/soc/sunxi_v2/snd_sunxi_log.h
@@ -0,0 +1,30 @@
+/*
+ * sound\soc\sunxi\snd_sunxi_log.h
+ * (C) Copyright 2021-2025
+ * allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Dby <dby@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#ifndef __SND_SUNXI_LOG_H
+#define __SND_SUNXI_LOG_H
+#include <linux/kernel.h>
+
+#define SND_LOG_ERR(head, fmt, arg...) \
+	pr_err("[sound %4d][" head " %s] " fmt, __LINE__, __func__, ##arg)
+
+#define SND_LOG_WARN(head, fmt, arg...) \
+	pr_warn("[sound %4d][" head " %s] " fmt, __LINE__, __func__, ##arg)
+
+#define SND_LOG_INFO(head, fmt, arg...) \
+	pr_info("[sound %4d][" head " %s] " fmt, __LINE__, __func__, ##arg)
+
+#define SND_LOG_DEBUG(head, fmt, arg...) \
+	pr_debug("[sound %4d][" head " %s] " fmt, __LINE__, __func__, ##arg)
+
+#endif /* __SND_SUNXI_LOG_H */
+
diff --git a/sound/soc/sunxi_v2/snd_sunxi_mach.c b/sound/soc/sunxi_v2/snd_sunxi_mach.c
new file mode 100644
index 000000000..74d276a2d
--- /dev/null
+++ b/sound/soc/sunxi_v2/snd_sunxi_mach.c
@@ -0,0 +1,479 @@
+/*
+ * sound\soc\sunxi\snd_sunxi_mach.c
+ * (C) Copyright 2021-2025
+ * AllWinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Dby <dby@allwinnertech.com>
+ *
+ * based on ${LINUX}/sound/soc/generic/simple-card.c
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <sound/soc.h>
+
+#include "snd_sunxi_log.h"
+#include "snd_sunxi_mach.h"
+
+#define HLOG		"MACH"
+#define DAI		"sound-dai"
+#define CELL		"#sound-dai-cells"
+#define PREFIX		"soundcard-mach,"
+
+#define DRV_NAME	"sunxi-snd-mach"
+
+static void asoc_simple_shutdown(struct snd_pcm_substream *substream)
+{
+}
+
+static int asoc_simple_startup(struct snd_pcm_substream *substream)
+{
+	return 0;
+}
+
+static int asoc_simple_hw_params(struct snd_pcm_substream *substream,
+				 struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = snd_soc_substream_to_rtd(substream);
+
+	struct snd_soc_dai *codec_dai = snd_soc_rtd_to_codec(rtd, 0);
+	struct snd_soc_dai *cpu_dai = snd_soc_rtd_to_cpu(rtd, 0);
+
+	struct asoc_simple_priv *priv = snd_soc_card_get_drvdata(rtd->card);
+	struct snd_soc_dai_link *dai_link = simple_priv_to_link(priv, rtd->id);
+	struct simple_dai_props *dai_props = simple_priv_to_props(priv, rtd->id);
+	struct asoc_simple_dai *dais = priv->dais;
+	unsigned int mclk;
+	unsigned int cpu_pll_clk, codec_pll_clk;
+	unsigned int cpu_bclk_ratio, codec_bclk_ratio;
+	unsigned int freq_point;
+	int cpu_clk_div, codec_clk_div;
+	int ret = 0;
+
+	switch (params_rate(params)) {
+	case 8000:
+	case 12000:
+	case 16000:
+	case 24000:
+	case 32000:
+	case 48000:
+	case 64000:
+	case 96000:
+	case 192000:
+		freq_point = 24576000;
+		break;
+	case 11025:
+	case 22050:
+	case 44100:
+	case 88200:
+	case 176400:
+		freq_point = 22579200;
+		break;
+	default:
+		SND_LOG_ERR(HLOG, "Invalid rate %d\n", params_rate(params));
+		return -EINVAL;
+	}
+
+	/* for cpudai pll clk */
+	cpu_pll_clk	= freq_point * dai_props->cpu_pll_fs;
+	codec_pll_clk	= freq_point * dai_props->codec_pll_fs;
+	cpu_clk_div	= cpu_pll_clk / params_rate(params);
+	codec_clk_div	= codec_pll_clk / params_rate(params);
+	SND_LOG_DEBUG(HLOG, "freq point   : %u\n", freq_point);
+	SND_LOG_DEBUG(HLOG, "cpu pllclk   : %u\n", cpu_pll_clk);
+	SND_LOG_DEBUG(HLOG, "codec pllclk : %u\n", codec_pll_clk);
+	SND_LOG_DEBUG(HLOG, "cpu clk_div  : %u\n", cpu_clk_div);
+	SND_LOG_DEBUG(HLOG, "codec clk_div: %u\n", codec_clk_div);
+
+	if (cpu_dai->driver->ops->set_pll) {
+		ret = snd_soc_dai_set_pll(cpu_dai, substream->stream, 0,
+					  cpu_pll_clk, cpu_pll_clk);
+		if (ret) {
+			SND_LOG_ERR(HLOG, "cpu_dai set pllclk failed\n");
+			return ret;
+		}
+	}
+	if (codec_dai->driver->ops->set_pll) {
+		ret = snd_soc_dai_set_pll(codec_dai, substream->stream, 0,
+					  codec_pll_clk, codec_pll_clk);
+		if (ret) {
+			SND_LOG_ERR(HLOG, "codec_dai set pllclk failed\n");
+			return ret;
+		}
+	}
+
+	if (cpu_dai->driver->ops->set_clkdiv) {
+		ret = snd_soc_dai_set_clkdiv(cpu_dai, 0, cpu_clk_div);
+		if (ret) {
+			SND_LOG_ERR(HLOG, "cpu_dai set clk_div failed\n");
+			return ret;
+		}
+	}
+	if (codec_dai->driver->ops->set_clkdiv) {
+		ret = snd_soc_dai_set_clkdiv(codec_dai, 0, codec_clk_div);
+		if (ret) {
+			SND_LOG_ERR(HLOG, "cadec_dai set clk_div failed.\n");
+			return ret;
+		}
+	}
+
+	/* use for tdm only */
+	if (!(dais->slots && dais->slot_width))
+		return 0;
+
+	/* for cpudai & codecdai mclk */
+	if (dai_props->mclk_fp)
+		mclk = (freq_point >> 1) * dai_props->mclk_fs;
+	else
+		mclk = params_rate(params) * dai_props->mclk_fs;
+	cpu_bclk_ratio = cpu_pll_clk / (params_rate(params) * dais->slot_width * dais->slots);
+	codec_bclk_ratio = codec_pll_clk / (params_rate(params) * dais->slot_width * dais->slots);
+	SND_LOG_DEBUG(HLOG, "mclk            : %u\n", mclk);
+	SND_LOG_DEBUG(HLOG, "cpu_bclk_ratio  : %u\n", cpu_bclk_ratio);
+	SND_LOG_DEBUG(HLOG, "codec_bclk_ratio: %u\n", codec_bclk_ratio);
+
+	if (cpu_dai->driver->ops->set_sysclk) {
+		ret = snd_soc_dai_set_sysclk(cpu_dai, 0, mclk, SND_SOC_CLOCK_OUT);
+		if (ret) {
+			SND_LOG_ERR(HLOG, "cpu_dai set sysclk(mclk) failed\n");
+			return ret;
+		}
+	}
+	if (codec_dai->driver->ops->set_sysclk) {
+		ret = snd_soc_dai_set_sysclk(codec_dai, 0, mclk, SND_SOC_CLOCK_IN);
+		if (ret) {
+			SND_LOG_ERR(HLOG, "cadec_dai set sysclk(mclk) failed\n");
+			return ret;
+		}
+	}
+
+	if (cpu_dai->driver->ops->set_bclk_ratio) {
+		ret = snd_soc_dai_set_bclk_ratio(cpu_dai, cpu_bclk_ratio);
+		if (ret) {
+			SND_LOG_ERR(HLOG, "cpu_dai set bclk failed\n");
+			return ret;
+		}
+	}
+	if (codec_dai->driver->ops->set_bclk_ratio) {
+		ret = snd_soc_dai_set_bclk_ratio(codec_dai, codec_bclk_ratio);
+		if (ret) {
+			SND_LOG_ERR(HLOG, "codec_dai set bclk failed\n");
+			return ret;
+		}
+	}
+
+	if (cpu_dai->driver->ops->set_fmt) {
+		ret = snd_soc_dai_set_fmt(cpu_dai, dai_link->dai_fmt);
+		if (ret) {
+			SND_LOG_ERR(HLOG, "cpu dai set fmt failed\n");
+			return ret;
+		}
+	}
+	if (codec_dai->driver->ops->set_fmt) {
+		ret = snd_soc_dai_set_fmt(codec_dai, dai_link->dai_fmt);
+		if (ret) {
+			SND_LOG_ERR(HLOG, "codec dai set fmt failed\n");
+			return ret;
+		}
+	}
+
+	if (cpu_dai->driver->ops->set_tdm_slot) {
+		ret = snd_soc_dai_set_tdm_slot(cpu_dai, 0, 0, dais->slots, dais->slot_width);
+		if (ret) {
+			SND_LOG_ERR(HLOG, "cpu dai set tdm slot failed\n");
+			return ret;
+		}
+	}
+	if (codec_dai->driver->ops->set_tdm_slot) {
+		ret = snd_soc_dai_set_tdm_slot(codec_dai, 0, 0, dais->slots, dais->slot_width);
+		if (ret) {
+			SND_LOG_ERR(HLOG, "codec dai set tdm slot failed\n");
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static struct snd_soc_ops simple_ops = {
+	.startup = asoc_simple_startup,
+	.shutdown = asoc_simple_shutdown,
+	.hw_params = asoc_simple_hw_params,
+};
+
+static int asoc_simple_dai_init(struct snd_soc_pcm_runtime *rtd)
+{
+	int i;
+	struct snd_soc_card *card = rtd->card;
+	struct snd_soc_dapm_context *dapm = &card->dapm;
+
+	const struct snd_kcontrol_new *controls = card->controls;
+
+	for (i = 0; i < card->num_controls; i++)
+		if (controls[i].info == snd_soc_dapm_info_pin_switch)
+			snd_soc_dapm_disable_pin(dapm,
+				(const char *)controls[i].private_value);
+
+	if (card->num_controls)
+		snd_soc_dapm_sync(dapm);
+
+	/* snd_soc_dai_set_sysclk(); */
+	/* snd_soc_dai_set_tdm_slot(); */
+
+	return 0;
+}
+
+static int simple_dai_link_of(struct device_node *node,
+			      struct asoc_simple_priv *priv)
+{
+	struct device *dev = simple_priv_to_dev(priv);
+	struct snd_soc_dai_link *dai_link = simple_priv_to_link(priv, 0);
+	struct simple_dai_props *dai_props = simple_priv_to_props(priv, 0);
+	struct device_node *top_np = NULL;
+	struct device_node *cpu = NULL;
+	struct device_node *plat = NULL;
+	struct device_node *codec = NULL;
+	char prop[128];
+	char *prefix = "";
+	int ret, single_cpu;
+
+	prefix = PREFIX;
+	top_np = node;
+
+	snprintf(prop, sizeof(prop), "%scpu", prefix);
+	cpu = of_get_child_by_name(top_np, prop);
+	if (!cpu) {
+		ret = -EINVAL;
+		SND_LOG_ERR(HLOG, "Can't find %s DT node\n", prop);
+		goto dai_link_of_err;
+	}
+	snprintf(prop, sizeof(prop), "%splat", prefix);
+	plat = of_get_child_by_name(top_np, prop);
+
+	snprintf(prop, sizeof(prop), "%scodec", prefix);
+	codec = of_get_child_by_name(top_np, prop);
+	if (!codec) {
+		ret = -EINVAL;
+		SND_LOG_ERR(HLOG, "Can't find %s DT node\n", prop);
+		goto dai_link_of_err;
+	}
+
+	ret = asoc_simple_parse_daifmt(top_np, codec, prefix, &dai_link->dai_fmt);
+	if (ret < 0)
+		goto dai_link_of_err;
+	/* sunxi: parse stream direction
+	 * ex1)
+	 * top_node {
+	 *	PREFIXplayback-only;
+	 * }
+	 * ex2)
+	 * top_node {
+	 *	PREFIXcapture-only;
+	 * }
+	 */
+	ret = asoc_simple_parse_daistream(top_np, prefix, dai_link);
+	if (ret < 0)
+		goto dai_link_of_err;
+	/* sunxi: parse slot-num & slot-width
+	 * ex)
+	 * top_node {
+	 *	PREFIXplayslot-num	= <x>;
+	 *	PREFIXplayslot-width	= <x>;
+	 * }
+	 */
+	ret = asoc_simple_parse_tdm_slot(top_np, prefix, priv->dais);
+	if (ret < 0)
+		goto dai_link_of_err;
+
+	ret = asoc_simple_parse_cpu(cpu, dai_link, DAI, CELL, &single_cpu);
+	if (ret < 0)
+		goto dai_link_of_err;
+	ret = asoc_simple_parse_codec(codec, dai_link, DAI, CELL);
+	if (ret < 0) {
+		if (ret == -EPROBE_DEFER)
+			goto dai_link_of_err;
+		dai_link->codecs->name = "snd-soc-dummy";
+		dai_link->codecs->dai_name = "snd-soc-dummy-dai";
+		/* dai_link->codecs->name = "sunxi-dummy-codec"; */
+		/* dai_link->codecs->dai_name = "sunxi-dummy-codec-dai"; */
+		SND_LOG_DEBUG(HLOG, "use dummy codec for simple card.\n");
+	}
+	ret = asoc_simple_parse_platform(plat, dai_link, DAI, CELL);
+	if (ret < 0)
+		goto dai_link_of_err;
+
+	/* sunxi: parse pll-fs & mclk-fs
+	 * ex)
+	 * top_node {
+	 *	PREFIXcpu {
+	 *		PREFIXpll-fs	= <x>;
+	 *		PREFIXmclk-fs	= <x>;
+	 *	}
+	 * }
+	 */
+	ret = asoc_simple_parse_tdm_clk(cpu, codec, prefix, dai_props);
+	if (ret < 0)
+		goto dai_link_of_err;
+
+	ret = asoc_simple_set_dailink_name(dev, dai_link,
+					   "%s-%s",
+					   dai_link->cpus->dai_name,
+					   dai_link->codecs->dai_name);
+	if (ret < 0)
+		goto dai_link_of_err;
+
+	dai_link->ops = &simple_ops;
+	dai_link->init = asoc_simple_dai_init;
+
+	SND_LOG_DEBUG(HLOG, "name   : %s\n", dai_link->stream_name);
+	SND_LOG_DEBUG(HLOG, "format : %x\n", dai_link->dai_fmt);
+	SND_LOG_DEBUG(HLOG, "cpu    : %s\n", dai_link->cpus->name);
+	SND_LOG_DEBUG(HLOG, "codec  : %s\n", dai_link->codecs->name);
+
+	asoc_simple_canonicalize_cpu(dai_link, single_cpu);
+	asoc_simple_canonicalize_platform(dai_link);
+
+dai_link_of_err:
+	of_node_put(cpu);
+	of_node_put(plat);
+	of_node_put(codec);
+
+	return ret;
+}
+
+static int simple_parse_of(struct asoc_simple_priv *priv)
+{
+	int ret;
+	struct device *dev = simple_priv_to_dev(priv);
+	struct snd_soc_card *card = simple_priv_to_card(priv);
+	struct device_node *top_np = dev->of_node;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	if (!top_np)
+		return -EINVAL;
+
+	/* DAPM widgets */
+	ret = asoc_simple_parse_widgets(card, PREFIX);
+	if (ret < 0)
+		return ret;
+
+	/* DAPM routes */
+	ret = asoc_simple_parse_routing(card, PREFIX);
+	if (ret < 0)
+		return ret;
+
+	/* DAPM pin_switches */
+	ret = asoc_simple_parse_pin_switches(card, PREFIX);
+	if (ret < 0)
+		return ret;
+
+	/* For single DAI link & old style of DT node */
+	ret = simple_dai_link_of(top_np, priv);
+	if (ret < 0)
+		return ret;
+
+	ret = asoc_simple_parse_card_name(card, PREFIX);
+	return ret;
+}
+
+static int simple_soc_probe(struct snd_soc_card *card)
+{
+	return 0;
+}
+
+static int asoc_simple_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *top_np = dev->of_node;
+	struct asoc_simple_priv *priv;
+	struct snd_soc_card *card;
+	int ret;
+
+	/* Allocate the private data and the DAI link array */
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	card = simple_priv_to_card(priv);
+	card->owner		= THIS_MODULE;
+	card->dev		= dev;
+	card->probe		= simple_soc_probe;
+
+	ret = asoc_simple_init_priv(priv);
+	if (ret < 0)
+		return ret;
+
+	if (top_np && of_device_is_available(top_np)) {
+		ret = simple_parse_of(priv);
+		if (ret < 0) {
+			if (ret != -EPROBE_DEFER)
+				SND_LOG_ERR(HLOG, "parse error %d\n", ret);
+			goto err;
+		}
+	} else {
+		SND_LOG_ERR(HLOG, "simple card dts available\n");
+	}
+
+	snd_soc_card_set_drvdata(card, priv);
+
+	/* asoc_simple_debug_info(priv); */
+	ret = devm_snd_soc_register_card(dev, card);
+	if (ret >= 0)
+		return ret;
+err:
+	asoc_simple_clean_reference(card);
+
+	return ret;
+}
+
+static void asoc_simple_remove(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
+
+	asoc_simple_clean_reference(card);
+}
+
+static const struct of_device_id snd_soc_sunxi_of_match[] = {
+	{ .compatible = "allwinner," DRV_NAME, },
+	{},
+};
+MODULE_DEVICE_TABLE(of, snd_soc_sunxi_of_match);
+
+static struct platform_driver sunxi_soundcard_machine_driver = {
+	.driver	= {
+		.name		= DRV_NAME,
+		.pm		= &snd_soc_pm_ops,
+		.of_match_table	= snd_soc_sunxi_of_match,
+	},
+	.probe	= asoc_simple_probe,
+	.remove	= asoc_simple_remove,
+};
+
+int __init sunxi_soundcard_machine_dev_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&sunxi_soundcard_machine_driver);
+	if (ret != 0) {
+		SND_LOG_ERR(HLOG, "platform driver register failed\n");
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+void __exit sunxi_soundcard_machine_dev_exit(void)
+{
+	platform_driver_unregister(&sunxi_soundcard_machine_driver);
+}
+
+late_initcall(sunxi_soundcard_machine_dev_init);
+module_exit(sunxi_soundcard_machine_dev_exit);
+
+MODULE_AUTHOR("Dby@allwinnertech.com");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("sunxi soundcard machine");
diff --git a/sound/soc/sunxi_v2/snd_sunxi_mach.h b/sound/soc/sunxi_v2/snd_sunxi_mach.h
new file mode 100644
index 000000000..ab429c884
--- /dev/null
+++ b/sound/soc/sunxi_v2/snd_sunxi_mach.h
@@ -0,0 +1,17 @@
+/* sound\soc\sunxi\snd_sunxi_mach.h
+ * (C) Copyright 2021-2025
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Dby <dby@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#ifndef __SND_SUNXI_MACH_H
+#define __SND_SUNXI_MACH_H
+
+#include "snd_sunxi_mach_utils.h"
+
+#endif /* __SND_SUNXI_MACH_H */
diff --git a/sound/soc/sunxi_v2/snd_sunxi_mach_utils.c b/sound/soc/sunxi_v2/snd_sunxi_mach_utils.c
new file mode 100644
index 000000000..820c72eb6
--- /dev/null
+++ b/sound/soc/sunxi_v2/snd_sunxi_mach_utils.c
@@ -0,0 +1,422 @@
+/*
+ * sound\soc\sunxi\snd_sunxi_mach_utils.c
+ * (C) Copyright 2021-2025
+ * AllWinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Dby <dby@allwinnertech.com>
+ *
+ * based on ${LINUX}/sound/soc/generic/simple-card.c
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/of.h>
+#include <sound/soc.h>
+
+#include "snd_sunxi_log.h"
+#include "snd_sunxi_mach_utils.h"
+
+#define HLOG		"mach_utils"
+
+int asoc_simple_clean_reference(struct snd_soc_card *card)
+{
+	struct snd_soc_dai_link *dai_link;
+	int i;
+
+	for_each_card_prelinks(card, i, dai_link) {
+		of_node_put(dai_link->cpus->of_node);
+		of_node_put(dai_link->codecs->of_node);
+	}
+	return 0;
+}
+
+int asoc_simple_init_priv(struct asoc_simple_priv *priv)
+{
+	struct snd_soc_card *card = simple_priv_to_card(priv);
+	struct device *dev = simple_priv_to_dev(priv);
+	struct snd_soc_dai_link *dai_link;
+	struct simple_dai_props *dai_props;
+	struct asoc_simple_dai *dais;
+	struct snd_soc_codec_conf *cconf = NULL;
+
+	dai_props = devm_kcalloc(dev, 1, sizeof(*dai_props), GFP_KERNEL);
+	dai_link  = devm_kcalloc(dev, 1, sizeof(*dai_link),  GFP_KERNEL);
+	dais      = devm_kcalloc(dev, 1, sizeof(*dais),      GFP_KERNEL);
+	if (!dai_props || !dai_link || !dais)
+		return -ENOMEM;
+
+	/*
+	if (li->conf) {
+		cconf = devm_kcalloc(dev, li->conf, sizeof(*cconf), GFP_KERNEL);
+		if (!cconf)
+			return -ENOMEM;
+	}
+	*/
+
+	/*
+	 * Use snd_soc_dai_link_component instead of legacy style
+	 * It is codec only. but cpu/platform will be supported in the future.
+	 * see
+	 *	soc-core.c :: snd_soc_init_multicodec()
+	 *
+	 * "platform" might be removed
+	 * see
+	 *	simple-card-utils.c :: asoc_simple_canonicalize_platform()
+	 */
+	dai_link->cpus		= &dai_props->cpus;
+	dai_link->num_cpus	= 1;
+	dai_link->codecs	= &dai_props->codecs;
+	dai_link->num_codecs	= 1;
+	dai_link->platforms	= &dai_props->platforms;
+	dai_link->num_platforms	= 1;
+
+	priv->dai_props		= dai_props;
+	priv->dai_link		= dai_link;
+	priv->dais		= dais;
+	priv->codec_conf	= cconf;
+
+	card->dai_link		= priv->dai_link;
+	card->num_links		= 1;
+	card->codec_conf	= cconf;
+	card->num_configs	= 0;
+
+	return 0;
+}
+
+int asoc_simple_parse_widgets(struct snd_soc_card *card, char *prefix)
+{
+	struct device_node *node = card->dev->of_node;
+	char prop[128];
+
+	if (!prefix)
+		prefix = "";
+
+	snprintf(prop, sizeof(prop), "%s%s", prefix, "widgets");
+
+	if (of_property_read_bool(node, prop))
+		return snd_soc_of_parse_audio_simple_widgets(card, prop);
+
+	/* no widgets is not error */
+	return 0;
+}
+
+int asoc_simple_parse_routing(struct snd_soc_card *card, char *prefix)
+{
+	struct device_node *node = card->dev->of_node;
+	char prop[128];
+
+	if (!prefix)
+		prefix = "";
+
+	snprintf(prop, sizeof(prop), "%s%s", prefix, "routing");
+
+	if (!of_property_read_bool(node, prop))
+		return 0;
+
+	return snd_soc_of_parse_audio_routing(card, prop);
+}
+
+int asoc_simple_parse_pin_switches(struct snd_soc_card *card, char *prefix)
+{
+	const unsigned int nb_controls_max = 16;
+	const char **strings, *control_name;
+	struct snd_kcontrol_new *controls;
+	struct device *dev = card->dev;
+	unsigned int i, nb_controls;
+	char prop[128];
+	int ret;
+
+	if (!prefix)
+		prefix = "";
+
+	snprintf(prop, sizeof(prop), "%s%s", prefix, "pin-switches");
+
+	if (!of_property_read_bool(dev->of_node, prop))
+		return 0;
+
+	strings = devm_kcalloc(dev, nb_controls_max,
+			       sizeof(*strings), GFP_KERNEL);
+	if (!strings)
+		return -ENOMEM;
+
+	ret = of_property_read_string_array(dev->of_node, prop,
+					    strings, nb_controls_max);
+	if (ret < 0)
+		return ret;
+
+	nb_controls = (unsigned int)ret;
+
+	controls = devm_kcalloc(dev, nb_controls,
+				sizeof(*controls), GFP_KERNEL);
+	if (!controls)
+		return -ENOMEM;
+
+	for (i = 0; i < nb_controls; i++) {
+		control_name = devm_kasprintf(dev, GFP_KERNEL,
+					      "%s Switch", strings[i]);
+		if (!control_name)
+			return -ENOMEM;
+
+		controls[i].iface = SNDRV_CTL_ELEM_IFACE_MIXER;
+		controls[i].name = control_name;
+		controls[i].info = snd_soc_dapm_info_pin_switch;
+		controls[i].get = snd_soc_dapm_get_pin_switch;
+		controls[i].put = snd_soc_dapm_put_pin_switch;
+		controls[i].private_value = (unsigned long)strings[i];
+	}
+
+	card->controls = controls;
+	card->num_controls = nb_controls;
+
+	return 0;
+}
+
+int asoc_simple_parse_daifmt(struct device_node *node,
+			     struct device_node *codec,
+			     char *prefix,
+			     unsigned int *retfmt)
+{
+	struct device_node *bitclkmaster = NULL;
+	struct device_node *framemaster = NULL;
+	unsigned int daifmt;
+
+	daifmt = snd_soc_daifmt_parse_format(node, prefix);
+
+	snd_soc_daifmt_parse_clock_provider_as_phandle(node, prefix, &bitclkmaster, &framemaster);
+	if (!bitclkmaster && !framemaster) {
+		/*
+		 * No dai-link level and master setting was not found from
+		 * sound node level, revert back to legacy DT parsing and
+		 * take the settings from codec node.
+		 */
+		SND_LOG_DEBUG(HLOG, "Revert to legacy daifmt parsing\n");
+
+		daifmt |= snd_soc_daifmt_parse_clock_provider_as_flag(codec, NULL);
+	} else {
+		daifmt |= snd_soc_daifmt_clock_provider_from_bitmap(
+	                ((codec == bitclkmaster) << 4) | (codec == framemaster));
+	}
+
+	of_node_put(bitclkmaster);
+	of_node_put(framemaster);
+
+	*retfmt = daifmt;
+
+	return 0;
+}
+
+int asoc_simple_parse_daistream(struct device_node *node, char *prefix,
+				struct snd_soc_dai_link *dai_link)
+{
+	char prop[128];
+
+	if (!prefix)
+		prefix = "";
+
+	/* check "[prefix]playback-only" */
+	snprintf(prop, sizeof(prop), "%splayback-only", prefix);
+	if (of_property_read_bool(node, prop))
+		dai_link->playback_only = 1;
+
+	/* check "[prefix]capture-only" */
+	snprintf(prop, sizeof(prop), "%scapture-only", prefix);
+	if (of_property_read_bool(node, prop))
+		dai_link->capture_only = 1;
+
+	return 0;
+}
+
+int asoc_simple_parse_tdm_slot(struct device_node *node, char *prefix,
+			       struct asoc_simple_dai *dais)
+{
+	int ret;
+	char prop[128];
+	unsigned int val;
+
+	if (!prefix)
+		prefix = "";
+
+	snprintf(prop, sizeof(prop), "%sslot-num", prefix);
+	ret = of_property_read_u32(node, prop, &val);
+	if (!ret)
+		dais->slots = val;
+
+	snprintf(prop, sizeof(prop), "%sslot-width", prefix);
+	ret = of_property_read_u32(node, prop, &val);
+	if (!ret)
+		dais->slot_width = val;
+
+	return 0;
+}
+
+int asoc_simple_parse_tdm_clk(struct device_node *cpu,
+			      struct device_node *codec,
+			      char *prefix,
+			      struct simple_dai_props *dai_props)
+{
+	int ret;
+	char prop[128];
+	unsigned int val;
+
+	if (!prefix)
+		prefix = "";
+
+	snprintf(prop, sizeof(prop), "%spll-fs", prefix);
+	ret = of_property_read_u32(cpu, prop, &val);
+	if (ret)
+		dai_props->cpu_pll_fs = 1;	/* default sysclk 24.576 or 22.5792MHz * 1 */
+	else
+		dai_props->cpu_pll_fs = val;
+
+	ret = of_property_read_u32(codec, prop, &val);
+	if (ret)
+		dai_props->codec_pll_fs = 1;	/* default sysclk 24.576 or 22.5792MHz * 1 */
+	else
+		dai_props->codec_pll_fs = val;
+
+	snprintf(prop, sizeof(prop), "%smclk-fp", prefix);
+	dai_props->mclk_fp = of_property_read_bool(cpu, prop);
+
+	snprintf(prop, sizeof(prop), "%smclk-fs", prefix);
+	ret = of_property_read_u32(cpu, prop, &val);
+	if (ret)
+		dai_props->mclk_fs = 0;		/* default mclk 0Hz(un output) */
+	else
+		dai_props->mclk_fs = val;
+
+	return 0;
+}
+
+int asoc_simple_parse_card_name(struct snd_soc_card *card,
+				char *prefix)
+{
+	int ret;
+
+	if (!prefix)
+		prefix = "";
+
+	/* Parse the card name from DT */
+	ret = snd_soc_of_parse_card_name(card, "label");
+	if (ret < 0 || !card->name) {
+		char prop[128];
+
+		snprintf(prop, sizeof(prop), "%sname", prefix);
+		ret = snd_soc_of_parse_card_name(card, prop);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (!card->name && card->dai_link)
+		card->name = card->dai_link->name;
+
+	return 0;
+}
+
+int asoc_simple_parse_dai(struct device_node *node,
+			  struct snd_soc_dai_link_component *dlc,
+			  const char *list_name, const char *cells_name,
+			  int *is_single_link)
+{
+	struct of_phandle_args args;
+	int ret;
+
+	if (!node)
+		return 0;
+
+	/*
+	 * Get node via "sound-dai = <&phandle port>"
+	 * it will be used as xxx_of_node on soc_bind_dai_link()
+	 */
+	ret = of_parse_phandle_with_args(node, list_name, cells_name, 0, &args);
+	if (ret)
+		return ret;
+
+	/*
+	 * FIXME
+	 *
+	 * Here, dlc->dai_name is pointer to CPU/Codec DAI name.
+	 * If user unbinded CPU or Codec driver, but not for Sound Card,
+	 * dlc->dai_name is keeping unbinded CPU or Codec
+	 * driver's pointer.
+	 *
+	 * If user re-bind CPU or Codec driver again, ALSA SoC will try
+	 * to rebind Card via snd_soc_try_rebind_card(), but because of
+	 * above reason, it might can't bind Sound Card.
+	 * Because Sound Card is pointing to released dai_name pointer.
+	 *
+	 * To avoid this rebind Card issue,
+	 * 1) It needs to alloc memory to keep dai_name eventhough
+	 *    CPU or Codec driver was unbinded, or
+	 * 2) user need to rebind Sound Card everytime
+	 *    if he unbinded CPU or Codec.
+	 */
+	ret = snd_soc_of_get_dai_name(node, &dlc->dai_name, 0);
+	if (ret < 0)
+		return ret;
+
+	dlc->of_node = args.np;
+
+	if (is_single_link)
+		*is_single_link = !args.args_count;
+
+	return 0;
+}
+
+int asoc_simple_set_dailink_name(struct device *dev,
+				 struct snd_soc_dai_link *dai_link,
+				 const char *fmt, ...)
+{
+	va_list ap;
+	char *name = NULL;
+	int ret = -ENOMEM;
+
+	va_start(ap, fmt);
+	name = devm_kvasprintf(dev, GFP_KERNEL, fmt, ap);
+	va_end(ap);
+
+	if (name) {
+		ret = 0;
+
+		dai_link->name		= name;
+		dai_link->stream_name	= name;
+	}
+
+	return ret;
+}
+
+void asoc_simple_canonicalize_platform(struct snd_soc_dai_link *dai_link)
+{
+	/* Assumes platform == cpu */
+	if (!dai_link->platforms->of_node)
+		dai_link->platforms->of_node = dai_link->cpus->of_node;
+
+	/*
+	 * DPCM BE can be no platform.
+	 * Alloced memory will be waste, but not leak.
+	 */
+	if (!dai_link->platforms->of_node)
+		dai_link->num_platforms = 0;
+}
+
+void asoc_simple_canonicalize_cpu(struct snd_soc_dai_link *dai_link,
+				  int is_single_links)
+{
+	/*
+	 * In soc_bind_dai_link() will check cpu name after
+	 * of_node matching if dai_link has cpu_dai_name.
+	 * but, it will never match if name was created by
+	 * fmt_single_name() remove cpu_dai_name if cpu_args
+	 * was 0. See:
+	 *	fmt_single_name()
+	 *	fmt_multiple_name()
+	 */
+	if (is_single_links)
+		dai_link->cpus->dai_name = NULL;
+}
+
+MODULE_AUTHOR("Dby@allwinnertech.com");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("sunxi soundcard machine utils");
diff --git a/sound/soc/sunxi_v2/snd_sunxi_mach_utils.h b/sound/soc/sunxi_v2/snd_sunxi_mach_utils.h
new file mode 100644
index 000000000..6a9ec18b4
--- /dev/null
+++ b/sound/soc/sunxi_v2/snd_sunxi_mach_utils.h
@@ -0,0 +1,116 @@
+/* sound\soc\sunxi\snd_sunxi_mach_utils.h
+ * (C) Copyright 2021-2025
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Dby <dby@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#ifndef __SND_SUNXI_MACH_UTILS_H
+#define __SND_SUNXI_MACH_UTILS_H
+
+#define simple_priv_to_card(priv)	(&(priv)->snd_card)
+#define simple_priv_to_props(priv, i)	((priv)->dai_props + (i))
+#define simple_priv_to_dev(priv)	(simple_priv_to_card(priv)->dev)
+#define simple_priv_to_link(priv, i)	(simple_priv_to_card(priv)->dai_link + (i))
+
+#define asoc_simple_parse_cpu(node, dai_link,				\
+			      list_name, cells_name, is_single_link)	\
+	asoc_simple_parse_dai(node, dai_link->cpus,			\
+			      list_name, cells_name, is_single_link)
+
+#define asoc_simple_parse_codec(node, dai_link,				\
+				list_name, cells_name)			\
+	asoc_simple_parse_dai(node, dai_link->codecs,			\
+			      list_name, cells_name, NULL)
+
+#define asoc_simple_parse_platform(node, dai_link,			\
+				   list_name, cells_name)		\
+	asoc_simple_parse_dai(node, dai_link->platforms,		\
+			      list_name, cells_name, NULL)
+
+struct asoc_simple_dai {
+	const char *name;
+	unsigned int sysclk;
+	int clk_direction;
+	int slots;
+	int slot_width;
+	unsigned int tx_slot_mask;
+	unsigned int rx_slot_mask;
+	struct clk *clk;
+};
+
+struct asoc_simple_data {
+	u32 convert_rate;
+	u32 convert_channels;
+};
+
+struct asoc_simple_jack {
+	struct snd_soc_jack jack;
+	struct snd_soc_jack_pin pin;
+	struct snd_soc_jack_gpio gpio;
+};
+
+struct asoc_simple_priv {
+	struct snd_soc_card snd_card;
+	struct simple_dai_props {
+		struct asoc_simple_dai *cpu_dai;
+		struct asoc_simple_dai *codec_dai;
+		struct snd_soc_dai_link_component cpus;   /* single cpu */
+		struct snd_soc_dai_link_component codecs; /* single codec */
+		struct snd_soc_dai_link_component platforms;
+		struct asoc_simple_data adata;
+		struct snd_soc_codec_conf *codec_conf;
+		bool mclk_fp;
+		unsigned int mclk_fs;
+		unsigned int cpu_pll_fs;
+		unsigned int codec_pll_fs;
+	} *dai_props;
+	struct asoc_simple_jack hp_jack;
+	struct asoc_simple_jack mic_jack;
+	struct snd_soc_dai_link *dai_link;
+	struct asoc_simple_dai *dais;
+	struct snd_soc_codec_conf *codec_conf;
+	struct gpio_desc *pa_gpio;
+};
+
+int asoc_simple_clean_reference(struct snd_soc_card *card);
+int asoc_simple_init_priv(struct asoc_simple_priv *priv);
+
+int asoc_simple_parse_widgets(struct snd_soc_card *card, char *prefix);
+int asoc_simple_parse_routing(struct snd_soc_card *card, char *prefix);
+int asoc_simple_parse_pin_switches(struct snd_soc_card *card, char *prefix);
+
+int asoc_simple_parse_daistream(struct device_node *node,
+				char *prefix,
+				struct snd_soc_dai_link *dai_link);
+int asoc_simple_parse_daifmt(struct device_node *node,
+			     struct device_node *codec,
+			     char *prefix,
+			     unsigned int *retfmt);
+int asoc_simple_parse_tdm_slot(struct device_node *node,
+			       char *prefix,
+			       struct asoc_simple_dai *dais);
+int asoc_simple_parse_tdm_clk(struct device_node *cpu,
+			      struct device_node *codec,
+			      char *prefix,
+			      struct simple_dai_props *dai_props);
+
+int asoc_simple_parse_card_name(struct snd_soc_card *card, char *prefix);
+int asoc_simple_parse_dai(struct device_node *node,
+			  struct snd_soc_dai_link_component *dlc,
+			  const char *list_name,
+			  const char *cells_name,
+			  int *is_single_link);
+
+int asoc_simple_set_dailink_name(struct device *dev,
+				 struct snd_soc_dai_link *dai_link,
+				 const char *fmt, ...);
+void asoc_simple_canonicalize_platform(struct snd_soc_dai_link *dai_link);
+void asoc_simple_canonicalize_cpu(struct snd_soc_dai_link *dai_link,
+				  int is_single_links);
+
+#endif /* __SND_SUNXI_MACH_UTILS_H */
