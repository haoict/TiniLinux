diff --git a/arch/arm64/boot/dts/rockchip/retrogame_joypad_s2_f1.dtsi b/arch/arm64/boot/dts/rockchip/retrogame_joypad_s2_f1.dtsi
new file mode 100644
index 000000000..304ef1ef4
--- /dev/null
+++ b/arch/arm64/boot/dts/rockchip/retrogame_joypad_s2_f1.dtsi
@@ -0,0 +1,122 @@
+/* 
+  This is a skeleton of joypad with 2 sticks and FN (MODE) button.
+  Fits devices with 1 stick and 2 extra face buttons too.
+  By including this ans setting I/O properties only,
+  devices should get consistent controller id and mapping
+  thus reusing non-game configs:
+    * SDL gamecontrollerdb.txt
+    * ES es_input.cfg
+    * Retroarch gamepad
+*/
+
+/ {
+    joypad: retrogame_joypad_s2_f1 {
+        /* These drivers emit the same button set which makes this skeleton ADC-agnostic */
+        /* compatible = "rocknix-joypad"; */
+        /* compatible = "rocknix-singleadc-joypad"; */
+
+        /* These are constants making Joystick Guid the same */
+        joypad-name = "retrogame_joypad_s2_f1";
+        joypad-vendor = <0x484B>;
+        joypad-product = <0x1121>;  /* 11 inherited, 2 for number of sticks, 1 for number of FN */
+        joypad-revision = <0x0100>;
+
+        /* require explicit status = "okay"; */
+        status = "disabled";
+
+        /* adc calculate scale */
+        button-adc-scale = <2>;
+
+        /* adc deadzone range  */
+        button-adc-deadzone = <64>;
+
+        /*
+          specifies fuzz value that is used to filter noise from
+          the event stream.
+        */
+        button-adc-fuzz = <32>;
+        button-adc-flat = <32>;
+
+        /* poll device interval (ms), adc read interval */
+        poll-interval = <10>;
+
+        /* gpio button auto repeat set value : default disable */
+        /*
+            autorepeat;
+        */
+
+        /* meaningful node names for easier use */
+        up {
+            label = "GPIO DPAD-UP";
+            linux,code = <BTN_DPAD_UP>;
+        };
+        down {
+            label = "GPIO DPAD-DOWN";
+            linux,code = <BTN_DPAD_DOWN>;
+        };
+        left {
+            label = "GPIO DPAD-LEFT";
+            linux,code = <BTN_DPAD_LEFT>;
+        };
+        right {
+            label = "GPIO DPAD-RIGHT";
+            linux,code = <BTN_DPAD_RIGHT>;
+        };
+
+        a {
+            label = "GPIO BTN-A";
+            linux,code = <BTN_EAST>;
+        };
+        b {
+            label = "GPIO BTN-B";
+            linux,code = <BTN_SOUTH>;
+        };
+        x {
+            label = "GPIO BTN-X";
+            linux,code = <BTN_NORTH>;
+        };
+        y {
+            label = "GPIO BTN-Y";
+            linux,code = <BTN_WEST>;
+        };
+
+        select {
+            label = "GPIO BTN_SELECT";
+            linux,code = <BTN_SELECT>;
+        };
+        start {
+            label = "GPIO BTN_START";
+            linux,code = <BTN_START>;
+        };
+        mode {
+            label = "GPIO BTN_F";
+            linux,code = <BTN_MODE>;
+        };
+
+        tl {
+            label = "GPIO BTN_TL";
+            linux,code = <BTN_TL>;
+        };
+        tr {
+            label = "GPIO BTN_TR";
+            linux,code = <BTN_TR>;
+        };
+        tl2 {
+            label = "GPIO BTN_TL2";
+            linux,code = <BTN_TL2>;
+        };
+        tr2 {
+            label = "GPIO BTN_TR2";
+            linux,code = <BTN_TR2>;
+        };
+
+        thumbl {
+            label = "GPIO BTN_THUMBL";
+            linux,code = <BTN_THUMBL>;
+        };
+        thumbr {
+            label = "GPIO BTN_THUMBR";
+            linux,code = <BTN_THUMBR>;
+        };
+    };
+};
diff --git a/arch/arm64/boot/dts/rockchip/rk3566-anbernic-rg-arc-d.dts b/arch/arm64/boot/dts/rockchip/rk3566-anbernic-rg-arc-d.dts
index ab83e8a61..74efd941b 100644
--- a/arch/arm64/boot/dts/rockchip/rk3566-anbernic-rg-arc-d.dts
+++ b/arch/arm64/boot/dts/rockchip/rk3566-anbernic-rg-arc-d.dts
@@ -33,7 +33,7 @@ touchscreen@14 {
 		pinctrl-0 = <&touch_int>;
 		pinctrl-names = "default";
 		reset-gpios = <&gpio4 RK_PA6 GPIO_ACTIVE_HIGH>;
-		touchscreen-inverted-y;
+        touchscreen-swapped-x-y;
 		touchscreen-size-x = <640>;
 		touchscreen-size-y = <480>;
 	};
diff --git a/arch/arm64/boot/dts/rockchip/rk3566-anbernic-rg-arc.dtsi b/arch/arm64/boot/dts/rockchip/rk3566-anbernic-rg-arc.dtsi
index 0aa269455..ff3c50416 100644
--- a/arch/arm64/boot/dts/rockchip/rk3566-anbernic-rg-arc.dtsi
+++ b/arch/arm64/boot/dts/rockchip/rk3566-anbernic-rg-arc.dtsi
@@ -8,10 +8,164 @@
 #include "rk3566-anbernic-rgxx3.dtsi"
 
 / {
+/*
+ * Device uses a non-standard six button layout for a gamepad with X,
+ * Y, and Z on the top row of buttons and A, B, and C under the bottom
+ * row.
+ */
+	joypad: rocknix-singleadc-joypad {
+		compatible = "rocknix-singleadc-joypad";
+		pinctrl-0 = <&btn_pins_ctrl>;
+		pinctrl-names = "default";
+		joypad-name = "rg_arc_joypad";
+		joypad-product = <0x0A2C>;
+		joypad-revision = <0x0100>;
+		joypad-vendor = <0x0001>;
+
+		status = "okay";
+		amux-count = <0>;
+		/* poll device interval (ms), adc read interval */
+		poll-interval = <10>;	
+		pwms = <&pwm5 0 1000000000 0>;
+		pwm-names = "enable";
+		rumble-boost-weak = <0x0000>;
+		rumble-boost-strong = <0x0000>;
+
+		button-down {
+			gpios = <&gpio3 RK_PA4 GPIO_ACTIVE_LOW>;
+			label = "DPAD-DOWN";
+			linux,code = <BTN_DPAD_DOWN>;
+		};
+
+		button-l1 {
+			gpios = <&gpio3 RK_PB1 GPIO_ACTIVE_LOW>;
+			label = "TL";
+			linux,code = <BTN_TL>;
+		};
+
+		button-l2 {
+			gpios = <&gpio3 RK_PB2 GPIO_ACTIVE_LOW>;
+			label = "TL2";
+			linux,code = <BTN_TL2>;
+		};
+
+		button-select {
+			gpios = <&gpio3 RK_PB6 GPIO_ACTIVE_LOW>;
+			label = "SELECT";
+			linux,code = <BTN_SELECT>;
+		};
+
+		button-start {
+			gpios = <&gpio3 RK_PB5 GPIO_ACTIVE_LOW>;
+			label = "START";
+			linux,code = <BTN_START>;
+		};
+
+		button-up {
+			gpios = <&gpio3 RK_PA3 GPIO_ACTIVE_LOW>;
+			label = "DPAD-UP";
+			linux,code = <BTN_DPAD_UP>;
+		};
+
+		button-a {
+			gpios = <&gpio3 RK_PC3 GPIO_ACTIVE_LOW>;
+			label = "A";
+			linux,code = <BTN_A>;
+		};
+
+		button-b {
+			gpios = <&gpio3 RK_PC2 GPIO_ACTIVE_LOW>;
+			label = "B";
+			linux,code = <BTN_B>;
+		};
+
+		button-c {
+			gpios = <&gpio3 RK_PA2 GPIO_ACTIVE_LOW>;
+			label = "C";
+			linux,code = <BTN_C>;
+		};
+
+		button-left {
+			gpios = <&gpio3 RK_PA6 GPIO_ACTIVE_LOW>;
+			label = "DPAD-LEFT";
+			linux,code = <BTN_DPAD_LEFT>;
+		};
+
+		button-r1 {
+			gpios = <&gpio3 RK_PB4 GPIO_ACTIVE_LOW>;
+			label = "TR";
+			linux,code = <BTN_TR>;
+		};
+
+		button-r2 {
+			gpios = <&gpio3 RK_PB3 GPIO_ACTIVE_LOW>;
+			label = "TR2";
+			linux,code = <BTN_TR2>;
+		};
+
+		button-right {
+			gpios = <&gpio3 RK_PA5 GPIO_ACTIVE_LOW>;
+			label = "DPAD-RIGHT";
+			linux,code = <BTN_DPAD_RIGHT>;
+		};
+
+		button-x {
+			gpios = <&gpio3 RK_PC0 GPIO_ACTIVE_LOW>;
+			label = "X";
+			linux,code = <BTN_X>;
+		};
+
+		button-y {
+			gpios = <&gpio3 RK_PC1 GPIO_ACTIVE_LOW>;
+			label = "Y";
+			linux,code = <BTN_Y>;
+		};
+
+		button-z {
+			gpios = <&gpio3 RK_PA1 GPIO_ACTIVE_LOW>;
+			label = "Z";
+			linux,code = <BTN_Z>;
+		};
+	};
+
 	backlight: backlight {
 		compatible = "pwm-backlight";
 		power-supply = <&vcc_sys>;
 		pwms = <&pwm4 0 25000 0>;
+		brightness-levels = <
+			  0   1   2   3   4   5   6   7
+			  8   9  10  11  12  13  14  15
+			 16  17  18  19  20  21  22  23
+			 24  25  26  27  28  29  30  31
+			 32  33  34  35  36  37  38  39
+			 40  41  42  43  44  45  46  47
+			 48  49  50  51  52  53  54  55
+			 56  57  58  59  60  61  62  63
+			 64  65  66  67  68  69  70  71
+			 72  73  74  75  76  77  78  79
+			 80  81  82  83  84  85  86  87
+			 88  89  90  91  92  93  94  95
+			 96  97  98  99 100 101 102 103
+			104 105 106 107 108 109 110 111
+			112 113 114 115 116 117 118 119
+			120 121 122 123 124 125 126 127
+			128 129 130 131 132 133 134 135
+			136 137 138 139 140 141 142 143
+			144 145 146 147 148 149 150 151
+			152 153 154 155 156 157 158 159
+			160 161 162 163 164 165 166 167
+			168 169 170 171 172 173 174 175
+			176 177 178 179 180 181 182 183
+			184 185 186 187 188 189 190 191
+			192 193 194 195 196 197 198 199
+			200 201 202 203 204 205 206 207
+			208 209 210 211 212 213 214 215
+			216 217 218 219 220 221 222 223
+			224 225 226 227 228 229 230 231
+			232 233 234 235 236 237 238 239
+			240 241 242 243 244 245 246 247
+			248 249 250 251 252 253 254 255>;
+		default-brightness-level = <77>;
 	};
 
 	battery: battery {
@@ -72,6 +226,7 @@ spk_amp: audio-amplifier {
 		pinctrl-0 = <&spk_amp_enable_h>;
 		pinctrl-names = "default";
 		sound-name-prefix = "Speaker Amp";
+		VCC-supply = <&vcc_3v3>;
 	};
 };
 
@@ -126,73 +281,6 @@ mipi_in_panel: endpoint {
 	};
 };
 
-/*
- * Device uses a non-standard six button layout for a gamepad with X,
- * Y, and Z on the top row of buttons and A, B, and C under the bottom
- * row.
- */
-&gpio_keys_control {
-	button-a {
-		gpios = <&gpio3 RK_PC3 GPIO_ACTIVE_LOW>;
-		label = "A";
-		linux,code = <BTN_A>;
-	};
-
-	button-b {
-		gpios = <&gpio3 RK_PC2 GPIO_ACTIVE_LOW>;
-		label = "B";
-		linux,code = <BTN_B>;
-	};
-
-	button-c {
-		gpios = <&gpio3 RK_PA2 GPIO_ACTIVE_LOW>;
-		label = "C";
-		linux,code = <BTN_C>;
-	};
-
-	button-left {
-		gpios = <&gpio3 RK_PA6 GPIO_ACTIVE_LOW>;
-		label = "DPAD-LEFT";
-		linux,code = <BTN_DPAD_LEFT>;
-	};
-
-	button-r1 {
-		gpios = <&gpio3 RK_PB4 GPIO_ACTIVE_LOW>;
-		label = "TR";
-		linux,code = <BTN_TR>;
-	};
-
-	button-r2 {
-		gpios = <&gpio3 RK_PB3 GPIO_ACTIVE_LOW>;
-		label = "TR2";
-		linux,code = <BTN_TR2>;
-	};
-
-	button-right {
-		gpios = <&gpio3 RK_PA5 GPIO_ACTIVE_LOW>;
-		label = "DPAD-RIGHT";
-		linux,code = <BTN_DPAD_RIGHT>;
-	};
-
-	button-x {
-		gpios = <&gpio3 RK_PC0 GPIO_ACTIVE_LOW>;
-		label = "X";
-		linux,code = <BTN_X>;
-	};
-
-	button-y {
-		gpios = <&gpio3 RK_PC1 GPIO_ACTIVE_LOW>;
-		label = "Y";
-		linux,code = <BTN_Y>;
-	};
-
-	button-z {
-		gpios = <&gpio3 RK_PA1 GPIO_ACTIVE_LOW>;
-		label = "Z";
-		linux,code = <BTN_Z>;
-	};
-};
-
 &pinctrl {
 	audio-amplifier {
 		spk_amp_enable_h: spk-amp-enable-h {
diff --git a/arch/arm64/boot/dts/rockchip/rk3566-anbernic-rg353p.dts b/arch/arm64/boot/dts/rockchip/rk3566-anbernic-rg353p.dts
index b80b6b593..c30092b24 100644
--- a/arch/arm64/boot/dts/rockchip/rk3566-anbernic-rg353p.dts
+++ b/arch/arm64/boot/dts/rockchip/rk3566-anbernic-rg353p.dts
@@ -74,20 +74,7 @@ spk_amp: audio-amplifier {
 		pinctrl-0 = <&spk_amp_enable_h>;
 		pinctrl-names = "default";
 		sound-name-prefix = "Speaker Amp";
-	};
-};
-
-&gpio_keys_control {
-	button-r1 {
-		gpios = <&gpio3 RK_PB4 GPIO_ACTIVE_LOW>;
-		label = "TR";
-		linux,code = <BTN_TR>;
-	};
-
-	button-r2 {
-		gpios = <&gpio3 RK_PB3 GPIO_ACTIVE_LOW>;
-		label = "TR2";
-		linux,code = <BTN_TR2>;
+		VCC-supply = <&vcc_3v3>;
 	};
 };
 
diff --git a/arch/arm64/boot/dts/rockchip/rk3566-anbernic-rg353ps.dts b/arch/arm64/boot/dts/rockchip/rk3566-anbernic-rg353ps.dts
index 4fb712fe9..96ef44e6d 100644
--- a/arch/arm64/boot/dts/rockchip/rk3566-anbernic-rg353ps.dts
+++ b/arch/arm64/boot/dts/rockchip/rk3566-anbernic-rg353ps.dts
@@ -73,20 +73,7 @@ spk_amp: audio-amplifier {
 		pinctrl-0 = <&spk_amp_enable_h>;
 		pinctrl-names = "default";
 		sound-name-prefix = "Speaker Amp";
-	};
-};
-
-&gpio_keys_control {
-	button-r1 {
-		gpios = <&gpio3 RK_PB4 GPIO_ACTIVE_LOW>;
-		label = "TR";
-		linux,code = <BTN_TR>;
-	};
-
-	button-r2 {
-		gpios = <&gpio3 RK_PB3 GPIO_ACTIVE_LOW>;
-		label = "TR2";
-		linux,code = <BTN_TR2>;
+		VCC-supply = <&vcc_3v3>;
 	};
 };
 
diff --git a/arch/arm64/boot/dts/rockchip/rk3566-anbernic-rg353v.dts b/arch/arm64/boot/dts/rockchip/rk3566-anbernic-rg353v.dts
index 01588bebf..fd86c6956 100644
--- a/arch/arm64/boot/dts/rockchip/rk3566-anbernic-rg353v.dts
+++ b/arch/arm64/boot/dts/rockchip/rk3566-anbernic-rg353v.dts
@@ -64,20 +64,6 @@ simple-audio-card,cpu {
 	};
 };
 
-&gpio_keys_control {
-	button-r1 {
-		gpios = <&gpio3 RK_PB3 GPIO_ACTIVE_LOW>;
-		label = "TR";
-		linux,code = <BTN_TR>;
-	};
-
-	button-r2 {
-		gpios = <&gpio3 RK_PB4 GPIO_ACTIVE_LOW>;
-		label = "TR2";
-		linux,code = <BTN_TR2>;
-	};
-};
-
 &i2c2 {
 	pinctrl-names = "default";
 	pinctrl-0 = <&i2c2m1_xfer>;
@@ -124,3 +110,16 @@ &sdhci {
 	vqmmc-supply = <&vcc_1v8>;
 	status = "okay";
 };
+
+&joypad {
+	sw13 {
+		gpios = <&gpio3 RK_PB3 GPIO_ACTIVE_LOW>;
+		label = "GPIO BTN_TR";
+		linux,code = <BTN_TR>;
+	};
+	sw15 {
+		gpios = <&gpio3 RK_PB4 GPIO_ACTIVE_LOW>;
+		label = "GPIO BTN_TR2";
+		linux,code = <BTN_TR2>;
+	};
+};
diff --git a/arch/arm64/boot/dts/rockchip/rk3566-anbernic-rg353vs.dts b/arch/arm64/boot/dts/rockchip/rk3566-anbernic-rg353vs.dts
index 5a30e3918..039a67613 100644
--- a/arch/arm64/boot/dts/rockchip/rk3566-anbernic-rg353vs.dts
+++ b/arch/arm64/boot/dts/rockchip/rk3566-anbernic-rg353vs.dts
@@ -63,20 +63,6 @@ simple-audio-card,cpu {
 	};
 };
 
-&gpio_keys_control {
-	button-r1 {
-		gpios = <&gpio3 RK_PB3 GPIO_ACTIVE_LOW>;
-		label = "TR";
-		linux,code = <BTN_TR>;
-	};
-
-	button-r2 {
-		gpios = <&gpio3 RK_PB4 GPIO_ACTIVE_LOW>;
-		label = "TR2";
-		linux,code = <BTN_TR2>;
-	};
-};
-
 &rk817 {
 	rk817_charger: charger {
 		monitored-battery = <&battery>;
@@ -85,3 +71,16 @@ rk817_charger: charger {
 		rockchip,sleep-filter-current-microamp = <100000>;
 	};
 };
+
+&joypad {
+	sw13 {
+		gpios = <&gpio3 RK_PB3 GPIO_ACTIVE_LOW>;
+		label = "GPIO BTN_TR";
+		linux,code = <BTN_TR>;
+	};
+	sw15 {
+		gpios = <&gpio3 RK_PB4 GPIO_ACTIVE_LOW>;
+		label = "GPIO BTN_TR2";
+		linux,code = <BTN_TR2>;
+	};
+};
diff --git a/arch/arm64/boot/dts/rockchip/rk3566-anbernic-rg353x.dtsi b/arch/arm64/boot/dts/rockchip/rk3566-anbernic-rg353x.dtsi
index 63a18ff36..270a1f401 100644
--- a/arch/arm64/boot/dts/rockchip/rk3566-anbernic-rg353x.dtsi
+++ b/arch/arm64/boot/dts/rockchip/rk3566-anbernic-rg353x.dtsi
@@ -8,72 +8,202 @@
 #include "rk3566-anbernic-rgxx3.dtsi"
 
 / {
-	adc-joystick {
-		compatible = "adc-joystick";
-		io-channels = <&adc_mux 0>,
-			      <&adc_mux 1>,
-			      <&adc_mux 2>,
-			      <&adc_mux 3>;
-		pinctrl-0 = <&joy_mux_en>;
+	joypad: rocknix-singleadc-joypad {
+		compatible = "rocknix-singleadc-joypad";
+
+		joypad-name = "retrogame_joypad";
+		joypad-product = <0x1101>;
+		joypad-revision = <0x0100>;
+		joypad-vendor = <0x484B>;
+
+		pwms = <&pwm5 0 1000000000 0>;
+		pwm-names = "enable";
+		rumble-boost-weak = <0x0000>;
+		rumble-boost-strong = <0x0000>;
+		status = "okay";
+
+		/* gpio pincontrol setup */
 		pinctrl-names = "default";
-		poll-interval = <60>;
-		#address-cells = <1>;
-		#size-cells = <0>;
+		pinctrl-0 = <&btn_pins_ctrl>;
 
-		axis@0 {
-			reg = <0>;
-			abs-flat = <32>;
-			abs-fuzz = <32>;
-			abs-range = <1023 15>;
-			linux,code = <ABS_X>;
-		};
+		/* Analog mux define */
+		io-channel-names = "amux_adc";
+		io-channels = <&saradc 3>;
 
-		axis@1 {
-			reg = <1>;
-			abs-flat = <32>;
-			abs-fuzz = <32>;
-			abs-range = <15 1023>;
-			linux,code = <ABS_RX>;
-		};
+		/* adc mux channel count */
+		amux-count = <4>;
+		/* adc mux select(a,b) gpio */
+		amux-a-gpios = <&gpio0 RK_PB6 GPIO_ACTIVE_LOW>;
+		amux-b-gpios = <&gpio0 RK_PB7 GPIO_ACTIVE_LOW>;
+		/* adc mux enable gpio */
+		amux-en-gpios = <&gpio0 RK_PB5 GPIO_ACTIVE_LOW>;
 
-		axis@2 {
-			reg = <2>;
-			abs-flat = <32>;
-			abs-fuzz = <32>;
-			abs-range = <15 1023>;
-			linux,code = <ABS_Y>;
-		};
+		/* adc calculate scale */
+		button-adc-scale = <2>;
 
-		axis@3 {
-			reg = <3>;
-			abs-flat = <32>;
-			abs-fuzz = <32>;
-			abs-range = <1023 15>;
-			linux,code = <ABS_RY>;
-		};
-	};
+		/* adc deadzone range  */
+		button-adc-deadzone = <64>;
 
-	adc_mux: adc-mux {
-		compatible = "io-channel-mux";
-		channels = "left_x", "right_x", "left_y", "right_y";
-		#io-channel-cells = <1>;
-		io-channels = <&saradc 3>;
-		io-channel-names = "parent";
-		mux-controls = <&gpio_mux>;
-		settle-time-us = <100>;
+		/*
+		  specifies fuzz value that is used to filter noise from
+		  the event stream.
+		*/
+		button-adc-fuzz = <32>;
+		button-adc-flat = <32>;
+
+		/*
+		  Analog Stick data tuning value(precent)
+		  p = positive direction, n = negative direction
+		  report value = (real_adc_data * tuning_value) / 100
+		*/
+		abs_x-p-tuning = <245>;
+		abs_x-n-tuning = <245>;
+
+		abs_y-p-tuning = <245>;
+		abs_y-n-tuning = <245>;
+
+		abs_rx-p-tuning = <245>;
+		abs_rx-n-tuning = <245>;
+
+		abs_ry-p-tuning = <245>;
+		abs_ry-n-tuning = <245>;
+
+		/* poll device interval (ms), adc read interval */
+		poll-interval = <10>;
+
+		/* required to invert x/y */
+		invert-absx;
+		invert-absy;
+
+		/* gpio button auto repeat set value : default disable */
+		/*
+			autorepeat;
+		*/
+		sw1 {
+			gpios = <&gpio3 RK_PA3 GPIO_ACTIVE_LOW>;
+			label = "GPIO DPAD-UP";
+			linux,code = <BTN_DPAD_UP>;
+		};
+		sw2 {
+			gpios = <&gpio3 RK_PA4 GPIO_ACTIVE_LOW>;
+			label = "GPIO DPAD-DOWN";
+			linux,code = <BTN_DPAD_DOWN>;
+		};
+		sw3 {
+			gpios = <&gpio3 RK_PA6 GPIO_ACTIVE_LOW>;
+			label = "GPIO DPAD-LEFT";
+			linux,code = <BTN_DPAD_LEFT>;
+		};
+		sw4 {
+			gpios = <&gpio3 RK_PA5 GPIO_ACTIVE_LOW>;
+			label = "GPIO DPAD-RIGHT";
+			linux,code = <BTN_DPAD_RIGHT>;
+		};
+		sw5 {
+			gpios = <&gpio3 RK_PC3 GPIO_ACTIVE_LOW>;
+			label = "GPIO KEY BTN-A";
+			linux,code = <BTN_SOUTH>;
+		};
+		sw6 {
+			gpios = <&gpio3 RK_PC2 GPIO_ACTIVE_LOW>;
+			label = "GPIO BTN-B";
+			linux,code = <BTN_EAST>;
+		};
+		sw7 {
+			gpios = <&gpio3 RK_PC0 GPIO_ACTIVE_LOW>;
+			label = "GPIO BTN-X";
+			linux,code = <BTN_NORTH>;
+		};
+		sw8 {
+			gpios = <&gpio3 RK_PC1 GPIO_ACTIVE_LOW>;
+			label = "GPIO BTN-Y";
+			linux,code = <BTN_WEST>;
+		};
+		sw9 {
+			gpios = <&gpio3 RK_PB6 GPIO_ACTIVE_LOW>;
+			label = "GPIO BTN_SELECT";
+			linux,code = <BTN_SELECT>;
+		};
+		sw10 {
+			gpios = <&gpio3 RK_PB5 GPIO_ACTIVE_LOW>;
+			label = "GPIO BTN_START";
+			linux,code = <BTN_START>;
+		};
+		sw11 {
+			gpios = <&gpio3 RK_PB7 GPIO_ACTIVE_LOW>;
+			label = "GPIO BTN_F";
+			linux,code = <BTN_MODE>;
+		};
+		sw12 {
+			gpios = <&gpio3 RK_PB1 GPIO_ACTIVE_LOW>;
+			label = "GPIO BTN_TL";
+			linux,code = <BTN_TL>;
+		};
+		sw13 {
+			gpios = <&gpio3 RK_PB4 GPIO_ACTIVE_LOW>;
+			label = "GPIO BTN_TR";
+			linux,code = <BTN_TR>;
+		};
+		sw14 {
+			gpios = <&gpio3 RK_PB2 GPIO_ACTIVE_LOW>;
+			label = "GPIO BTN_TL2";
+			linux,code = <BTN_TL2>;
+		};
+		sw15 {
+			gpios = <&gpio3 RK_PB3 GPIO_ACTIVE_LOW>;
+			label = "GPIO BTN_TR2";
+			linux,code = <BTN_TR2>;
+		};
+		sw16 {
+			gpios = <&gpio3 RK_PA1 GPIO_ACTIVE_LOW>;
+			label = "GPIO BTN_THUMBL";
+			linux,code = <BTN_THUMBL>;
+		};
+		sw17 {
+			gpios = <&gpio3 RK_PA2 GPIO_ACTIVE_LOW>;
+			label = "GPIO BTN_THUMBR";
+			linux,code = <BTN_THUMBR>;
+		};
 	};
 
 	backlight: backlight {
 		compatible = "pwm-backlight";
 		power-supply = <&vcc_sys>;
 		pwms = <&pwm4 0 25000 0>;
-	};
-
-	gpio_mux: mux-controller {
-		compatible = "gpio-mux";
-		mux-gpios = <&gpio0 RK_PB6 GPIO_ACTIVE_LOW>,
-			    <&gpio0 RK_PB7 GPIO_ACTIVE_LOW>;
-		#mux-control-cells = <0>;
+		brightness-levels = <
+			  0   1   2   3   4   5   6   7
+			  8   9  10  11  12  13  14  15
+			 16  17  18  19  20  21  22  23
+			 24  25  26  27  28  29  30  31
+			 32  33  34  35  36  37  38  39
+			 40  41  42  43  44  45  46  47
+			 48  49  50  51  52  53  54  55
+			 56  57  58  59  60  61  62  63
+			 64  65  66  67  68  69  70  71
+			 72  73  74  75  76  77  78  79
+			 80  81  82  83  84  85  86  87
+			 88  89  90  91  92  93  94  95
+			 96  97  98  99 100 101 102 103
+			104 105 106 107 108 109 110 111
+			112 113 114 115 116 117 118 119
+			120 121 122 123 124 125 126 127
+			128 129 130 131 132 133 134 135
+			136 137 138 139 140 141 142 143
+			144 145 146 147 148 149 150 151
+			152 153 154 155 156 157 158 159
+			160 161 162 163 164 165 166 167
+			168 169 170 171 172 173 174 175
+			176 177 178 179 180 181 182 183
+			184 185 186 187 188 189 190 191
+			192 193 194 195 196 197 198 199
+			200 201 202 203 204 205 206 207
+			208 209 210 211 212 213 214 215
+			216 217 218 219 220 221 222 223
+			224 225 226 227 228 229 230 231
+			232 233 234 235 236 237 238 239
+			240 241 242 243 244 245 246 247
+			248 249 250 251 252 253 254 255>;
+		default-brightness-level = <77>;
 	};
 };
 
@@ -126,44 +256,6 @@ mipi_in_panel: endpoint {
 	};
 };
 
-&gpio_keys_control {
-	button-a {
-		gpios = <&gpio3 RK_PC2 GPIO_ACTIVE_LOW>;
-		label = "EAST";
-		linux,code = <BTN_EAST>;
-	};
-
-	button-left {
-		gpios = <&gpio3 RK_PA6 GPIO_ACTIVE_LOW>;
-		label = "DPAD-LEFT";
-		linux,code = <BTN_DPAD_LEFT>;
-	};
-
-	button-right {
-		gpios = <&gpio3 RK_PA5 GPIO_ACTIVE_LOW>;
-		label = "DPAD-RIGHT";
-		linux,code = <BTN_DPAD_RIGHT>;
-	};
-
-	button-thumbl {
-		gpios = <&gpio3 RK_PA1 GPIO_ACTIVE_LOW>;
-		label = "THUMBL";
-		linux,code = <BTN_THUMBL>;
-	};
-
-	button-thumbr {
-		gpios = <&gpio3 RK_PA2 GPIO_ACTIVE_LOW>;
-		label = "THUMBR";
-		linux,code = <BTN_THUMBR>;
-	};
-
-	button-y {
-		gpios = <&gpio3 RK_PC1 GPIO_ACTIVE_LOW>;
-		label = "WEST";
-		linux,code = <BTN_WEST>;
-	};
-};
-
 &i2c0 {
 	/* This hardware is physically present but unused. */
 	power-monitor@62 {
diff --git a/arch/arm64/boot/dts/rockchip/rk3566-anbernic-rg503.dts b/arch/arm64/boot/dts/rockchip/rk3566-anbernic-rg503.dts
index 4dcc0ea4c..ce4aec35e 100644
--- a/arch/arm64/boot/dts/rockchip/rk3566-anbernic-rg503.dts
+++ b/arch/arm64/boot/dts/rockchip/rk3566-anbernic-rg503.dts
@@ -16,62 +16,6 @@ aliases {
 		mmc1 = &sdmmc1;
 		mmc2 = &sdmmc2;
 	};
-
-	adc-joystick {
-		compatible = "adc-joystick";
-		io-channels = <&adc_mux 0>,
-			      <&adc_mux 1>,
-			      <&adc_mux 2>,
-			      <&adc_mux 3>;
-		pinctrl-0 = <&joy_mux_en>;
-		pinctrl-names = "default";
-		poll-interval = <60>;
-		#address-cells = <1>;
-		#size-cells = <0>;
-
-		axis@0 {
-			reg = <0>;
-			abs-flat = <32>;
-			abs-fuzz = <32>;
-			abs-range = <1023 15>;
-			linux,code = <ABS_X>;
-		};
-
-		axis@1 {
-			reg = <1>;
-			abs-flat = <32>;
-			abs-fuzz = <32>;
-			abs-range = <15 1023>;
-			linux,code = <ABS_RX>;
-		};
-
-		axis@2 {
-			reg = <2>;
-			abs-flat = <32>;
-			abs-fuzz = <32>;
-			abs-range = <15 1023>;
-			linux,code = <ABS_Y>;
-		};
-
-		axis@3 {
-			reg = <3>;
-			abs-flat = <32>;
-			abs-fuzz = <32>;
-			abs-range = <1023 15>;
-			linux,code = <ABS_RY>;
-		};
-	};
-
-	adc_mux: adc-mux {
-		compatible = "io-channel-mux";
-		channels = "left_x", "right_x", "left_y", "right_y";
-		#io-channel-cells = <1>;
-		io-channels = <&saradc 3>;
-		io-channel-names = "parent";
-		mux-controls = <&gpio_mux>;
-		settle-time-us = <100>;
-	};
-
 	battery: battery {
 		compatible = "simple-battery";
 		charge-full-design-microamp-hours = <3472000>;
@@ -91,13 +35,6 @@ battery: battery {
 					<3400000 0>;
 	};
 
-	gpio_mux: mux-controller {
-		compatible = "gpio-mux";
-		mux-gpios = <&gpio0 RK_PB6 GPIO_ACTIVE_LOW>,
-			    <&gpio0 RK_PB7 GPIO_ACTIVE_LOW>;
-		#mux-control-cells = <0>;
-	};
-
 	gpio_spi: spi {
 		compatible = "spi-gpio";
 		pinctrl-names = "default";
@@ -163,6 +100,165 @@ spk_amp: audio-amplifier {
 		pinctrl-0 = <&spk_amp_enable_h>;
 		pinctrl-names = "default";
 		sound-name-prefix = "Speaker Amp";
+		VCC-supply = <&vcc_3v3>;
+	};
+
+	joypad: rocknix-singleadc-joypad {
+		compatible = "rocknix-singleadc-joypad";
+
+		joypad-name = "retrogame_joypad";
+		joypad-product = <0x1101>;
+		joypad-revision = <0x0100>;
+		joypad-vendor = <0x484B>;
+
+		status = "okay";
+		pwms = <&pwm5 0 1000000000 0>;
+		pwm-names = "enable";
+		rumble-boost-weak = <0x0000>;
+		rumble-boost-strong = <0x0000>;
+
+		/* gpio pincontrol setup */
+		pinctrl-names = "default";
+		pinctrl-0 = <&btn_pins_ctrl>;
+
+		/* Analog mux define */
+		io-channel-names = "amux_adc";
+		io-channels = <&saradc 3>;
+
+		/* adc mux channel count */
+		amux-count = <4>;
+		/* adc mux select(a,b) gpio */
+		amux-a-gpios = <&gpio0 RK_PB6 GPIO_ACTIVE_LOW>;
+		amux-b-gpios = <&gpio0 RK_PB7 GPIO_ACTIVE_LOW>;
+		/* adc mux enable gpio */
+		amux-en-gpios = <&gpio0 RK_PB5 GPIO_ACTIVE_LOW>;
+
+		/* adc calculate scale */
+		button-adc-scale = <2>;
+
+		/* adc deadzone range  */
+		button-adc-deadzone = <64>;
+
+		/*
+		  specifies fuzz value that is used to filter noise from
+		  the event stream.
+		*/
+		button-adc-fuzz = <32>;
+		button-adc-flat = <32>;
+
+		/*
+		  Analog Stick data tuning value(precent)
+		  p = positive direction, n = negative direction
+		  report value = (real_adc_data * tuning_value) / 100
+		*/
+		abs_x-p-tuning = <450>;
+		abs_x-n-tuning = <450>;
+
+		abs_y-p-tuning = <450>;
+		abs_y-n-tuning = <450>;
+
+		abs_rx-p-tuning = <450>;
+		abs_rx-n-tuning = <450>;
+
+		abs_ry-p-tuning = <450>;
+		abs_ry-n-tuning = <450>;
+
+		/* poll device interval (ms), adc read interval */
+		poll-interval = <10>;
+
+		/* required to invert x/y */
+		invert-absx;
+		invert-absy;
+
+		/* gpio button auto repeat set value : default disable */
+		/*
+			autorepeat;
+		*/
+		sw1 {
+			gpios = <&gpio3 RK_PA3 GPIO_ACTIVE_LOW>;
+			label = "GPIO DPAD-UP";
+			linux,code = <BTN_DPAD_UP>;
+		};
+		sw2 {
+			gpios = <&gpio3 RK_PA4 GPIO_ACTIVE_LOW>;
+			label = "GPIO DPAD-DOWN";
+			linux,code = <BTN_DPAD_DOWN>;
+		};
+		sw3 {
+			gpios = <&gpio3 RK_PA5 GPIO_ACTIVE_LOW>;
+			label = "GPIO DPAD-LEFT";
+			linux,code = <BTN_DPAD_LEFT>;
+		};
+		sw4 {
+			gpios = <&gpio3 RK_PA6 GPIO_ACTIVE_LOW>;
+			label = "GPIO DPAD-RIGHT";
+			linux,code = <BTN_DPAD_RIGHT>;
+		};
+		sw5 {
+			gpios = <&gpio3 RK_PC3 GPIO_ACTIVE_LOW>;
+			label = "GPIO KEY BTN-A";
+			linux,code = <BTN_SOUTH>;
+		};
+		sw6 {
+			gpios = <&gpio3 RK_PC2 GPIO_ACTIVE_LOW>;
+			label = "GPIO BTN-B";
+			linux,code = <BTN_EAST>;
+		};
+		sw7 {
+			gpios = <&gpio3 RK_PC0 GPIO_ACTIVE_LOW>;
+			label = "GPIO BTN-X";
+			linux,code = <BTN_NORTH>;
+		};
+		sw8 {
+			gpios = <&gpio3 RK_PC1 GPIO_ACTIVE_LOW>;
+			label = "GPIO BTN-Y";
+			linux,code = <BTN_WEST>;
+		};
+		sw9 {
+			gpios = <&gpio3 RK_PB6 GPIO_ACTIVE_LOW>;
+			label = "GPIO BTN_SELECT";
+			linux,code = <BTN_SELECT>;
+		};
+		sw10 {
+			gpios = <&gpio3 RK_PB5 GPIO_ACTIVE_LOW>;
+			label = "GPIO BTN_START";
+			linux,code = <BTN_START>;
+		};
+		sw11 {
+			gpios = <&gpio3 RK_PB7 GPIO_ACTIVE_LOW>;
+			label = "GPIO BTN_F";
+			linux,code = <BTN_MODE>;
+		};
+		sw12 {
+			gpios = <&gpio3 RK_PB1 GPIO_ACTIVE_LOW>;
+			label = "GPIO BTN_TL";
+			linux,code = <BTN_TL>;
+		};
+		sw13 {
+			gpios = <&gpio3 RK_PB3 GPIO_ACTIVE_LOW>;
+			label = "GPIO BTN_TR";
+			linux,code = <BTN_TR>;
+		};
+		sw14 {
+			gpios = <&gpio3 RK_PB2 GPIO_ACTIVE_LOW>;
+			label = "GPIO BTN_TL2";
+			linux,code = <BTN_TL2>;
+		};
+		sw15 {
+			gpios = <&gpio3 RK_PB4 GPIO_ACTIVE_LOW>;
+			label = "GPIO BTN_TR2";
+			linux,code = <BTN_TR2>;
+		};
+		sw16 {
+			gpios = <&gpio3 RK_PA1 GPIO_ACTIVE_LOW>;
+			label = "GPIO BTN_THUMBL";
+			linux,code = <BTN_THUMBL>;
+		};
+		sw17 {
+			gpios = <&gpio3 RK_PA2 GPIO_ACTIVE_LOW>;
+			label = "GPIO BTN_THUMBR";
+			linux,code = <BTN_THUMBR>;
+		};
 	};
 };
 
@@ -199,62 +295,6 @@ mipi_out_panel: endpoint {
 	};
 };
 
-&gpio_keys_control {
-	button-a {
-		gpios = <&gpio3 RK_PC1 GPIO_ACTIVE_LOW>;
-		label = "EAST";
-		linux,code = <BTN_EAST>;
-	};
-
-	button-left {
-		gpios = <&gpio3 RK_PA5 GPIO_ACTIVE_LOW>;
-		label = "DPAD-LEFT";
-		linux,code = <BTN_DPAD_LEFT>;
-	};
-
-	button-right {
-		gpios = <&gpio3 RK_PA6 GPIO_ACTIVE_LOW>;
-		label = "DPAD-RIGHT";
-		linux,code = <BTN_DPAD_RIGHT>;
-	};
-
-	button-r1 {
-		gpios = <&gpio3 RK_PB3 GPIO_ACTIVE_LOW>;
-		label = "TR";
-		linux,code = <BTN_TR>;
-	};
-
-	button-r2 {
-		gpios = <&gpio3 RK_PB4 GPIO_ACTIVE_LOW>;
-		label = "TR2";
-		linux,code = <BTN_TR2>;
-	};
-
-	button-right {
-		gpios = <&gpio3 RK_PA6 GPIO_ACTIVE_LOW>;
-		label = "DPAD-RIGHT";
-		linux,code = <BTN_DPAD_RIGHT>;
-	};
-
-	button-thumbl {
-		gpios = <&gpio3 RK_PA1 GPIO_ACTIVE_LOW>;
-		label = "THUMBL";
-		linux,code = <BTN_THUMBL>;
-	};
-
-	button-thumbr {
-		gpios = <&gpio3 RK_PA2 GPIO_ACTIVE_LOW>;
-		label = "THUMBR";
-		linux,code = <BTN_THUMBR>;
-	};
-
-	button-y {
-		gpios = <&gpio3 RK_PC2 GPIO_ACTIVE_LOW>;
-		label = "WEST";
-		linux,code = <BTN_WEST>;
-	};
-};
-
 &pinctrl {
 	audio-amplifier {
 		spk_amp_enable_h: spk-amp-enable-h {
diff --git a/arch/arm64/boot/dts/rockchip/rk3566-anbernic-rgxx3.dtsi b/arch/arm64/boot/dts/rockchip/rk3566-anbernic-rgxx3.dtsi
index 645db9d3d..3dc4c2e83 100644
--- a/arch/arm64/boot/dts/rockchip/rk3566-anbernic-rgxx3.dtsi
+++ b/arch/arm64/boot/dts/rockchip/rk3566-anbernic-rgxx3.dtsi
@@ -34,60 +34,6 @@ button-mode {
 		};
 	};
 
-	gpio_keys_control: gpio-keys-control {
-		compatible = "gpio-keys";
-		pinctrl-0 = <&btn_pins_ctrl>;
-		pinctrl-names = "default";
-
-		button-b {
-			gpios = <&gpio3 RK_PC3 GPIO_ACTIVE_LOW>;
-			label = "SOUTH";
-			linux,code = <BTN_SOUTH>;
-		};
-
-		button-down {
-			gpios = <&gpio3 RK_PA4 GPIO_ACTIVE_LOW>;
-			label = "DPAD-DOWN";
-			linux,code = <BTN_DPAD_DOWN>;
-		};
-
-		button-l1 {
-			gpios = <&gpio3 RK_PB1 GPIO_ACTIVE_LOW>;
-			label = "TL";
-			linux,code = <BTN_TL>;
-		};
-
-		button-l2 {
-			gpios = <&gpio3 RK_PB2 GPIO_ACTIVE_LOW>;
-			label = "TL2";
-			linux,code = <BTN_TL2>;
-		};
-
-		button-select {
-			gpios = <&gpio3 RK_PB6 GPIO_ACTIVE_LOW>;
-			label = "SELECT";
-			linux,code = <BTN_SELECT>;
-		};
-
-		button-start {
-			gpios = <&gpio3 RK_PB5 GPIO_ACTIVE_LOW>;
-			label = "START";
-			linux,code = <BTN_START>;
-		};
-
-		button-up {
-			gpios = <&gpio3 RK_PA3 GPIO_ACTIVE_LOW>;
-			label = "DPAD-UP";
-			linux,code = <BTN_DPAD_UP>;
-		};
-
-		button-x {
-			gpios = <&gpio3 RK_PC0 GPIO_ACTIVE_LOW>;
-			label = "NORTH";
-			linux,code = <BTN_NORTH>;
-		};
-	};
-
 	gpio_keys_vol: gpio-keys-vol {
 		compatible = "gpio-keys";
 		autorepeat;
@@ -162,7 +108,6 @@ vcc3v3_lcd0_n: regulator-vcc3v3-lcd0 {
 		enable-active-high;
 		pinctrl-0 = <&vcc_lcd_h>;
 		pinctrl-names = "default";
-		regulator-boot-on;
 		regulator-min-microvolt = <3300000>;
 		regulator-max-microvolt = <3300000>;
 		regulator-name = "vcc3v3_lcd0_n";
@@ -188,17 +133,11 @@ vcc_wifi: regulator-vcc-wifi {
 		pinctrl-0 = <&vcc_wifi_h>;
 		pinctrl-names = "default";
 		regulator-always-on;
-		regulator-boot-on;
 		regulator-min-microvolt = <3300000>;
 		regulator-max-microvolt = <3300000>;
 		regulator-name = "vcc_wifi";
 	};
 
-	vibrator: pwm-vibrator {
-		compatible = "pwm-vibrator";
-		pwm-names = "enable";
-		pwms = <&pwm5 0 1000000000 0>;
-	};
 };
 
 &combphy1 {
@@ -230,6 +169,8 @@ &hdmi {
 	ddc-i2c-bus = <&i2c5>;
 	pinctrl-0 = <&hdmitxm0_cec>;
 	pinctrl-names = "default";
+	avdd-0v9-supply = <&vdda0v9_pmu>;
+	avdd-1v8-supply = <&vcca1v8_pmu>;
 	status = "okay";
 };
 
@@ -266,7 +207,7 @@ rk817: pmic@20 {
 		#sound-dai-cells = <0>;
 		pinctrl-names = "default";
 		pinctrl-0 = <&i2s1m0_mclk>, <&pmic_int_l>;
-		wakeup-source;
+		system-power-controller;
 
 		vcc1-supply = <&vcc_sys>;
 		vcc2-supply = <&vcc_sys>;
@@ -366,7 +307,6 @@ regulator-state-mem {
 
 			vccio_acodec: LDO_REG4 {
 				regulator-always-on;
-				regulator-boot-on;
 				regulator-min-microvolt = <3300000>;
 				regulator-max-microvolt = <3300000>;
 				regulator-name = "vccio_acodec";
@@ -411,7 +351,6 @@ regulator-state-mem {
 
 			vcc1v8_dvp: LDO_REG8 {
 				regulator-always-on;
-				regulator-boot-on;
 				regulator-min-microvolt = <1800000>;
 				regulator-max-microvolt = <3300000>;
 				regulator-name = "vcc1v8_dvp";
@@ -433,7 +372,6 @@ regulator-state-mem {
 
 			dcdc_boost: BOOST {
 				regulator-always-on;
-				regulator-boot-on;
 				regulator-min-microvolt = <4700000>;
 				regulator-max-microvolt = <5400000>;
 				regulator-name = "boost";
@@ -550,6 +488,13 @@ vcc_lcd_h: vcc-lcd-h {
 		};
 	};
 
+	wifi {
+		wifi_host_wake_l: wifi-host-wake-l {
+			rockchip,pins =
+				<4 RK_PA1 RK_FUNC_GPIO &pcfg_pull_down>;
+		};
+	};
+
 	vcc-wifi {
 		vcc_wifi_h: vcc-wifi-h {
 			rockchip,pins =
@@ -609,6 +554,7 @@ &sdmmc0 {
 &sdmmc1 {
 	bus-width = <4>;
 	cap-sd-highspeed;
+	card-detect-delay = <800>;
 	cd-gpios = <&gpio2 RK_PB2 GPIO_ACTIVE_LOW>;
 	disable-wp;
 	pinctrl-0 = <&sdmmc1_bus4 &sdmmc1_cmd &sdmmc1_clk &sdmmc1_det>;
@@ -620,6 +566,8 @@ &sdmmc1 {
 };
 
 &sdmmc2 {
+	#address-cells = <1>;
+	#size-cells = <0>;
 	bus-width = <4>;
 	cap-sd-highspeed;
 	cap-sdio-irq;
@@ -633,7 +581,19 @@ &sdmmc2 {
 	sd-uhs-sdr50;
 	vmmc-supply = <&vcc_wifi>;
 	vqmmc-supply = <&vcca1v8_pmu>;
+	no-mmc;
+	no-sd;
+	sd-uhs-sdr50;
 	status = "okay";
+
+	wifi@1 {
+		reg = <1>;
+		interrupt-names = "host-wake";
+		interrupt-parent = <&gpio4>;
+		interrupts = <RK_PA1 IRQ_TYPE_LEVEL_HIGH>;
+		pinctrl-0 = <&wifi_host_wake_l>;
+		pinctrl-names = "default";
+	};
 };
 
 &tsadc {
@@ -643,6 +603,7 @@ &tsadc {
 };
 
 &uart1 {
+	dma-names = "tx", "rx";
 	pinctrl-0 = <&uart1m1_xfer &uart1m1_ctsn &uart1m1_rtsn>;
 	pinctrl-names = "default";
 	uart-has-rtscts;
diff --git a/arch/arm64/boot/dts/rockchip/rk3566-miyoo-flip.dts b/arch/arm64/boot/dts/rockchip/rk3566-miyoo-flip.dts
new file mode 100644
index 000000000..91d3fc96e
--- /dev/null
+++ b/arch/arm64/boot/dts/rockchip/rk3566-miyoo-flip.dts
@@ -0,0 +1,927 @@
+// SPDX-License-Identifier: (GPL-2.0)
+/*
+ * Copyright (c) 2025 ROCKNIX (https://github.com/ROCKNIX)
+ */
+
+/dts-v1/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/linux-event-codes.h>
+#include <dt-bindings/leds/common.h>
+#include <dt-bindings/pinctrl/rockchip.h>
+#include <dt-bindings/soc/rockchip,vop2.h>
+#include "rk3566.dtsi"
+
+/ {
+	model = "Miyoo Flip";
+	chassis-type = "handset";
+	compatible = "miyoo,flip", "rockchip,rk3566";
+
+	aliases {
+		mmc1 = &sdmmc0;
+		mmc2 = &sdmmc1;
+		mmc3 = &sdmmc2;
+	};
+
+	chosen: chosen {
+		stdout-path = "serial2:1500000n8";
+	};
+
+	backlight: backlight {
+		compatible = "pwm-backlight";
+		power-supply = <&vcc_sys>;
+		pwms = <&pwm4 0 25000 0>;
+		brightness-levels = <
+			  0  20  20  21  21  22  22  23
+			 23  24  24  25  25  26  26  27
+			 27  28  28  29  29  30  30  31
+			 31  32  32  33  33  34  34  35
+			 35  36  36  37  37  38  38  39
+			 40  41  42  43  44  45  46  47
+			 48  49  50  51  52  53  54  55
+			 56  57  58  59  60  61  62  63
+			 64  65  66  67  68  69  70  71
+			 72  73  74  75  76  77  78  79
+			 80  81  82  83  84  85  86  87
+			 88  89  90  91  92  93  94  95
+			 96  97  98  99 100 101 102 103
+			104 105 106 107 108 109 110 111
+			112 113 114 115 116 117 118 119
+			120 121 122 123 124 125 126 127
+			128 129 130 131 132 133 134 135
+			136 137 138 139 140 141 142 143
+			144 145 146 147 148 149 150 151
+			152 153 154 155 156 157 158 159
+			160 161 162 163 164 165 166 167
+			168 169 170 171 172 173 174 175
+			176 177 178 179 180 181 182 183
+			184 185 186 187 188 189 190 191
+			192 193 194 195 196 197 198 199
+			200 201 202 203 204 205 206 207
+			208 209 210 211 212 213 214 215
+			216 217 218 219 220 221 222 223
+			224 225 226 227 228 229 230 231
+			232 233 234 235 236 237 238 239
+			240 241 242 243 244 245 246 247
+			248 249 250 251 252 253 254 255
+		>;
+		default-brightness-level = <128>;
+	};
+
+	battery: battery {
+		compatible = "simple-battery";
+		charge-full-design-microamp-hours = <3000000>;
+		charge-term-current-microamp = <300000>;
+		constant-charge-current-max-microamp = <2000000>;
+		constant-charge-voltage-max-microvolt = <4300000>;
+		factory-internal-resistance-micro-ohms = <117000>;
+		voltage-max-design-microvolt = <4227000>;
+		voltage-min-design-microvolt = <3400000>;
+
+		ocv-capacity-celsius = <20>;
+		ocv-capacity-table-0 =  <4227000 100>, <4186000 95>, <3970000 90>, <3920000 85>,
+					<3873000 80>, <3836000 75>, <3790000 70>, <3759000 65>,
+					<3727000 60>, <3685000 55>, <3655000 50>, <3622000 45>,
+					<3585000 40>, <3566000 35>, <3540000 30>, <3516000 25>,
+					<3495000 20>, <3470000 15>, <3450000 10>, <3420000 5>,
+					<3400000 0>;
+	};
+
+	gpio_keys_vol: gpio-keys-vol {
+		compatible = "gpio-keys";
+		autorepeat;
+		pinctrl-0 = <&btn_pins_vol>;
+		pinctrl-names = "default";
+
+		button-voldown {
+			gpios = <&gpio3 RK_PB0 GPIO_ACTIVE_LOW>;
+			label = "VOLUMEDOWN";
+			linux,code = <KEY_VOLUMEDOWN>;
+		};
+
+		button-volup {
+			gpios = <&gpio3 RK_PA7 GPIO_ACTIVE_LOW>;
+			label = "VOLUMEUP";
+			linux,code = <KEY_VOLUMEUP>;
+		};
+	};
+
+	gpio_leds: gpio-leds {
+		compatible = "gpio-leds";
+		pinctrl-names = "default";
+		pinctrl-0 = <&led_pins>;
+
+		red_led: led-0 {
+			color = <LED_COLOR_ID_RED>;
+			default-state = "off";
+			gpios = <&gpio0 RK_PC2 GPIO_ACTIVE_HIGH>;
+			function = LED_FUNCTION_STATUS;
+		};
+
+		green_led: led-1 {
+			color = <LED_COLOR_ID_GREEN>;
+			default-state = "on";
+			gpios = <&gpio0 RK_PB4 GPIO_ACTIVE_HIGH>;
+			function = LED_FUNCTION_POWER;
+		};
+	};
+
+	hdmi-con {
+		compatible = "hdmi-connector";
+		ddc-i2c-bus = <&i2c5>;
+		type = "c";
+
+		port {
+			hdmi_con_in: endpoint {
+				remote-endpoint = <&hdmi_out_con>;
+			};
+		};
+	};
+
+	joypad: rocknix-singleadc-joypad {
+		compatible = "rocknix-singleadc-joypad";
+
+		joypad-name = "retrogame_joypad";
+		joypad-product = <0x1101>;
+		joypad-revision = <0x0100>;
+		joypad-vendor = <0x484B>;
+
+		status = "okay";
+
+		/* use miyoo serial instead of adc */
+		rocknix,use-miyoo-serial-joypad;
+
+		/* gpio pincontrol setup */
+		pinctrl-names = "default";
+		pinctrl-0 = <&btn_pins_ctrl>;
+
+		/* poll device interval (ms), adc read interval */
+		poll-interval = <10>;
+
+		sw1 {
+		        gpios = <&gpio3 RK_PA3 GPIO_ACTIVE_LOW>;
+		        label = "GPIO DPAD-UP";
+		        linux,code = <BTN_DPAD_UP>;
+		};
+		sw2 {
+		        gpios = <&gpio3 RK_PA4 GPIO_ACTIVE_LOW>;
+		        label = "GPIO DPAD-DOWN";
+		        linux,code = <BTN_DPAD_DOWN>;
+		};
+		sw3 {
+		        gpios = <&gpio3 RK_PA5 GPIO_ACTIVE_LOW>;
+		        label = "GPIO DPAD-LEFT";
+		        linux,code = <BTN_DPAD_LEFT>;
+		};
+		sw4 {
+		        gpios = <&gpio3 RK_PA6 GPIO_ACTIVE_LOW>;
+		        label = "GPIO DPAD-RIGHT";
+		        linux,code = <BTN_DPAD_RIGHT>;
+		};
+		sw5 {
+		        gpios = <&gpio3 RK_PC2 GPIO_ACTIVE_LOW>;
+		        label = "GPIO KEY BTN-A";
+		        linux,code = <BTN_SOUTH>;
+		};
+		sw6 {
+		        gpios = <&gpio3 RK_PC3 GPIO_ACTIVE_LOW>;
+		        label = "GPIO BTN-B";
+		        linux,code = <BTN_EAST>;
+		};
+		sw7 {
+		        gpios = <&gpio3 RK_PC1 GPIO_ACTIVE_LOW>;
+		        label = "GPIO BTN-X";
+		        linux,code = <BTN_NORTH>;
+		};
+		sw8 {
+		        gpios = <&gpio3 RK_PC0 GPIO_ACTIVE_LOW>;
+		        label = "GPIO BTN-Y";
+		        linux,code = <BTN_WEST>;
+		};
+		sw9 {
+		        gpios = <&gpio3 RK_PB6 GPIO_ACTIVE_LOW>;
+		        label = "GPIO BTN_SELECT";
+		        linux,code = <BTN_SELECT>;
+		};
+		sw10 {
+		        gpios = <&gpio3 RK_PB5 GPIO_ACTIVE_LOW>;
+		        label = "GPIO BTN_START";
+		        linux,code = <BTN_START>;
+		};
+		sw11 {
+		        gpios = <&gpio3 RK_PA1 GPIO_ACTIVE_LOW>;
+		        label = "GPIO BTN_F";
+		        linux,code = <BTN_MODE>;
+		};
+		sw12 {
+		        gpios = <&gpio3 RK_PB1 GPIO_ACTIVE_LOW>;
+		        label = "GPIO BTN_TL";
+		        linux,code = <BTN_TL>;
+		};
+		sw13 {
+		        gpios = <&gpio3 RK_PB3 GPIO_ACTIVE_LOW>;
+		        label = "GPIO BTN_TR";
+		        linux,code = <BTN_TR>;
+		};
+		sw14 {
+		        gpios = <&gpio3 RK_PB2 GPIO_ACTIVE_LOW>;
+		        label = "GPIO BTN_TL2";
+		        linux,code = <BTN_TL2>;
+		};
+		sw15 {
+		        gpios = <&gpio3 RK_PB4 GPIO_ACTIVE_LOW>;
+		        label = "GPIO BTN_TR2";
+		        linux,code = <BTN_TR2>;
+		};
+		sw16 {
+		        gpios = <&gpio2 RK_PC1 GPIO_ACTIVE_HIGH>;
+		        label = "GPIO BTN_THUMBL";
+		        linux,code = <BTN_THUMBL>;
+		};
+		sw17 {
+		        gpios = <&gpio2 RK_PC0 GPIO_ACTIVE_HIGH>;
+		        label = "GPIO BTN_THUMBR";
+		        linux,code = <BTN_THUMBR>;
+		};
+	};
+
+	hall_sensor: hall-mh248 {
+		compatible = "hall-mh248";
+		irq-gpio = <&gpio0 RK_PC6 IRQ_TYPE_EDGE_BOTH>;
+		hall-active = <1>;
+	};
+
+	sdio_pwrseq: sdio-pwrseq {
+		compatible = "mmc-pwrseq-simple";
+		clocks = <&rk817 1>;
+		clock-names = "ext_clock";
+		pinctrl-0 = <&wifi_enable_h>;
+		pinctrl-names = "default";
+		post-power-on-delay-ms = <200>;
+		reset-gpios = <&gpio4 RK_PA2 GPIO_ACTIVE_LOW>;
+	};
+
+	/* Channels reversed for both headphones and speakers. */
+	sound {
+		compatible = "simple-audio-card";
+		pinctrl-0 = <&hp_det>;
+		pinctrl-names = "default";
+		simple-audio-card,name = "rk817_int";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,hp-det-gpio = <&gpio4 RK_PC6 GPIO_ACTIVE_LOW>;
+		simple-audio-card,mclk-fs = <256>;
+		simple-audio-card,widgets =
+			"Microphone", "Mic Jack",
+			"Headphone", "Headphones",
+			"Speaker", "Internal Speakers";
+		simple-audio-card,routing =
+			"MICL", "Mic Jack",
+			"Headphones", "HPOL",
+			"Headphones", "HPOR",
+			"Internal Speakers", "SPKO";
+
+		simple-audio-card,codec {
+			sound-dai = <&rk817>;
+		};
+
+		simple-audio-card,cpu {
+			sound-dai = <&i2s1_8ch>;
+		};
+	};
+
+	vcc5v0_host: regulator-vcc5v0-host {
+		compatible = "regulator-fixed";
+		enable-active-high;
+		gpio = <&gpio4 RK_PC5 GPIO_ACTIVE_HIGH>;
+		pinctrl-0 = <&vcc5v0_host_en>;
+		pinctrl-names = "default";
+		regulator-name = "vcc5v0_host";
+		vin-supply = <&dcdc_boost>;
+	};
+
+	vcc_lcd: regulator-vcc-lcd {
+		compatible = "regulator-fixed";
+		enable-active-high;
+		gpio = <&gpio0 RK_PC7 GPIO_ACTIVE_HIGH>;
+		pinctrl-0 = <&vcc_lcd_en>;
+		pinctrl-names = "default";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-name = "vcc_lcd";
+	};
+
+	vcc_sys: regulator-vcc-sys {
+		compatible = "regulator-fixed";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <3800000>;
+		regulator-max-microvolt = <3800000>;
+		regulator-name = "vcc_sys";
+	};
+
+	vcc_wifi: regulator-vcc-wifi {
+		compatible = "regulator-fixed";
+		gpio = <&gpio0 RK_PA0 GPIO_ACTIVE_LOW>;
+		pinctrl-0 = <&vcc_wifi_h>;
+		pinctrl-names = "default";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-name = "vcc_wifi";
+	};
+
+	vibrator: pwm-vibrator {
+		compatible = "pwm-vibrator";
+		pwm-names = "enable";
+		pwms = <&pwm5 0 1000000000 0>;
+		vcc-supply = <&vcc_3v3>;
+	};
+};
+
+&combphy1 {
+	status = "okay";
+};
+
+&cru {
+	assigned-clocks = <&pmucru CLK_RTC_32K>, <&cru PLL_GPLL>,
+			  <&pmucru PLL_PPLL>, <&cru PLL_VPLL>;
+	assigned-clock-rates = <32768>, <1200000000>,
+			       <200000000>, <126400000>;
+};
+
+&cpu0 {
+	cpu-supply = <&vdd_cpu>;
+};
+
+&cpu1 {
+	cpu-supply = <&vdd_cpu>;
+};
+
+&cpu2 {
+	cpu-supply = <&vdd_cpu>;
+};
+
+&cpu3 {
+	cpu-supply = <&vdd_cpu>;
+};
+
+&dsi_dphy0 {
+	status = "okay";
+};
+
+&dsi0 {
+	status = "okay";
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	ports {
+		dsi0_in: port@0 {
+			reg = <0>;
+			dsi0_in_vp1: endpoint {
+				remote-endpoint = <&vp1_out_dsi0>;
+			};
+		};
+
+		dsi0_out: port@1 {
+			reg = <1>;
+			mipi_out_panel: endpoint {
+				remote-endpoint = <&mipi_in_panel>;
+			};
+		};
+	};
+
+	panel: panel@0 {
+		compatible = "rocknix,generic-dsi";
+		panel_description = "G size=68,121 delays=0,160,200,200,20 format=rgb888 lanes=2 flags=0xe03", "M clock=32000 horizontal=640,150,120,120 vertical=480,20,6,12 default=1", "M clock=32000 horizontal=640,150,130,120 vertical=480,20,104,12", "M clock=32010 horizontal=640,150,157,120 vertical=480,20,88,12", "M clock=32130 horizontal=640,150,152,120 vertical=480,20,93,12", "M clock=32890 horizontal=640,150,130,120 vertical=480,20,38,12", "M clock=38050 horizontal=640,150,150,120 vertical=480,20,89,12", "M clock=33600 horizontal=640,150,168,120 vertical=480,20,8,12", "M clock=32760 horizontal=640,150,140,120 vertical=480,20,8,12", "M clock=32750 horizontal=640,150,126,120 vertical=480,20,14,12", "M clock=43580 horizontal=640,150,138,120 vertical=480,20,39,12", "M clock=49140 horizontal=640,150,140,120 vertical=480,20,8,12", "M clock=64890 horizontal=640,150,120,120 vertical=480,20,13,12", "I seq=11 wait=250", "I seq=29 wait=32", "I seq=b9f11287", "I seq=b2780470", "I seq=b31010282803ff00000000", "I seq=b480", "I seq=b50a0a", "I seq=b82622f013", "I seq=ba318105f90e0e2000000000000000442500910a0000014f01000037", "I seq=bc47", "I seq=bf0211008004", "I seq=c0737350500000127300", "I seq=c17300323277f47777ccccffff1111000032", "I seq=c710000a0000000000edc500a5", "I seq=c810401e03", "I seq=cc0b", "I seq=e0000509293c3f3b37050a0c10131013121a000509293c3f3b37050a0c10131013121a", "I seq=e111119100000000", "I seq=e307070b0b0b0b00000000ff04c010", "I seq=e9c810020000b0b11131232880b0b127080004020000000004020000008888ba60240888888888888888ba713518888888888800000001000000000000000000", "I seq=ea970a820203070000000000008188ba17538888888888888088ba064288888888888823000002a500000000000000000000000000000000000000000000", "I seq=efffff01";
+		reg = <0>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&lcd_rst>;
+		reset-gpios = <&gpio4 RK_PA0 GPIO_ACTIVE_LOW>;
+		backlight = <&backlight>;
+		iovcc-supply = <&vcc_lcd>;
+		vdd-supply = <&vcc_lcd>;
+
+		port {
+			mipi_in_panel: endpoint {
+				remote-endpoint = <&mipi_out_panel>;
+			};
+		};
+	};
+};
+
+&gpu {
+	mali-supply = <&vdd_gpu>;
+	status = "okay";
+};
+
+&hdmi {
+	ddc-i2c-bus = <&i2c5>;
+	pinctrl-0 = <&hdmitxm0_cec>;
+	pinctrl-names = "default";
+	status = "okay";
+};
+
+&hdmi_in {
+	hdmi_in_vp0: endpoint {
+		remote-endpoint = <&vp0_out_hdmi>;
+	};
+};
+
+&hdmi_out {
+	hdmi_out_con: endpoint {
+		remote-endpoint = <&hdmi_con_in>;
+	};
+};
+
+&hdmi_sound {
+	status = "okay";
+};
+
+&i2c0 {
+	status = "okay";
+
+	rk817: pmic@20 {
+		compatible = "rockchip,rk817";
+		reg = <0x20>;
+		assigned-clocks = <&cru I2S1_MCLKOUT_TX>;
+		assigned-clock-parents = <&cru CLK_I2S1_8CH_TX>;
+		clock-names = "mclk";
+		clock-output-names = "rk808-clkout1", "rk808-clkout2";
+		clocks = <&cru I2S1_MCLKOUT_TX>;
+		interrupt-parent = <&gpio0>;
+		interrupts = <RK_PA3 IRQ_TYPE_LEVEL_LOW>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2s1m0_mclk>, <&pmic_int_l>;
+		system-power-controller;
+		#clock-cells = <1>;
+		#sound-dai-cells = <0>;
+
+		vcc1-supply = <&vcc_sys>;
+		vcc2-supply = <&vcc_sys>;
+		vcc3-supply = <&vcc_sys>;
+		vcc4-supply = <&vcc_sys>;
+		vcc5-supply = <&vcc_sys>;
+		vcc6-supply = <&vcc_sys>;
+		vcc7-supply = <&vcc_sys>;
+		vcc8-supply = <&vcc_sys>;
+		vcc9-supply = <&dcdc_boost>;
+
+		regulators {
+			vdd_logic: DCDC_REG1 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-ramp-delay = <6001>;
+				regulator-initial-mode = <0x2>;
+				regulator-name = "vdd_logic";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+					regulator-suspend-microvolt = <900000>;
+				};
+			};
+
+			vdd_gpu: DCDC_REG2 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-ramp-delay = <6001>;
+				regulator-initial-mode = <0x2>;
+				regulator-name = "vdd_gpu";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcc_ddr: DCDC_REG3 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-initial-mode = <0x2>;
+				regulator-name = "vcc_ddr";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+				};
+			};
+
+			vcc_3v3: DCDC_REG4 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-initial-mode = <0x2>;
+				regulator-name = "vcc_3v3";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <3300000>;
+				};
+			};
+
+			vcca1v8_pmu: LDO_REG1 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-name = "vcca1v8_pmu";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <1800000>;
+				};
+			};
+
+			vdda_0v9: LDO_REG2 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <900000>;
+				regulator-max-microvolt = <900000>;
+				regulator-name = "vdda_0v9";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vdda0v9_pmu: LDO_REG3 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <900000>;
+				regulator-max-microvolt = <900000>;
+				regulator-name = "vdda0v9_pmu";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <900000>;
+				};
+			};
+
+			vccio_acodec: LDO_REG4 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-name = "vccio_acodec";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vccio_sd: LDO_REG5 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-name = "vccio_sd";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcc3v3_pmu: LDO_REG6 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-name = "vcc3v3_pmu";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <3300000>;
+				};
+			};
+
+			vcc_1v8: LDO_REG7 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-name = "vcc_1v8";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcc1v8_dvp: LDO_REG8 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-name = "vcc1v8_dvp";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+				};
+			};
+
+			vcc2v8_dvp: LDO_REG9 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-name = "vcc2v8_dvp";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			dcdc_boost: BOOST {
+				regulator-min-microvolt = <4700000>;
+				regulator-max-microvolt = <5400000>;
+				regulator-name = "boost";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			otg_switch: OTG_SWITCH {
+				regulator-name = "otg_switch";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+		};
+
+		rk817_charger: charger {
+			monitored-battery = <&battery>;
+			rockchip,resistor-sense-micro-ohms = <10000>;
+			rockchip,sleep-enter-current-microamp = <150000>;
+			rockchip,sleep-filter-current-microamp = <100000>;
+		};
+
+	};
+
+	vdd_cpu: regulator@1c {
+		compatible = "tcs,tcs4525";
+		reg = <0x1c>;
+		fcs,suspend-voltage-selector = <1>;
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <712500>;
+		regulator-max-microvolt = <1390000>;
+		regulator-name = "vdd_cpu";
+		regulator-ramp-delay = <2300>;
+		vin-supply = <&vcc_sys>;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+};
+
+&i2c5 {
+	pinctrl-0 = <&i2c5m1_xfer>;
+	pinctrl-names = "default";
+	status = "okay";
+};
+
+&i2s0_8ch {
+	status = "okay";
+};
+
+&i2s1_8ch {
+	pinctrl-0 = <&i2s1m0_sclktx>, <&i2s1m0_lrcktx>, <&i2s1m0_sdi0>,
+		    <&i2s1m0_sdo0>;
+	pinctrl-names = "default";
+	rockchip,trcm-sync-tx-only;
+	status = "okay";
+};
+
+&pinctrl {
+	gpio-control {
+		btn_pins_ctrl: btn-pins-ctrl {
+			rockchip,pins =
+				<2 RK_PC0 RK_FUNC_GPIO &pcfg_pull_down>,
+				<2 RK_PC1 RK_FUNC_GPIO &pcfg_pull_down>,
+				<3 RK_PA1 RK_FUNC_GPIO &pcfg_pull_up>,
+				<3 RK_PA3 RK_FUNC_GPIO &pcfg_pull_up>,
+				<3 RK_PA4 RK_FUNC_GPIO &pcfg_pull_up>,
+				<3 RK_PA5 RK_FUNC_GPIO &pcfg_pull_up>,
+				<3 RK_PA6 RK_FUNC_GPIO &pcfg_pull_up>,
+				<3 RK_PB1 RK_FUNC_GPIO &pcfg_pull_up>,
+				<3 RK_PB2 RK_FUNC_GPIO &pcfg_pull_up>,
+				<3 RK_PB3 RK_FUNC_GPIO &pcfg_pull_up>,
+				<3 RK_PB4 RK_FUNC_GPIO &pcfg_pull_up>,
+				<3 RK_PB5 RK_FUNC_GPIO &pcfg_pull_up>,
+				<3 RK_PB6 RK_FUNC_GPIO &pcfg_pull_up>,
+				<3 RK_PC0 RK_FUNC_GPIO &pcfg_pull_up>,
+				<3 RK_PC1 RK_FUNC_GPIO &pcfg_pull_up>,
+				<3 RK_PC2 RK_FUNC_GPIO &pcfg_pull_up>,
+				<3 RK_PC3 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+
+		btn_pins_vol: btn-pins-vol {
+			rockchip,pins =
+				<3 RK_PA7 RK_FUNC_GPIO &pcfg_pull_up>,
+				<3 RK_PB0 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	gpio-lcd {
+		lcd_rst: lcd-rst {
+			rockchip,pins =
+				<4 RK_PA0 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	gpio-leds {
+		led_pins: led-pins {
+			rockchip,pins =
+				<0 RK_PB4 RK_FUNC_GPIO &pcfg_pull_none>,
+				<0 RK_PC2 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	hp-detect {
+		hp_det: hp-det {
+			rockchip,pins =
+				<4 RK_PC6 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	pmic {
+		pmic_int_l: pmic-int-l {
+			rockchip,pins =
+				<0 RK_PA3 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	sdio-pwrseq {
+		wifi_enable_h: wifi-enable-h {
+			rockchip,pins =
+				<4 RK_PA2 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	usb {
+		vcc5v0_host_en: vcc5v0-host-en {
+			rockchip,pins =
+				<4 RK_PC5 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		vcc5v0_otg_en: vcc5v0-otg-en {
+			rockchip,pins =
+				<4 RK_PC5 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	vcc-lcd {
+		vcc_lcd_en: vcc-lcd-en {
+			rockchip,pins =
+				<0 RK_PC7 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	vcc-wifi {
+		vcc_wifi_h: vcc-wifi-h {
+			rockchip,pins =
+				<0 RK_PA0 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+};
+
+&pmu_io_domains {
+	status = "okay";
+	pmuio1-supply = <&vcc3v3_pmu>;
+	pmuio2-supply = <&vcca1v8_pmu>;
+	vccio1-supply = <&vccio_acodec>;
+	vccio2-supply = <&vcc_1v8>;
+	vccio3-supply = <&vccio_sd>;
+	vccio4-supply = <&vcca1v8_pmu>;
+	vccio5-supply = <&vcc2v8_dvp>;
+	vccio6-supply = <&vcc1v8_dvp>;
+	vccio7-supply = <&vcc_3v3>;
+};
+
+&pwm4 {
+	status = "okay";
+};
+
+&pwm5 {
+	status = "okay";
+};
+
+&sdmmc0 {
+	bus-width = <4>;
+	cap-mmc-highspeed;
+	cap-sd-highspeed;
+	disable-wp;
+	pinctrl-0 = <&sdmmc0_bus4>, <&sdmmc0_clk>, <&sdmmc0_cmd>,
+		    <&sdmmc0_det>;
+	pinctrl-names = "default";
+	sd-uhs-sdr104;
+	vmmc-supply = <&vcc_3v3>;
+	vqmmc-supply = <&vccio_sd>;
+	status = "okay";
+};
+
+&sdmmc1 {
+	bus-width = <4>;
+	cap-mmc-highspeed;
+	cap-sd-highspeed;
+	disable-wp;
+	pinctrl-0 = <&sdmmc1_bus4>, <&sdmmc1_cmd>, <&sdmmc1_clk>,
+		    <&sdmmc1_det>;
+	pinctrl-names = "default";
+	sd-uhs-sdr104;
+	vmmc-supply = <&vcc_3v3>;
+	vqmmc-supply = <&vcc2v8_dvp>;
+	status = "okay";
+};
+
+&sdmmc2 {
+	bus-width = <4>;
+	cap-sd-highspeed;
+	cap-sdio-irq;
+	keep-power-in-suspend;
+	mmc-pwrseq = <&sdio_pwrseq>;
+	no-mmc;
+	no-sd;
+	non-removable;
+	pinctrl-0 = <&sdmmc2m0_bus4>, <&sdmmc2m0_cmd>, <&sdmmc2m0_clk>;
+	pinctrl-names = "default";
+	vmmc-supply = <&vcc_wifi>;
+	vqmmc-supply = <&vcca1v8_pmu>;
+	status = "okay";
+};
+
+&sfc {
+	status = "okay";
+
+	flash@0 {
+		compatible = "spi-nand";
+		reg = <0>;
+		spi-max-frequency = <75000000>;
+		spi-rx-bus-width = <4>;
+		spi-tx-bus-width = <1>;
+	};
+};
+
+&uart1 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart1m0_xfer &uart1m0_ctsn>;
+};
+
+&usb_host0_xhci {
+	dr_mode = "peripheral";
+	phys = <&usb2phy0_otg>;
+	phy-names = "usb2-phy";
+	status = "okay";
+};
+
+&usb_host1_ehci {
+	status = "okay";
+};
+
+&usb_host1_ohci {
+	status = "okay";
+};
+
+&usb_host1_xhci {
+	phy-names = "usb2-phy", "usb3-phy";
+	phys = <&usb2phy1_host>, <&combphy1 PHY_TYPE_USB3>;
+	status = "okay";
+};
+
+&usb2phy0 {
+	status = "okay";
+};
+
+&usb2phy0_host {
+	status = "okay";
+};
+
+&usb2phy0_otg {
+	status = "okay";
+};
+
+&usb2phy1 {
+	status = "okay";
+};
+
+&usb2phy1_host {
+	status = "okay";
+};
+
+&usb2phy0_otg {
+	status = "okay";
+};
+
+&vop {
+	assigned-clocks = <&cru DCLK_VOP0>, <&cru DCLK_VOP1>;
+	assigned-clock-parents = <&pmucru PLL_HPLL>, <&cru PLL_VPLL>;
+	status = "okay";
+};
+
+&vop_mmu {
+	status = "okay";
+};
+
+&vp0 {
+	vp0_out_hdmi: endpoint@ROCKCHIP_VOP2_EP_HDMI0 {
+		reg = <ROCKCHIP_VOP2_EP_HDMI0>;
+		remote-endpoint = <&hdmi_in_vp0>;
+	};
+};
+
+&vp1 {
+	vp1_out_dsi0: endpoint@ROCKCHIP_VOP2_EP_MIPI0 {
+		reg = <ROCKCHIP_VOP2_EP_MIPI0>;
+		remote-endpoint = <&dsi0_in_vp1>;
+	};
+};
diff --git a/arch/arm64/boot/dts/rockchip/rk3566-powkiddy-rgb10max3.dts b/arch/arm64/boot/dts/rockchip/rk3566-powkiddy-rgb10max3.dts
index e5a474e68..1cd89a640 100644
--- a/arch/arm64/boot/dts/rockchip/rk3566-powkiddy-rgb10max3.dts
+++ b/arch/arm64/boot/dts/rockchip/rk3566-powkiddy-rgb10max3.dts
@@ -85,3 +85,26 @@ &red_led {
 	default-state = "off";
 	function = LED_FUNCTION_STATUS;
 };
+
+&joypad {
+	sw12 {
+		gpios = <&gpio3 RK_PB2 GPIO_ACTIVE_LOW>;
+		label = "GPIO BTN_TL";
+		linux,code = <BTN_TL>;
+	};
+	sw13 {
+		gpios = <&gpio3 RK_PB4 GPIO_ACTIVE_LOW>;
+		label = "GPIO BTN_TR";
+		linux,code = <BTN_TR>;
+	};
+	sw14 {
+		gpios = <&gpio3 RK_PB1 GPIO_ACTIVE_LOW>;
+		label = "GPIO BTN_TL2";
+		linux,code = <BTN_TL2>;
+	};
+	sw15 {
+		gpios = <&gpio3 RK_PB3 GPIO_ACTIVE_LOW>;
+		label = "GPIO BTN_TR2";
+		linux,code = <BTN_TR2>;
+	};
+};
diff --git a/arch/arm64/boot/dts/rockchip/rk3566-powkiddy-rgb20-pro.dts b/arch/arm64/boot/dts/rockchip/rk3566-powkiddy-rgb20-pro.dts
new file mode 100644
index 000000000..11c6f53be
--- /dev/null
+++ b/arch/arm64/boot/dts/rockchip/rk3566-powkiddy-rgb20-pro.dts
@@ -0,0 +1,95 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2024-present ROCKNIX (https://github.com/ROCKNIX)
+ */
+
+/dts-v1/;
+
+#include "rk3566-powkiddy-rk2023.dts"
+
+/ {
+	compatible = "powkiddy,rgb20-pro", "rockchip,rk3566";
+	model = "Powkiddy RGB20 Pro";
+};
+
+&battery {
+	charge-full-design-microamp-hours = <5000000>;
+	factory-internal-resistance-micro-ohms = <110000>;
+	voltage-max-design-microvolt = <4148000>;
+	voltage-min-design-microvolt = <3500000>;
+
+	ocv-capacity-table-0 =  <4148000 100>, <4076000 95>, <4056000 90>, <40410000 85>,
+				<4030000 80>, <4015000 75>, <3993000 70>, <3964000 65>,
+				<3929000 60>, <3889000 55>, <3864000 50>, <3846000 45>,
+				<3827000 40>, <3806000 35>, <3780000 30>, <3740000 25>,
+				<3687000 20>, <3636000 15>, <3592000 10>, <3548000 5>,
+				<3500000 0>;
+};
+
+&cru {
+	assigned-clocks = <&pmucru CLK_RTC_32K>, <&cru PLL_GPLL>,
+			  <&pmucru PLL_PPLL>, <&cru PLL_VPLL>;
+	assigned-clock-rates = <32768>, <1200000000>,
+			       <200000000>, <102000000>;
+};
+
+&dsi0 {
+        panel: panel@0 {
+		compatible = "rocknix,generic-dsi";
+		panel_description =
+			"G size=65,49 delays=200,150,36,36,20 format=rgb888 lanes=4 flags=0xe03",
+
+			"M clock=51072 horizontal=1024,20,4,20 vertical=768,15,3,11 default=1",
+			"M clock=51312 horizontal=1024,20,30,20 vertical=768,15,145,11",
+			"M clock=51072 horizontal=1024,20,56,20 vertical=768,15,118,11",
+			"M clock=52162 horizontal=1024,20,54,20 vertical=768,15,139,11",
+			"M clock=51152 horizontal=1024,20,48,20 vertical=768,15,6,11",
+			"M clock=62932 horizontal=1024,20,29,20 vertical=768,15,170,11",
+			"M clock=59842 horizontal=1024,20,20,20 vertical=768,15,127,11",
+			"M clock=51312 horizontal=1024,20,5,20 vertical=768,15,6,11",
+			"M clock=54600 horizontal=1024,20,48,20 vertical=768,15,23,11",
+			"M clock=65390 horizontal=1024,20,15,20 vertical=768,15,9,11",
+			"M clock=77040 horizontal=1024,20,6,20 vertical=768,15,6,11",
+			"M clock=102720 horizontal=1024,20,6,20 vertical=768,15,6,11",
+
+			"I seq=df9168f9",
+			"I seq=de00",
+			"I seq=b2007e",
+			"I seq=b3007e",
+			"I seq=c1001000000000",
+			"I seq=bb02240761194444",
+			"I seq=be1af2",
+			"I seq=c310175a175a0505050515153105df",
+			"I seq=c4118000df090614",
+			"I seq=ce0003030303030303030303030303030303030303030f03",
+			"I seq=cf00014001ca01ca01ca",
+			"I seq=d0001f1f1f1f1f1f1f1f1f1f03010507090b1e151f1f151f",
+			"I seq=d1001f1f1f1f1f1f1f1f1f1f02000406080a1e151f1f151f",
+			"I seq=d2001f1f1f1f1f1f1f1f1f1f00020a0806041f151f1f151e",
+			"I seq=d3001f1f1f1f1f1f1f1f1f1f01030b0907051f151f1f151e",
+			"I seq=d43000000400060000000000030300110001c0040101118001c00501010000000400061802e3",
+			"I seq=d56873000808000300",
+			"I seq=b700d80000d800",
+			"I seq=c87f695a4e4a3b402a4443446351594c483a280f7f695a4e4a3b402a4443446351594c483a280f",
+			"I seq=de02",
+			"I seq=bb005b5c41",
+			"I seq=b5005a0a",
+			"I seq=c622",
+			"I seq=d712",
+			"I seq=de00",
+			"I seq=3500",
+			"I seq=11 wait=250",
+			"I seq=29 wait=250";
+        };
+};
+
+&joypad {
+	pwms = <&pwm5 0 1000000000 0>;
+	pwm-names = "enable";
+	rumble-boost-weak = <0x0000>;
+	rumble-boost-strong = <0x0000>;
+};
+
+&pwm5 {
+	status = "okay";
+};
diff --git a/arch/arm64/boot/dts/rockchip/rk3566-powkiddy-rk2023.dtsi b/arch/arm64/boot/dts/rockchip/rk3566-powkiddy-rk2023.dtsi
index bd332714a..03be01c3a 100644
--- a/arch/arm64/boot/dts/rockchip/rk3566-powkiddy-rk2023.dtsi
+++ b/arch/arm64/boot/dts/rockchip/rk3566-powkiddy-rk2023.dtsi
@@ -18,65 +18,48 @@ aliases {
 		mmc3 = &sdmmc2;
 	};
 
-	adc-joystick {
-		compatible = "adc-joystick";
-		io-channels = <&adc_mux 0>,
-			      <&adc_mux 1>,
-			      <&adc_mux 2>,
-			      <&adc_mux 3>;
-		pinctrl-0 = <&joy_mux_en>;
-		pinctrl-names = "default";
-		poll-interval = <60>;
-		#address-cells = <1>;
-		#size-cells = <0>;
-
-		axis@0 {
-			reg = <0>;
-			abs-flat = <32>;
-			abs-fuzz = <32>;
-			abs-range = <1023 15>;
-			linux,code = <ABS_X>;
-		};
-
-		axis@1 {
-			reg = <1>;
-			abs-flat = <32>;
-			abs-fuzz = <32>;
-			abs-range = <15 1023>;
-			linux,code = <ABS_RX>;
-		};
-
-		axis@2 {
-			reg = <2>;
-			abs-flat = <32>;
-			abs-fuzz = <32>;
-			abs-range = <15 1023>;
-			linux,code = <ABS_Y>;
-		};
-
-		axis@3 {
-			reg = <3>;
-			abs-flat = <32>;
-			abs-fuzz = <32>;
-			abs-range = <1023 15>;
-			linux,code = <ABS_RY>;
-		};
-	};
-
-	adc_mux: adc-mux {
-		compatible = "io-channel-mux";
-		channels = "left_x", "right_x", "left_y", "right_y";
-		#io-channel-cells = <1>;
-		io-channels = <&saradc 3>;
-		io-channel-names = "parent";
-		mux-controls = <&gpio_mux>;
-		settle-time-us = <100>;
+	chosen: chosen {
+		stdout-path = "serial2:1500000n8";
 	};
 
 	backlight: backlight {
 		compatible = "pwm-backlight";
 		power-supply = <&vcc_sys>;
 		pwms = <&pwm4 0 25000 0>;
+		brightness-levels = <
+			  0   1   2   3   4   5   6   7
+			  8   9  10  11  12  13  14  15
+			 16  17  18  19  20  21  22  23
+			 24  25  26  27  28  29  30  31
+			 32  33  34  35  36  37  38  39
+			 40  41  42  43  44  45  46  47
+			 48  49  50  51  52  53  54  55
+			 56  57  58  59  60  61  62  63
+			 64  65  66  67  68  69  70  71
+			 72  73  74  75  76  77  78  79
+			 80  81  82  83  84  85  86  87
+			 88  89  90  91  92  93  94  95
+			 96  97  98  99 100 101 102 103
+			104 105 106 107 108 109 110 111
+			112 113 114 115 116 117 118 119
+			120 121 122 123 124 125 126 127
+			128 129 130 131 132 133 134 135
+			136 137 138 139 140 141 142 143
+			144 145 146 147 148 149 150 151
+			152 153 154 155 156 157 158 159
+			160 161 162 163 164 165 166 167
+			168 169 170 171 172 173 174 175
+			176 177 178 179 180 181 182 183
+			184 185 186 187 188 189 190 191
+			192 193 194 195 196 197 198 199
+			200 201 202 203 204 205 206 207
+			208 209 210 211 212 213 214 215
+			216 217 218 219 220 221 222 223
+			224 225 226 227 228 229 230 231
+			232 233 234 235 236 237 238 239
+			240 241 242 243 244 245 246 247
+			248 249 250 251 252 253 254 255>;
+		default-brightness-level = <77>;
 	};
 
 	battery: battery {
@@ -98,106 +81,159 @@ battery: battery {
 					<3400000 0>;
 	};
 
-	gpio_keys_control: gpio-keys-control {
-		compatible = "gpio-keys";
-		pinctrl-0 = <&btn_pins_ctrl>;
+	joypad: rocknix-singleadc-joypad {
+		compatible = "rocknix-singleadc-joypad";
+
+		joypad-name = "retrogame_joypad";
+		joypad-product = <0x1101>;
+		joypad-revision = <0x0100>;
+		joypad-vendor = <0x484B>;
+
+		status = "okay";
+
+		/* gpio pincontrol setup */
 		pinctrl-names = "default";
+		pinctrl-0 = <&btn_pins_ctrl>;
 
-		button-a {
-			gpios = <&gpio3 RK_PC2 GPIO_ACTIVE_LOW>;
-			label = "EAST";
-			linux,code = <BTN_EAST>;
-		};
+		/* Analog mux define */
+		io-channel-names = "amux_adc";
+		io-channels = <&saradc 3>;
 
-		button-b {
-			gpios = <&gpio3 RK_PC3 GPIO_ACTIVE_LOW>;
-			label = "SOUTH";
-			linux,code = <BTN_SOUTH>;
+		/* adc mux channel count */
+		amux-count = <4>;
+		/* adc mux select(a,b) gpio */
+		amux-a-gpios = <&gpio0 RK_PB6 GPIO_ACTIVE_LOW>;
+		amux-b-gpios = <&gpio0 RK_PB7 GPIO_ACTIVE_LOW>;
+		/* adc mux enable gpio */
+		amux-en-gpios = <&gpio0 RK_PB5 GPIO_ACTIVE_LOW>;
+
+		/* adc calculate scale */
+		button-adc-scale = <2>;
+
+
+		/* adc deadzone range  */
+		button-adc-deadzone = <64>;
+
+		/*
+		  specifies fuzz value that is used to filter noise from
+		  the event stream.
+		*/
+		button-adc-fuzz = <32>;
+		button-adc-flat = <32>;
+
+		/*
+		  Analog Stick data tuning value(precent)
+		  p = positive direction, n = negative direction
+		  report value = (real_adc_data * tuning_value) / 100
+		*/
+		abs_x-p-tuning = <245>;
+		abs_x-n-tuning = <245>;
+
+		abs_y-p-tuning = <245>;
+		abs_y-n-tuning = <245>;
+
+		abs_rx-p-tuning = <245>;
+		abs_rx-n-tuning = <245>;
+
+		abs_ry-p-tuning = <245>;
+		abs_ry-n-tuning = <245>;
+
+		/* poll device interval (ms), adc read interval */
+		poll-interval = <10>;
+
+		/* required to invert x/y */
+		invert-absx;
+		invert-absy;
+
+		/* gpio button auto repeat set value : default disable */
+		/*
+			autorepeat;
+		*/
+		sw1 {
+			gpios = <&gpio3 RK_PA3 GPIO_ACTIVE_LOW>;
+			label = "GPIO DPAD-UP";
+			linux,code = <BTN_DPAD_UP>;
 		};
-
-		button-down {
+		sw2 {
 			gpios = <&gpio3 RK_PA4 GPIO_ACTIVE_LOW>;
-			label = "DPAD-DOWN";
+			label = "GPIO DPAD-DOWN";
 			linux,code = <BTN_DPAD_DOWN>;
 		};
-
-		button-l1 {
-			gpios = <&gpio3 RK_PB1 GPIO_ACTIVE_LOW>;
-			label = "TL";
-			linux,code = <BTN_TL>;
-		};
-
-		button-l2 {
-			gpios = <&gpio3 RK_PB2 GPIO_ACTIVE_LOW>;
-			label = "TL2";
-			linux,code = <BTN_TL2>;
-		};
-
-		button-left {
+		sw3 {
 			gpios = <&gpio3 RK_PA6 GPIO_ACTIVE_LOW>;
-			label = "DPAD-LEFT";
+			label = "GPIO DPAD-LEFT";
 			linux,code = <BTN_DPAD_LEFT>;
 		};
-
-		button-r1 {
-			gpios = <&gpio3 RK_PB3 GPIO_ACTIVE_LOW>;
-			label = "TR";
-			linux,code = <BTN_TR>;
-		};
-
-		button-r2 {
-			gpios = <&gpio3 RK_PB4 GPIO_ACTIVE_LOW>;
-			label = "TR2";
-			linux,code = <BTN_TR2>;
-		};
-
-		button-right {
+		sw4 {
 			gpios = <&gpio3 RK_PA5 GPIO_ACTIVE_LOW>;
-			label = "DPAD-RIGHT";
+			label = "GPIO DPAD-RIGHT";
 			linux,code = <BTN_DPAD_RIGHT>;
 		};
-
-		button-select {
+		sw5 {
+			gpios = <&gpio3 RK_PC3 GPIO_ACTIVE_LOW>;
+			label = "GPIO KEY BTN-A";
+			linux,code = <BTN_SOUTH>;
+		};
+		sw6 {
+			gpios = <&gpio3 RK_PC2 GPIO_ACTIVE_LOW>;
+			label = "GPIO BTN-B";
+			linux,code = <BTN_EAST>;
+		};
+		sw7 {
+			gpios = <&gpio3 RK_PC0 GPIO_ACTIVE_LOW>;
+			label = "GPIO BTN-X";
+			linux,code = <BTN_NORTH>;
+		};
+		sw8 {
+			gpios = <&gpio3 RK_PC1 GPIO_ACTIVE_LOW>;
+			label = "GPIO BTN-Y";
+			linux,code = <BTN_WEST>;
+		};
+		sw9 {
 			gpios = <&gpio3 RK_PB6 GPIO_ACTIVE_LOW>;
-			label = "SELECT";
+			label = "GPIO BTN_SELECT";
 			linux,code = <BTN_SELECT>;
 		};
-
-		button-start {
+		sw10 {
 			gpios = <&gpio3 RK_PB5 GPIO_ACTIVE_LOW>;
-			label = "START";
+			label = "GPIO BTN_START";
 			linux,code = <BTN_START>;
 		};
-
-		button-thumbl {
+		sw11 {
+			gpios = <&gpio3 RK_PB7 GPIO_ACTIVE_LOW>;
+			label = "GPIO BTN_F";
+			linux,code = <BTN_MODE>;
+		};
+		sw12 {
+			gpios = <&gpio3 RK_PB1 GPIO_ACTIVE_LOW>;
+			label = "GPIO BTN_TL";
+			linux,code = <BTN_TL>;
+		};
+		sw13 {
+			gpios = <&gpio3 RK_PB3 GPIO_ACTIVE_LOW>;
+			label = "GPIO BTN_TR";
+			linux,code = <BTN_TR>;
+		};
+		sw14 {
+			gpios = <&gpio3 RK_PB2 GPIO_ACTIVE_LOW>;
+			label = "GPIO BTN_TL2";
+			linux,code = <BTN_TL2>;
+		};
+		sw15 {
+			gpios = <&gpio3 RK_PB4 GPIO_ACTIVE_LOW>;
+			label = "GPIO BTN_TR2";
+			linux,code = <BTN_TR2>;
+		};
+		sw16 {
 			gpios = <&gpio3 RK_PA1 GPIO_ACTIVE_LOW>;
-			label = "THUMBL";
+			label = "GPIO BTN_THUMBL";
 			linux,code = <BTN_THUMBL>;
 		};
-
-		button-thumbr {
+		sw17 {
 			gpios = <&gpio3 RK_PA2 GPIO_ACTIVE_LOW>;
-			label = "THUMBR";
+			label = "GPIO BTN_THUMBR";
 			linux,code = <BTN_THUMBR>;
 		};
-
-		button-up {
-			gpios = <&gpio3 RK_PA3 GPIO_ACTIVE_LOW>;
-			label = "DPAD-UP";
-			linux,code = <BTN_DPAD_UP>;
-		};
-
-		button-x {
-			gpios = <&gpio3 RK_PC0 GPIO_ACTIVE_LOW>;
-			label = "NORTH";
-			linux,code = <BTN_NORTH>;
-		};
-
-		button-y {
-			gpios = <&gpio3 RK_PC1 GPIO_ACTIVE_LOW>;
-			label = "WEST";
-			linux,code = <BTN_WEST>;
-		};
 	};
 
 	gpio_keys_vol: gpio-keys-vol {
@@ -219,13 +255,6 @@ button-vol-up {
 		};
 	};
 
-	gpio_mux: mux-controller {
-		compatible = "gpio-mux";
-		mux-gpios = <&gpio0 RK_PB6 GPIO_ACTIVE_LOW>,
-			    <&gpio0 RK_PB7 GPIO_ACTIVE_LOW>;
-		#mux-control-cells = <0>;
-	};
-
 	hdmi-con {
 		compatible = "hdmi-connector";
 		ddc-i2c-bus = <&i2c5>;
@@ -425,7 +454,7 @@ rk817: pmic@20 {
 		#sound-dai-cells = <0>;
 		pinctrl-names = "default";
 		pinctrl-0 = <&i2s1m0_mclk>, <&pmic_int_l>;
-		wakeup-source;
+		system-power-controller;
 
 		vcc1-supply = <&vcc_sys>;
 		vcc2-supply = <&vcc_sys>;
@@ -755,6 +784,7 @@ &sdmmc0 {
 &sdmmc1 {
 	bus-width = <4>;
 	cap-sd-highspeed;
+	card-detect-delay = <800>;
 	cd-gpios = <&gpio2 RK_PB2 GPIO_ACTIVE_LOW>;
 	disable-wp;
 	pinctrl-0 = <&sdmmc1_bus4 &sdmmc1_cmd &sdmmc1_clk &sdmmc1_det>;
@@ -776,6 +806,9 @@ &sdmmc2 {
 	pinctrl-names = "default";
 	vmmc-supply = <&vcc_wifi>;
 	vqmmc-supply = <&vcca1v8_pmu>;
+	no-mmc;
+	no-sd;
+	sd-uhs-sdr50;
 	status = "okay";
 };
 
@@ -799,6 +832,10 @@ bluetooth: bluetooth {
 	};
 };
 
+&uart2 {
+	status = "okay";
+};
+
 &usb_host0_xhci {
 	dr_mode = "peripheral";
 	phys = <&usb2phy0_otg>;
diff --git a/arch/arm64/boot/dts/rockchip/rk3566-powkiddy-x35s.dts b/arch/arm64/boot/dts/rockchip/rk3566-powkiddy-x35s.dts
new file mode 100644
index 000000000..bca48d258
--- /dev/null
+++ b/arch/arm64/boot/dts/rockchip/rk3566-powkiddy-x35s.dts
@@ -0,0 +1,37 @@
+#include "rk3566-powkiddy-x55.dts"
+
+/ {
+	model = "Powkiddy x35s";
+	compatible = "powkiddy,x35s", "rockchip,rk3566";
+};
+
+&battery {
+	charge-full-design-microamp-hours = <3000000>;
+};
+
+&joypad {
+	invert-absx;
+	invert-absy;
+	sw5 {
+		label = "GPIO BTN-B";
+		linux,code = <BTN_SOUTH>;
+	};
+	sw6 {
+		label = "GPIO BTN-A";
+		linux,code = <BTN_EAST>;
+	};
+	sw7 {
+		label = "GPIO BTN-X";
+		linux,code = <BTN_NORTH>;
+	};
+	sw8 {
+		label = "GPIO BTN-Y";
+		linux,code = <BTN_WEST>;
+	};
+};
+
+&panel {
+	compatible = "rocknix,generic-dsi";
+	panel_description = "G size=70,52 delays=60,60,60,120,20 format=rgb888 lanes=4 flags=0xe03", "M clock=30000 horizontal=640,150,50,150 vertical=480,20,6,12 default=1 # fps=58.500059 (target=58.500059)", "M clock=30000 horizontal=640,150,61,150 vertical=480,20,88,12 # fps=49.950050 (target=49.950050)", "M clock=30000 horizontal=640,150,60,150 vertical=480,20,88,12 # fps=50.000000 (target=50.000000)", "M clock=30010 horizontal=640,150,72,150 vertical=480,20,81,12 # fps=50.006999 (target=50.007000)", "M clock=30130 horizontal=640,150,60,150 vertical=480,20,12,12 # fps=57.500000 (target=57.500000)", "M clock=35920 horizontal=640,150,59,150 vertical=480,20,90,12 # (CAN FAIL) fps=59.727502 (target=59.727500)", "M clock=31440 horizontal=640,150,61,150 vertical=480,20,12,12 # (CAN FAIL) fps=59.940060 (target=59.940060)", "M clock=31080 horizontal=640,150,60,150 vertical=480,20,6,12 # (CAN FAIL) fps=60.000000 (target=60.000000)", "M clock=32750 horizontal=640,150,96,150 vertical=480,20,14,12 # (CAN FAIL) fps=60.098801 (target=60.098800)", "M clock=45250 horizontal=640,150,66,150 vertical=480,20,84,12 # (CAN FAIL) fps=75.469999 (target=75.470000)", "M clock=46620 horizontal=640,150,60,150 vertical=480,20,6,12 # (CAN FAIL) fps=90.000000 (target=90.000000)", "M clock=62160 horizontal=640,150,60,150 vertical=480,20,6,12 # (CAN FAIL) fps=120.000000 (target=120.000000)", "I seq=b9f11283", "I seq=b1000000da80", "I seq=b2000370", "I seq=b31010fcfc03ff00000000", "I seq=b480", "I seq=b50606", "I seq=b6a9a9", "I seq=b825622003", "I seq=ba338105f90e0e2000000000000000442500900a0000014f01000037", "I seq=bc47", "I seq=bf021100", "I seq=c0737350500000127000", "I seq=c125c0323277e4ffffcccc7777", "I seq=c68200bfff00ff", "I seq=c7b8000a000000", "I seq=c810401e02", "I seq=cc0b", "I seq=e0000a0f293c3f4138080c0f121412131219000a0f293c3f4138080c0f121412131219", "I seq=e307070b0b0b0b00000000ff00c010", "I seq=e9c8100a0000f0811231234f86f0814708000010000000000010000000888808f8f4466002288888888818f8f557711338888800000001000000000000000000", "I seq=ea001a0000000000000000000088f818f88331177558888888f808f88220066448888823000002fe00000000000000000000000000000000000000000000", "I seq=efffff01", "I seq=11 wait=250", "I seq=29 wait=50";
+	rotation = <0>;
+};
diff --git a/arch/arm64/boot/dts/rockchip/rk3566-powkiddy-x55.dts b/arch/arm64/boot/dts/rockchip/rk3566-powkiddy-x55.dts
index e274f7bf9..7c3df7142 100644
--- a/arch/arm64/boot/dts/rockchip/rk3566-powkiddy-x55.dts
+++ b/arch/arm64/boot/dts/rockchip/rk3566-powkiddy-x55.dts
@@ -25,51 +25,44 @@ chosen: chosen {
 		stdout-path = "serial2:1500000n8";
 	};
 
-	adc_joystick: adc-joystick {
-		compatible = "adc-joystick";
-		io-channels = <&saradc 0>, <&saradc 1>,
-			      <&saradc 2>, <&saradc 3>;
-		poll-interval = <60>;
-		#address-cells = <1>;
-		#size-cells = <0>;
-
-		axis@0 {
-			reg = <0>;
-			abs-flat = <30>;
-			abs-fuzz = <20>;
-			abs-range = <15 1023>;
-			linux,code = <ABS_X>;
-		};
-
-		axis@1 {
-			reg = <1>;
-			abs-flat = <30>;
-			abs-fuzz = <20>;
-			abs-range = <1023 15>;
-			linux,code = <ABS_Y>;
-		};
-
-		axis@2 {
-			reg = <2>;
-			abs-flat = <30>;
-			abs-fuzz = <20>;
-			abs-range = <15 1023>;
-			linux,code = <ABS_RX>;
-		};
-
-		axis@3 {
-			reg = <3>;
-			abs-flat = <30>;
-			abs-fuzz = <20>;
-			abs-range = <1023 15>;
-			linux,code = <ABS_RY>;
-		};
-	};
-
 	backlight: backlight {
 		compatible = "pwm-backlight";
 		power-supply = <&vcc_sys>;
 		pwms = <&pwm4 0 25000 0>;
+		brightness-levels = <
+			  0   1   2   3   4   5   6   7
+			  8   9  10  11  12  13  14  15
+			 16  17  18  19  20  21  22  23
+			 24  25  26  27  28  29  30  31
+			 32  33  34  35  36  37  38  39
+			 40  41  42  43  44  45  46  47
+			 48  49  50  51  52  53  54  55
+			 56  57  58  59  60  61  62  63
+			 64  65  66  67  68  69  70  71
+			 72  73  74  75  76  77  78  79
+			 80  81  82  83  84  85  86  87
+			 88  89  90  91  92  93  94  95
+			 96  97  98  99 100 101 102 103
+			104 105 106 107 108 109 110 111
+			112 113 114 115 116 117 118 119
+			120 121 122 123 124 125 126 127
+			128 129 130 131 132 133 134 135
+			136 137 138 139 140 141 142 143
+			144 145 146 147 148 149 150 151
+			152 153 154 155 156 157 158 159
+			160 161 162 163 164 165 166 167
+			168 169 170 171 172 173 174 175
+			176 177 178 179 180 181 182 183
+			184 185 186 187 188 189 190 191
+			192 193 194 195 196 197 198 199
+			200 201 202 203 204 205 206 207
+			208 209 210 211 212 213 214 215
+			216 217 218 219 220 221 222 223
+			224 225 226 227 228 229 230 231
+			232 233 234 235 236 237 238 239
+			240 241 242 243 244 245 246 247
+			248 249 250 251 252 253 254 255>;
+		default-brightness-level = <77>;
 	};
 
 	battery: battery {
@@ -91,108 +84,6 @@ battery: battery {
 					<3400000 0>;
 	};
 
-	gpio_keys_control: gpio-keys-control {
-		compatible = "gpio-keys";
-		pinctrl-0 = <&btn_pins_ctrl>;
-		pinctrl-names = "default";
-
-		button-a {
-			gpios = <&gpio3 RK_PD3 GPIO_ACTIVE_LOW>;
-			label = "EAST";
-			linux,code = <BTN_EAST>;
-		};
-
-		button-b {
-			gpios = <&gpio3 RK_PD2 GPIO_ACTIVE_LOW>;
-			label = "SOUTH";
-			linux,code = <BTN_SOUTH>;
-		};
-
-		button-down {
-			gpios = <&gpio4 RK_PA1 GPIO_ACTIVE_LOW>;
-			label = "DPAD-DOWN";
-			linux,code = <BTN_DPAD_DOWN>;
-		};
-
-		button-l1 {
-			gpios = <&gpio3 RK_PD0 GPIO_ACTIVE_LOW>;
-			label = "TL";
-			linux,code = <BTN_TL>;
-		};
-
-		button-l2 {
-			gpios = <&gpio3 RK_PD1 GPIO_ACTIVE_LOW>;
-			label = "TL2";
-			linux,code = <BTN_TL2>;
-		};
-
-		button-left {
-			gpios = <&gpio3 RK_PD6 GPIO_ACTIVE_LOW>;
-			label = "DPAD-LEFT";
-			linux,code = <BTN_DPAD_LEFT>;
-		};
-
-		button-right {
-			gpios = <&gpio3 RK_PD7 GPIO_ACTIVE_LOW>;
-			label = "DPAD-RIGHT";
-			linux,code = <BTN_DPAD_RIGHT>;
-		};
-
-		button-select {
-			gpios = <&gpio4 RK_PA4 GPIO_ACTIVE_LOW>;
-			label = "SELECT";
-			linux,code = <BTN_SELECT>;
-		};
-
-		button-start {
-			gpios = <&gpio4 RK_PA2 GPIO_ACTIVE_LOW>;
-			label = "START";
-			linux,code = <BTN_START>;
-		};
-
-		button-thumbl {
-			gpios = <&gpio4 RK_PA7 GPIO_ACTIVE_LOW>;
-			label = "THUMBL";
-			linux,code = <BTN_THUMBL>;
-		};
-
-		button-thumbr {
-			gpios = <&gpio4 RK_PB0 GPIO_ACTIVE_LOW>;
-			label = "THUMBR";
-			linux,code = <BTN_THUMBR>;
-		};
-
-		button-r1 {
-			gpios = <&gpio3 RK_PC6 GPIO_ACTIVE_LOW>;
-			label = "TR";
-			linux,code = <BTN_TR>;
-		};
-
-		button-r2 {
-			gpios = <&gpio3 RK_PC7 GPIO_ACTIVE_LOW>;
-			label = "TR2";
-			linux,code = <BTN_TR2>;
-		};
-
-		button-up {
-			gpios = <&gpio4 RK_PA0 GPIO_ACTIVE_LOW>;
-			label = "DPAD-UP";
-			linux,code = <BTN_DPAD_UP>;
-		};
-
-		button-x {
-			gpios = <&gpio3 RK_PD5 GPIO_ACTIVE_LOW>;
-			label = "NORTH";
-			linux,code = <BTN_NORTH>;
-		};
-
-		button-y {
-			gpios = <&gpio3 RK_PD4 GPIO_ACTIVE_LOW>;
-			label = "WEST";
-			linux,code = <BTN_WEST>;
-		};
-	};
-
 	gpio_keys_vol: gpio-keys-vol {
 		compatible = "gpio-keys";
 		autorepeat;
@@ -251,6 +142,167 @@ hdmi_con_in: endpoint {
 		};
 	};
 
+	joypad: rocknix-joypad {
+		compatible = "rocknix-joypad";
+		status = "okay";
+
+		/* the following 4 dts entries starting from joypad-name are important to keep
+		   compatibility with existing userspace programs such as ES and retroarch */
+		joypad-name = "retrogame_joypad";
+		joypad-product = <0x1101>;
+		joypad-revision = <0x0100>;
+		joypad-vendor = <0x484B>;
+
+		/* analog mux define */
+		io-channel-names = "key-RY", "key-RX", "key-LY", "key-LX";
+		io-channels = <&saradc 3>,<&saradc 2>,<&saradc 1>, <&saradc 0>;
+
+		/* gpio pincontrol setup */
+		pinctrl-names = "default";
+		pinctrl-0 = <&btn_pins_ctrl>;
+
+		/* adc calculate scale */
+		button-adc-scale = <2>;
+
+		/* adc deadzone range (minimum should be around 12%) */
+		button-adc-deadzone = <216>;
+
+		/* specifies fuzz value that is used to filter noise from
+		   the event stream. (around 3%) */
+		button-adc-fuzz = <54>;
+		button-adc-flat = <54>;
+
+		/* analog Stick data tuning value(precent)
+		   p = positive direction, n = negative direction
+		   report value = (real_adc_data * tuning_value) / 100 */
+		abs_x-p-tuning = <180>;
+		abs_x-n-tuning = <180>;
+
+		abs_y-p-tuning = <180>;
+		abs_y-n-tuning = <180>;
+
+		abs_rx-p-tuning = <180>;
+		abs_rx-n-tuning = <180>;
+
+		abs_ry-p-tuning = <180>;
+		abs_ry-n-tuning = <180>;
+
+		/* poll device interval (ms), adc read interval */
+		poll-interval = <10>;
+
+		/* gpio button auto repeat set value : default disable */
+		/* autorepeat; */
+
+		/*    *** Powkiddy X55 Switch layout ***
+		|------------------------------------------------|
+		| sw15                                      sw13 |
+		| sw16                                      sw14 |
+		|------------------------------------------------|
+		|                                                |
+		|   Analog     |-------------------|             |
+		|    sw11      |                   |      sw8    |
+		|              |                   |   sw7   sw5 |
+		|              |    LCD Display    |      sw6    |
+		|     sw1      |                   |             |
+		|  sw3  sw4    |                   |    Analog   |
+		|     sw2      |-------------------|     sw12    |
+		|                                                |
+		| sw9 Vol+                           Vol- sw10   |
+		|                                                |
+		|------------------------------------------------| */
+
+		sw1 {
+			gpios = <&gpio4 RK_PA0 GPIO_ACTIVE_LOW>;
+			label = "GPIO DPAD-UP";
+			linux,code = <BTN_DPAD_UP>;
+		};
+		sw2 {
+			gpios = <&gpio4 RK_PA1 GPIO_ACTIVE_LOW>;
+			label = "GPIO DPAD-DOWN";
+			linux,code = <BTN_DPAD_DOWN>;
+		};
+		sw3 {
+			gpios = <&gpio3 RK_PD6 GPIO_ACTIVE_LOW>;
+			label = "GPIO DPAD-LEFT";
+			linux,code = <BTN_DPAD_LEFT>;
+		};
+		sw4 {
+			gpios = <&gpio3 RK_PD7 GPIO_ACTIVE_LOW>;
+			label = "GPIO DPAD-RIGHT";
+			linux,code = <BTN_DPAD_RIGHT>;
+		};
+		sw5 {
+			gpios = <&gpio3 RK_PD3 GPIO_ACTIVE_LOW>;
+			label = "GPIO BTN-A";
+			linux,code = <BTN_EAST>;
+		};
+		sw6 {
+			gpios = <&gpio3 RK_PD2 GPIO_ACTIVE_LOW> ;
+			label = "GPIO BTN-B";
+			linux,code = <BTN_SOUTH>;
+		};
+		sw7 {
+			gpios = <&gpio3 RK_PD4 GPIO_ACTIVE_LOW>;
+			label = "GPIO BTN-Y";
+			linux,code = <BTN_WEST>;
+		};
+		sw8 {
+			gpios = <&gpio3 RK_PD5 GPIO_ACTIVE_LOW>;
+			label = "GPIO BTN-X";
+			linux,code = <BTN_NORTH>;
+		};
+		sw9 {
+			gpios = <&gpio4 RK_PA4 GPIO_ACTIVE_LOW>;
+			label = "BTN_SELECT";
+			linux,code = <BTN_SELECT>;
+		};
+		sw10 {
+			gpios = <&gpio4 RK_PA2 GPIO_ACTIVE_LOW>;
+			label = "BTN_START";
+			linux,code = <BTN_START>;
+		};
+		/* this sw11 entry is SPECIAL, most RK3566 devices do not have
+		   this physical button but for the sake of keeping compatibility
+		   with ES and retroarch, this phantom button and offset will
+		   allow existing userspace programs to work without doing any
+		   new remapping thus saving lots of headaches and extra work */
+		sw11 {
+			gpios = <&gpio3 RK_PB7 GPIO_ACTIVE_LOW>;
+			label = "GPIO BTN_F";
+			linux,code = <BTN_MODE>;
+		};
+		sw12 {
+			gpios = <&gpio4 RK_PA7 GPIO_ACTIVE_LOW>;
+			label = "BTN_THUMBL";
+			linux,code = <BTN_THUMBL>;
+		};
+		sw13 {
+			gpios = <&gpio4 RK_PB0 GPIO_ACTIVE_LOW>;
+			label = "BTN_THUMBR";
+			linux,code = <BTN_THUMBR>;
+		};
+		sw14 {
+			gpios = <&gpio3 RK_PC6 GPIO_ACTIVE_LOW>;
+			label = "GPIO BTN_TR";
+			linux,code = <BTN_TR>;
+		};
+		sw15 {
+			gpios = <&gpio3 RK_PC7 GPIO_ACTIVE_LOW>;
+			label = "GPIO BTN_TR2";
+			linux,code = <BTN_TR2>;
+		};
+		sw16 {
+			gpios = <&gpio3 RK_PD0 GPIO_ACTIVE_LOW>;
+			label = "GPIO BTN_TL";
+			linux,code = <BTN_TL>;
+		};
+		sw17 {
+			gpios = <&gpio3 RK_PD1 GPIO_ACTIVE_LOW>;
+			label = "GPIO BTN_TL2";
+			linux,code = <BTN_TL2>;
+		};
+	};
+
 	sdio_pwrseq: sdio-pwrseq {
 		compatible = "mmc-pwrseq-simple";
 		clocks = <&rk817 1>;
@@ -839,6 +891,9 @@ &sdmmc1 {
 	pinctrl-0 = <&sdmmc1_bus4>, <&sdmmc1_cmd>, <&sdmmc1_clk>;
 	pinctrl-names = "default";
 	vmmc-supply = <&vcc_wifi>;
+	no-mmc;
+	no-sd;
+	sd-uhs-sdr50;
 	status = "okay";
 };
 
diff --git a/arch/arm64/boot/dts/rockchip/rk3566.dtsi b/arch/arm64/boot/dts/rockchip/rk3566.dtsi
index 3fcca7927..60f5902d4 100644
--- a/arch/arm64/boot/dts/rockchip/rk3566.dtsi
+++ b/arch/arm64/boot/dts/rockchip/rk3566.dtsi
@@ -105,3 +105,11 @@ &cpu3 {
 &gpu {
 	operating-points-v2 = <&gpu_opp_table>;
 };
+
+&cpu0_opp_table {
+	opp-1992000000 {
+		opp-hz = /bits/ 64 <1992000000>;
+		opp-microvolt = <1150000 1150000 1150000>;
+		turbo-mode;
+	};
+};
diff --git a/arch/arm64/boot/dts/rockchip/rk356x-base.dtsi b/arch/arm64/boot/dts/rockchip/rk356x-base.dtsi
index fd2214b6f..017891827 100644
--- a/arch/arm64/boot/dts/rockchip/rk356x-base.dtsi
+++ b/arch/arm64/boot/dts/rockchip/rk356x-base.dtsi
@@ -55,6 +55,7 @@ cpu0: cpu@0 {
 			reg = <0x0 0x0>;
 			clocks = <&scmi_clk 0>;
 			#cooling-cells = <2>;
+			cpu-idle-states = <&CPU_SLEEP>;
 			enable-method = "psci";
 			i-cache-size = <0x8000>;
 			i-cache-line-size = <64>;
@@ -70,6 +71,7 @@ cpu1: cpu@100 {
 			compatible = "arm,cortex-a55";
 			reg = <0x0 0x100>;
 			#cooling-cells = <2>;
+			cpu-idle-states = <&CPU_SLEEP>;
 			enable-method = "psci";
 			i-cache-size = <0x8000>;
 			i-cache-line-size = <64>;
@@ -85,6 +87,7 @@ cpu2: cpu@200 {
 			compatible = "arm,cortex-a55";
 			reg = <0x0 0x200>;
 			#cooling-cells = <2>;
+			cpu-idle-states = <&CPU_SLEEP>;
 			enable-method = "psci";
 			i-cache-size = <0x8000>;
 			i-cache-line-size = <64>;
@@ -100,6 +103,7 @@ cpu3: cpu@300 {
 			compatible = "arm,cortex-a55";
 			reg = <0x0 0x300>;
 			#cooling-cells = <2>;
+			cpu-idle-states = <&CPU_SLEEP>;
 			enable-method = "psci";
 			i-cache-size = <0x8000>;
 			i-cache-line-size = <64>;
@@ -109,6 +113,18 @@ cpu3: cpu@300 {
 			d-cache-sets = <128>;
 			next-level-cache = <&l3_cache>;
 		};
+
+		idle-states {
+			entry-method = "psci";
+			CPU_SLEEP: cpu-sleep {
+				compatible = "arm,idle-state";
+				local-timer-stop;
+				arm,psci-suspend-param = <0x0010000>;
+				entry-latency-us = <100>;
+				exit-latency-us = <120>;
+				min-residency-us = <1000>;
+			};
+		};
 	};
 
 	/*
@@ -559,9 +575,22 @@ gpu: gpu@fde60000 {
 		interrupt-names = "job", "mmu", "gpu";
 		clocks = <&scmi_clk 1>, <&cru CLK_GPU>;
 		clock-names = "gpu", "bus";
+		resets = <&cru SRST_GPU>;
 		#cooling-cells = <2>;
 		power-domains = <&power RK3568_PD_GPU>;
 		status = "disabled";
+		power_policy = "always_on";
+		power_model@0 {
+			compatible = "arm,mali-simple-power-model";
+			static-coefficient = <100000>;
+			dynamic-coefficient = <953>;
+			ts = <(-108890) 63610 (-1355) 20>;
+			thermal-zone = "gpu-thermal";
+		};
+		power_model@1 {
+			compatible = "arm,mali-g52-power-model";
+			scale = <5>;
+		};
 	};
 
 	vpu: video-codec@fdea0400 {
@@ -812,6 +841,47 @@ hdmi_out: port@1 {
 		};
 	};
 
+	otp: otp@fe38c000 {
+		compatible = "rockchip,rk3568-otp";
+		reg = <0x0 0xfe38c000 0x0 0x4000>;
+		clocks = <&cru CLK_OTPC_NS_USR>, <&cru CLK_OTPC_NS_SBPI>,
+			 <&cru PCLK_OTPC_NS>, <&cru PCLK_OTPPHY>;
+		clock-names = "usr", "sbpi", "apb", "phy";
+		resets = <&cru SRST_OTPPHY>;
+		reset-names = "otp_phy";
+		#address-cells = <1>;
+		#size-cells = <1>;
+
+		cpu_code: cpu-code@2 {
+			reg = <0x02 0x2>;
+		};
+
+		otp_cpu_version: cpu-version@8 {
+			reg = <0x08 0x1>;
+			bits = <3 3>;
+		};
+
+		otp_id: id@a {
+			reg = <0x0a 0x10>;
+		};
+
+		cpu_leakage: cpu-leakage@1a {
+			reg = <0x1a 0x1>;
+		};
+
+		log_leakage: log-leakage@1b {
+			reg = <0x1b 0x1>;
+		};
+
+		npu_leakage: npu-leakage@1c {
+			reg = <0x1c 0x1>;
+		};
+
+		gpu_leakage: gpu-leakage@1d {
+			reg = <0x1d 0x1>;
+		};
+	};
+
 	qos_gpu: qos@fe128000 {
 		compatible = "rockchip,rk3568-qos", "syscon";
 		reg = <0x0 0xfe128000 0x0 0x20>;
@@ -1334,6 +1404,7 @@ uart1: serial@fe650000 {
 		clocks = <&cru SCLK_UART1>, <&cru PCLK_UART1>;
 		clock-names = "baudclk", "apb_pclk";
 		dmas = <&dmac0 2>, <&dmac0 3>;
+		dma-names = "tx", "rx";
 		pinctrl-0 = <&uart1m0_xfer>;
 		pinctrl-names = "default";
 		reg-io-width = <4>;
diff --git a/drivers/bluetooth/btrtl.c b/drivers/bluetooth/btrtl.c
index 1d4a7887a..aaefb912a 100644
--- a/drivers/bluetooth/btrtl.c
+++ b/drivers/bluetooth/btrtl.c
@@ -179,6 +179,14 @@ static const struct id_table ic_id_table[] = {
 	  .cfg_name = "rtl_bt/rtl8723ds_config",
 	  .hw_info  = "rtl8723ds" },
 
+	/* 8733BU */
+	{ IC_INFO(RTL_ROM_LMP_8723B, 0xf, 0x8, HCI_USB),
+	  .config_needed = true,
+	  .has_rom_version = true,
+	  .fw_name  = "rtl_bt/rtl8723fu_fw",
+	  .cfg_name = "rtl_bt/rtl8723fu_config",
+	  .hw_info  = "rtl8733bu" },
+
 	/* 8821A */
 	{ IC_INFO(RTL_ROM_LMP_8821A, 0xa, 0x6, HCI_USB),
 	  .config_needed = false,
@@ -665,6 +673,7 @@ static int rtlbt_parse_firmware(struct hci_dev *hdev,
 		{ RTL_ROM_LMP_8822B, 13 },	/* 8822C */
 		{ RTL_ROM_LMP_8761A, 14 },	/* 8761B */
 		{ RTL_ROM_LMP_8852A, 18 },	/* 8852A */
+		{ RTL_ROM_LMP_8723B, 19 },	/* 8733B */
 		{ RTL_ROM_LMP_8852A, 20 },	/* 8852B */
 		{ RTL_ROM_LMP_8852A, 25 },	/* 8852C */
 		{ RTL_ROM_LMP_8851B, 36 },	/* 8851B */
@@ -1516,6 +1525,8 @@ MODULE_FIRMWARE("rtl_bt/rtl8723d_fw.bin");
 MODULE_FIRMWARE("rtl_bt/rtl8723d_config.bin");
 MODULE_FIRMWARE("rtl_bt/rtl8723ds_fw.bin");
 MODULE_FIRMWARE("rtl_bt/rtl8723ds_config.bin");
+MODULE_FIRMWARE("rtl_bt/rtl8723fu_fw.bin");
+MODULE_FIRMWARE("rtl_bt/rtl8723fu_config.bin");
 MODULE_FIRMWARE("rtl_bt/rtl8761a_fw.bin");
 MODULE_FIRMWARE("rtl_bt/rtl8761a_config.bin");
 MODULE_FIRMWARE("rtl_bt/rtl8761b_fw.bin");
diff --git a/drivers/bluetooth/btusb.c b/drivers/bluetooth/btusb.c
index fa683bb7f..31fdf4200 100644
--- a/drivers/bluetooth/btusb.c
+++ b/drivers/bluetooth/btusb.c
@@ -766,6 +766,9 @@ static const struct usb_device_id quirks_table[] = {
 	{ USB_DEVICE(0x0bda, 0xb009), .driver_info = BTUSB_REALTEK },
 	{ USB_DEVICE(0x2ff8, 0xb011), .driver_info = BTUSB_REALTEK },
 
+	/* Realtek 8733BU Bluetooth device */
+	{ USB_DEVICE(0x0bda, 0xb733), .driver_info = BTUSB_REALTEK },
+
 	/* Additional Realtek 8761BUV Bluetooth devices */
 	{ USB_DEVICE(0x2357, 0x0604), .driver_info = BTUSB_REALTEK |
 						     BTUSB_WIDEBAND_SPEECH },
diff --git a/drivers/gpio/gpiolib-of.c b/drivers/gpio/gpiolib-of.c
index 37ab78243..13fbd2fb7 100644
--- a/drivers/gpio/gpiolib-of.c
+++ b/drivers/gpio/gpiolib-of.c
@@ -25,21 +25,6 @@
 #include "gpiolib.h"
 #include "gpiolib-of.h"
 
-/*
- * This is Linux-specific flags. By default controllers' and Linux' mapping
- * match, but GPIO controllers are free to translate their own flags to
- * Linux-specific in their .xlate callback. Though, 1:1 mapping is recommended.
- */
-enum of_gpio_flags {
-	OF_GPIO_ACTIVE_LOW = 0x1,
-	OF_GPIO_SINGLE_ENDED = 0x2,
-	OF_GPIO_OPEN_DRAIN = 0x4,
-	OF_GPIO_TRANSITORY = 0x8,
-	OF_GPIO_PULL_UP = 0x10,
-	OF_GPIO_PULL_DOWN = 0x20,
-	OF_GPIO_PULL_DISABLE = 0x40,
-};
-
 /**
  * of_gpio_named_count() - Count GPIOs for a device
  * @np:		device node to count GPIOs for
@@ -446,6 +431,20 @@ static struct gpio_desc *of_get_named_gpiod_flags(const struct device_node *np,
 	return desc;
 }
 
+int of_get_named_gpio_flags(const struct device_node *np, const char *list_name,
+			    int index, enum of_gpio_flags *flags)
+{
+	struct gpio_desc *desc;
+
+	desc = of_get_named_gpiod_flags(np, list_name, index, flags);
+
+	if (IS_ERR(desc))
+		return PTR_ERR(desc);
+	else
+		return desc_to_gpio(desc);
+}
+EXPORT_SYMBOL_GPL(of_get_named_gpio_flags);
+
 /**
  * of_get_named_gpio() - Get a GPIO number to use with GPIO API
  * @np:		device node to get GPIO from
diff --git a/drivers/gpu/drm/panel/Makefile b/drivers/gpu/drm/panel/Makefile
index 957555b49..b1bc402b7 100644
--- a/drivers/gpu/drm/panel/Makefile
+++ b/drivers/gpu/drm/panel/Makefile
@@ -114,3 +114,4 @@ obj-$(CONFIG_DRM_PANEL_VISIONOX_VTDR6130) += panel-visionox-vtdr6130.o
 obj-$(CONFIG_DRM_PANEL_VISIONOX_R66451) += panel-visionox-r66451.o
 obj-$(CONFIG_DRM_PANEL_WIDECHIPS_WS2401) += panel-widechips-ws2401.o
 obj-$(CONFIG_DRM_PANEL_XINPENG_XPP055C272) += panel-xinpeng-xpp055c272.o
+obj-y += panel-generic-dsi.o
diff --git a/drivers/gpu/drm/panel/panel-generic-dsi.c b/drivers/gpu/drm/panel/panel-generic-dsi.c
new file mode 100644
index 000000000..e01ce7477
--- /dev/null
+++ b/drivers/gpu/drm/panel/panel-generic-dsi.c
@@ -0,0 +1,681 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Generic MIPI-DSI panel driver
+ * Copyright (C) 2024 ROCKNIX
+ *
+ * based on
+ *
+ * Rockteck jh057n00900 5.5" MIPI-DSI panel driver
+ * Copyright (C) Purism SPC 2019
+ */
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/media-bus-format.h>
+#include <linux/module.h>
+#include <linux/firmware.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <video/display_timing.h>
+#include <video/mipi_display.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+#define DRIVER_NAME "panel-generic-dsi"
+
+static char *descfile = "";
+module_param(descfile,charp,0660);
+MODULE_PARM_DESC(descfile, "Panel description filename in firmware dir");
+
+struct generic_panel_delays {
+    int prepare;
+    int reset;
+    int init;
+    int enable;
+    int ready;
+};
+
+struct generic_panel_size {
+    int width;
+    int height;
+};
+
+struct generic_panel_mode {
+    int clock;
+    int horizontal[5];
+    int vertical[5];
+    int is_default;
+    struct generic_panel_mode *prev;
+};
+
+#define DCS_PSEUDO_CMD_SEQ 0x10000
+struct generic_panel_init_seq {
+    int dcs;
+    int len;
+    int read;
+    int wait;
+    u8 *data;
+    struct generic_panel_init_seq *link;
+};
+
+struct generic_panel {
+    struct device *dev;
+    struct drm_panel panel;
+    struct gpio_desc *reset_gpio;
+    struct regulator *vdd;
+    struct regulator *iovcc;
+
+    struct generic_panel_delays delays;
+    struct generic_panel_size size;
+    struct generic_panel_mode *modes;
+    struct generic_panel_init_seq *iseq;
+
+    enum drm_panel_orientation orientation;
+    bool prepared;
+};
+
+
+int load_panel_description(struct mipi_dsi_device *dsi, struct generic_panel *ctx);
+int load_panel_description_line(char *data, struct mipi_dsi_device *dsi, struct generic_panel *ctx);
+int load_globals(char *data, struct mipi_dsi_device *dsi, struct generic_panel *ctx);
+int load_mode(char *data, struct mipi_dsi_device *dsi, struct generic_panel *ctx);
+int load_init_seq(char *data, struct mipi_dsi_device *dsi, struct generic_panel *ctx);
+
+
+
+int load_globals(char *data, struct mipi_dsi_device *dsi, struct generic_panel *ctx) {
+    struct device *dev = &dsi->dev;
+    char *param, *val;
+    while (*data) {
+        data = next_arg(data, &param, &val);
+        if (!val) continue;
+        if (strcmp(param, "delays") == 0) {
+            int delays[] = {0, 5, 1, 25, 120, 50};
+            get_options(val, 6, delays);
+            ctx->delays.prepare     = delays[1];
+            ctx->delays.reset       = delays[2];
+            ctx->delays.init        = delays[3];
+            ctx->delays.enable      = delays[4];
+            ctx->delays.ready       = delays[5];
+        } else if (strcmp(param, "size") == 0) {
+            int size[] = {0, -1, -1};
+            get_options(val, 3, size);
+            ctx->size.width         = size[1];
+            ctx->size.height        = size[2];
+        } else if (strcmp(param, "format") == 0) {
+            if (strcmp(val, "rgb888") == 0) {
+                dsi->format = MIPI_DSI_FMT_RGB888;
+            } else if (strcmp(val, "rgb666") == 0) {
+                dsi->format = MIPI_DSI_FMT_RGB666;
+            } else if (strcmp(val, "rgb666_packed") == 0) {
+                dsi->format = MIPI_DSI_FMT_RGB666_PACKED;
+            } else if (strcmp(val, "rgb565") == 0) {
+                dsi->format = MIPI_DSI_FMT_RGB565;
+            } else {
+                dev_info(dev, "bad format %s\n", val);
+            }
+        } else if (strcmp(param, "lanes") == 0) {
+            if (get_option(&val, &dsi->lanes) == 0) {
+                dev_info(dev, "bad lanes %s\n", val);
+            }
+        } else if (strcmp(param, "flags") == 0) {
+            int flags;
+            if (get_option(&val, &flags) == 0) {
+                dev_info(dev, "bad flags %s\n", val);
+            } else {
+                dsi->mode_flags = flags;
+            }
+        } else {
+            dev_info(dev, "unknown param %s\n", param);
+            return -1;
+        }
+    }
+    return 0;
+}
+
+
+int load_mode(char *data, struct mipi_dsi_device *dsi, struct generic_panel *ctx) {
+    struct device *dev = &dsi->dev;
+    struct generic_panel_mode *mode;
+    char *param, *val;
+
+    mode = devm_kzalloc(dev, sizeof(*mode), GFP_KERNEL);
+
+    while (*data) {
+        data = next_arg(data, &param, &val);
+        if (!val) continue;
+        if (strcmp(param, "clock") == 0) {
+            if (get_option(&val, &mode->clock) == 0) {
+                dev_info(dev, "bad clock %s\n", val);
+            }
+        } else if (strcmp(param, "horizontal") == 0) {
+            get_options(val, 5, &mode->horizontal[0]);
+        } else if (strcmp(param, "vertical") == 0) {
+            get_options(val, 5, &mode->vertical[0]);
+        } else if (strcmp(param, "default") == 0) {
+            get_option(&val, &mode->is_default);
+        } else {
+            dev_info(dev, "Mode unhandled %s = %s\n", param, val);
+        }
+    }
+
+    if ((mode->clock > 5000) && (mode->vertical[1] > 0) && (mode->horizontal[1] > 0)) {
+        mode->prev = ctx->modes;
+        ctx->modes = mode;
+        dev_dbg(dev, "Mode %d %d %d  %p -> %p\n", mode->clock, mode->vertical[1], mode->horizontal[1], mode, mode->prev);
+        return 0;
+    }
+    return -1;
+}
+
+int load_init_seq(char *data, struct mipi_dsi_device *dsi, struct generic_panel *ctx) {
+    struct device *dev = &dsi->dev;
+    struct generic_panel_init_seq *item;
+    char *param, *val;
+
+    item = devm_kzalloc(dev, sizeof(*item), GFP_KERNEL);
+    item->dcs = -1;
+    item->len = -1;
+    item->read = 0;
+    item->wait = 0;
+
+    while (*data) {
+        data = next_arg(data, &param, &val);
+        if (!val) continue;
+        if (strcmp(param, "dcs") == 0) {
+            item->dcs = simple_strtoul(val, NULL, 16) & 0xFF;
+            //dev_info(dev, "Init dcs %02x\n", item->dcs);
+        } else if (strcmp(param, "data") == 0) {
+            item->len = (strlen(val)) >> 1;
+            item->data = devm_kzalloc(dev, item->len, GFP_KERNEL);
+            if (hex2bin(item->data, val, item->len) != 0) {
+                dev_info(dev, "bad data %s\n", val);
+                return -1;
+            }
+            //for (int i=0; i < (item->len); i++) { dev_info(dev, " %02x", item->data[i]);};
+            //dev_info(dev, "\n");
+        } else if (strcmp(param, "seq") == 0) {
+            item->dcs = DCS_PSEUDO_CMD_SEQ;
+            item->len = (strlen(val)) >> 1;
+            item->data = devm_kzalloc(dev, item->len, GFP_KERNEL);
+            if (hex2bin(item->data, val, item->len) != 0) {
+                dev_info(dev, "bad seq %s\n", val);
+                return -1;
+            }
+            dev_dbg(dev, "loaded seq len=%d %s\n", item->len, val);
+        } else if (strcmp(param, "read") == 0) {
+            item->read = simple_strtoul(val, NULL, 16);
+        } else if (strcmp(param, "wait") == 0) {
+            item->wait = simple_strtoul(val, NULL, 16);
+        } else {
+            dev_info(dev, "Init unhandled %s = %s\n", param, val);
+        }
+    }
+
+    if (item->dcs >= 0) {
+        item->link = ctx->iseq;
+        ctx->iseq = item;
+        return 0;
+    }
+
+    return -1;
+}
+
+/*
+ * data   is a null-terminated string of panel description
+ */
+int load_panel_description_line(char *data, struct mipi_dsi_device *dsi, struct generic_panel *ctx) {
+    size_t pos;
+    for (pos = 0; data[pos] != 0; pos ++) {
+        if ((data[pos] == '#') || data[pos] == '\n') {
+            data[pos] = 0;
+            break;
+        }
+    }
+    if (pos < 2) return 0;
+
+    switch (data[0]) {
+        case 'G':
+            load_globals(data+1, dsi, ctx);
+            break;
+        case 'M':
+            load_mode(data+1, dsi, ctx);
+            break;
+        case 'I':
+            load_init_seq(data+1, dsi, ctx);
+            break;
+        default:
+            dev_info(NULL, "Unhandled %s\n", data);
+    }
+
+    return 0;
+}
+
+int panel_description_foreach(struct mipi_dsi_device *dsi, struct generic_panel *ctx,
+        int (*handle_line)(char*, struct mipi_dsi_device*, struct generic_panel*));
+
+int panel_description_foreach(struct mipi_dsi_device *dsi, struct generic_panel *ctx,
+        int (*handle_line)(char*, struct mipi_dsi_device*, struct generic_panel*))
+{
+    struct device *dev = &dsi->dev;
+    const struct firmware *fw;
+    int ret;
+
+    if (strlen(descfile) > 0) {
+        ret = request_firmware(&fw, descfile, dev);
+        if (ret) {
+            dev_err(dev, "No config file found (error=%d)\n", ret);
+            return -1;
+        }
+
+        size_t pos = 0, size = fw->size;
+        char *data = (char *)fw->data;
+
+        while (pos < size) {
+            while ((pos < size) && (data[pos] != '\n')) pos++;
+
+            if (pos < size) pos++;
+            data[pos - 1] = 0;
+
+            handle_line(data, dsi, ctx);
+
+            data = &data[pos];
+            size = size - pos;
+            pos = 0;
+        }
+
+        release_firmware(fw);
+    } else {
+        //ret = of_drm_get_panel_orientation(dev->of_node, &ctx->orientation);
+        const char *line;
+        char * buf;
+        size_t linescnt, i;
+
+        linescnt = of_property_count_strings(dev->of_node, "panel_description");
+        if (linescnt < 1) {
+            dev_err(dev, "failed to read panel_description from device tree %ld\n", linescnt);
+            return -1;
+        }
+
+        for (i = 0; i < linescnt; i++) {
+            ret = of_property_read_string_index(dev->of_node, "panel_description", i, &line);
+            if (ret < 0) {
+                dev_err(dev, "failed to read panel_description[%ld] from device tree %d\n", i, ret);
+                return -1;
+            }
+            buf = kstrdup(line, GFP_KERNEL);
+            if (!buf) {
+                dev_err(dev, "kstrdup(of desc line) failed\n");
+                return -1;
+            }
+
+            dev_dbg(dev, "desc[%ld]: %s", i, line);
+            handle_line(buf, dsi, ctx);
+            kfree(buf);
+        }
+    }
+    return 0;
+}
+
+int load_panel_description(struct mipi_dsi_device *dsi, struct generic_panel *ctx) {
+    int ret;
+
+    ret = panel_description_foreach(dsi, ctx, &load_panel_description_line);
+    if (ret < 0) { return ret; }
+
+    // Reverse iseq
+    struct generic_panel_init_seq *rev = ctx->iseq, *fwd = NULL, *tmp = NULL;
+    while (rev) {
+        tmp = rev;
+        rev = tmp->link;
+        tmp->link = fwd;
+        fwd = tmp;
+    }
+    ctx->iseq = fwd;
+
+
+    return 0;
+}
+
+
+static inline struct generic_panel *panel_to_generic_panel(struct drm_panel *panel)
+{
+    return container_of(panel, struct generic_panel, panel);
+}
+
+static int generic_panel_init_sequence(struct generic_panel *ctx)
+{
+    struct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);
+    struct device *dev = ctx->dev;
+    int ret;
+
+    struct generic_panel_init_seq *iseq = ctx->iseq;
+    while (iseq) {
+        if (iseq->read > 0) {
+            u8 readbuf[8];
+            if (iseq->read > 8) { iseq->read = 8; }
+            ret = mipi_dsi_generic_read(dsi, iseq->data, iseq->len, &readbuf[0], iseq->read);
+            if (ret < 0) {
+                dev_err(ctx->dev, "failed to read: %d\n", ret);
+            } else {
+                for (int i = 0; i < ret; i++) {
+                    dev_info(ctx->dev, "read[%d]: %02x\n", i, readbuf[i]);
+                }
+            }
+        } else if (iseq->dcs == DCS_PSEUDO_CMD_SEQ) {
+            ret = mipi_dsi_dcs_write_buffer(dsi, iseq->data, iseq->len);
+            dev_dbg(dev, "iseq 0x%px len=%d -> %d\n", (void*)iseq, iseq->len, ret);
+        } else {
+            ret = mipi_dsi_dcs_write(dsi, iseq->dcs, iseq->data, iseq->len);
+            dev_dbg(dev, "iseq %02x len=%d -> %d\n", iseq->dcs, iseq->len, ret);
+        }
+        if (iseq->wait) {
+            msleep(iseq->wait);
+        }
+        iseq = iseq->link;
+    }
+
+    dev_dbg(dev, "Panel init sequence done\n");
+
+    return 0;
+}
+
+static int generic_panel_unprepare(struct drm_panel *panel)
+{
+    struct generic_panel *ctx = panel_to_generic_panel(panel);
+    struct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);
+    int ret;
+
+    if (!ctx->prepared)
+        return 0;
+
+    ret = mipi_dsi_dcs_set_display_off(dsi);
+    if (ret < 0)
+        dev_err(ctx->dev, "failed to set display off: %d\n", ret);
+
+    ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+    if (ret < 0) {
+        dev_err(ctx->dev, "failed to enter sleep mode: %d\n", ret);
+        return ret;
+    }
+
+    gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+
+    regulator_disable(ctx->iovcc);
+    regulator_disable(ctx->vdd);
+
+    gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+
+    ctx->prepared = false;
+
+    return 0;
+}
+
+static int generic_panel_prepare(struct drm_panel *panel)
+{
+    struct generic_panel *ctx = panel_to_generic_panel(panel);
+    struct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);
+    int ret;
+
+    if (ctx->prepared) {
+        return 0;
+    }
+
+    ret = regulator_enable(ctx->vdd);
+    if (ret < 0) {
+        dev_err(ctx->dev, "Failed to enable vdd supply: %d\n", ret);
+        return ret;
+    }
+
+    ret = regulator_enable(ctx->iovcc);
+    if (ret < 0) {
+        dev_err(ctx->dev, "Failed to enable iovcc supply: %d\n", ret);
+        goto disable_vdd;
+    }
+
+    msleep(ctx->delays.prepare);
+
+    gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+    msleep(ctx->delays.reset);
+    gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+
+    msleep(ctx->delays.init);
+
+    ret = generic_panel_init_sequence(ctx);
+    if (ret < 0) {
+        dev_err(ctx->dev, "Panel init sequence failed: %d\n", ret);
+        goto disable_iovcc;
+    }
+
+    ret = mipi_dsi_dcs_set_display_on(dsi);
+    if (ret < 0) {
+        dev_err(ctx->dev, "Failed to set display on: %d\n", ret);
+        goto disable_iovcc;
+    }
+
+    ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+    if (ret < 0) {
+        dev_err(ctx->dev, "Failed to exit sleep mode: %d\n", ret);
+        goto disable_iovcc;
+    }
+
+    msleep(ctx->delays.enable);
+
+    //msleep(ctx->delays.ready);
+
+    ctx->prepared = true;
+
+    return 0;
+
+disable_iovcc:
+    regulator_disable(ctx->iovcc);
+disable_vdd:
+    regulator_disable(ctx->vdd);
+    return ret;
+}
+
+/* drm_display_mode template without clock as it is variable */
+static const struct drm_display_mode mode_template = { };
+
+
+static int generic_panel_get_modes(struct drm_panel *panel,
+                struct drm_connector *connector)
+{
+    struct generic_panel *ctx = panel_to_generic_panel(panel);
+    struct drm_display_mode mode_tmp;
+    struct drm_display_mode *mode;
+    struct generic_panel_mode *genmode = ctx->modes;
+
+    while (genmode) {
+        dev_dbg(ctx->dev, "gen mode %d %dx%d\n", genmode->clock, genmode->horizontal[1], genmode->vertical[1]);
+
+        mode_tmp = mode_template;
+
+        mode_tmp.clock          = genmode->clock;
+
+        mode_tmp.hdisplay       = genmode->horizontal[1];
+        mode_tmp.hsync_start    = mode_tmp.hdisplay + genmode->horizontal[2];
+        mode_tmp.hsync_end      = mode_tmp.hsync_start + genmode->horizontal[3];
+        mode_tmp.htotal         = mode_tmp.hsync_end + genmode->horizontal[4];
+
+        mode_tmp.vdisplay       = genmode->vertical[1];
+        mode_tmp.vsync_start    = mode_tmp.vdisplay + genmode->vertical[2];
+        mode_tmp.vsync_end      = mode_tmp.vsync_start + genmode->vertical[3];
+        mode_tmp.vtotal         = mode_tmp.vsync_end + genmode->vertical[4];
+
+        mode_tmp.width_mm       = ctx->size.width;
+        mode_tmp.height_mm      = ctx->size.height;
+
+        // All tested panels (R36s orig, new-3, new-4; rgb10s) either require no sync or work OK with it.
+        // So for now just always set no sync drm flags
+        // TODO: pass drm flags in mode line if some future panel requires that
+        mode_tmp.flags          = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC;
+
+        mode = drm_mode_duplicate(connector->dev, &mode_tmp);
+        if (!mode) {
+            dev_err(ctx->dev, "Failed to add mode %u\n",
+                drm_mode_vrefresh(mode));
+            return -ENOMEM;
+        }
+        drm_mode_set_name(mode);
+
+        mode->type = DRM_MODE_TYPE_DRIVER;
+        if (genmode->is_default) { mode->type |= DRM_MODE_TYPE_PREFERRED; };
+
+        drm_mode_probed_add(connector, mode);
+
+        genmode = genmode->prev;
+    }
+
+    connector->display_info.width_mm = ctx->size.width;
+    connector->display_info.height_mm = ctx->size.height;
+
+
+    /*
+     * TODO: Remove once all drm drivers call
+     * drm_connector_set_orientation_from_panel()
+     */
+    drm_connector_set_panel_orientation(connector, ctx->orientation);
+
+    return 1;
+}
+
+static enum drm_panel_orientation generic_panel_get_orientation(struct drm_panel *panel)
+{
+    struct generic_panel *ctx = panel_to_generic_panel(panel);
+
+    return ctx->orientation;
+}
+
+static const struct drm_panel_funcs generic_panel_funcs = {
+    .unprepare  = generic_panel_unprepare,
+    .prepare    = generic_panel_prepare,
+    .get_modes  = generic_panel_get_modes,
+    .get_orientation = generic_panel_get_orientation,
+};
+
+static int generic_panel_probe(struct mipi_dsi_device *dsi)
+{
+    struct device *dev = &dsi->dev;
+    struct generic_panel *ctx;
+    int ret;
+
+    ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+    if (!ctx)
+        return -ENOMEM;
+
+    ctx->reset_gpio = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_LOW);
+    if (IS_ERR(ctx->reset_gpio)) {
+        dev_err(dev, "cannot get reset gpio\n");
+        return PTR_ERR(ctx->reset_gpio);
+    }
+
+    ctx->vdd = devm_regulator_get(dev, "vdd");
+    if (IS_ERR(ctx->vdd)) {
+        ret = PTR_ERR(ctx->vdd);
+        if (ret != -EPROBE_DEFER)
+            dev_err(dev, "Failed to request vdd regulator: %d\n", ret);
+        return ret;
+    }
+
+    ctx->iovcc = devm_regulator_get(dev, "iovcc");
+    if (IS_ERR(ctx->iovcc)) {
+        ret = PTR_ERR(ctx->iovcc);
+        if (ret != -EPROBE_DEFER)
+            dev_err(dev, "Failed to request iovcc regulator: %d\n", ret);
+        return ret;
+    }
+
+    ret = of_drm_get_panel_orientation(dev->of_node, &ctx->orientation);
+    if (ret < 0) {
+        dev_err(dev, "%pOF: failed to get orientation %d\n", dev->of_node, ret);
+        return ret;
+    }
+
+    mipi_dsi_set_drvdata(dsi, ctx);
+
+    ctx->dev = dev;
+
+    // Some defaults
+    dsi->lanes = 1;
+    dsi->format = MIPI_DSI_FMT_RGB888;
+    dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+              MIPI_DSI_MODE_LPM | MIPI_DSI_MODE_NO_EOT_PACKET |
+              MIPI_DSI_CLOCK_NON_CONTINUOUS;
+
+    ret = load_panel_description(dsi, ctx);
+    if (ret < 0) {
+        dev_err(dev, "Failed to load panel description\n");
+        return ret;
+    }
+
+    mipi_dsi_set_drvdata(dsi, ctx);
+
+    dev_info(dev, "lanes %d, format %d, mode %lx\n", dsi->lanes, dsi->format, dsi->mode_flags);
+
+    drm_panel_init(&ctx->panel, &dsi->dev, &generic_panel_funcs,
+               DRM_MODE_CONNECTOR_DSI);
+
+    ret = drm_panel_of_backlight(&ctx->panel);
+    if (ret)
+        return ret;
+
+    drm_panel_add(&ctx->panel);
+
+    ret = mipi_dsi_attach(dsi);
+    if (ret < 0) {
+        dev_err(dev, "mipi_dsi_attach failed: %d\n", ret);
+        drm_panel_remove(&ctx->panel);
+        return ret;
+    }
+
+    return 0;
+}
+
+static void generic_panel_shutdown(struct mipi_dsi_device *dsi)
+{
+    struct generic_panel *ctx = mipi_dsi_get_drvdata(dsi);
+    int ret;
+
+    drm_panel_unprepare(&ctx->panel);
+
+    drm_panel_disable(&ctx->panel);
+}
+
+static void generic_panel_remove(struct mipi_dsi_device *dsi)
+{
+    struct generic_panel *ctx = mipi_dsi_get_drvdata(dsi);
+    int ret;
+
+    generic_panel_shutdown(dsi);
+
+    ret = mipi_dsi_detach(dsi);
+    if (ret < 0)
+        dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+    drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id generic_panel_of_match[] = {
+    { .compatible = "rocknix,generic-dsi" },
+    { /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, generic_panel_of_match);
+
+static struct mipi_dsi_driver generic_panel_driver = {
+    .driver = {
+        .name = DRIVER_NAME,
+        .of_match_table = generic_panel_of_match,
+    },
+    .probe  = generic_panel_probe,
+    .remove = generic_panel_remove,
+    .shutdown = generic_panel_shutdown,
+};
+module_mipi_dsi_driver(generic_panel_driver);
+
+MODULE_AUTHOR("Danil Zagoskin <z@gosk.in>");
+MODULE_DESCRIPTION("DRM driver for generic MIPI DSI panel");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/panel/panel-newvision-nv3051d.c b/drivers/gpu/drm/panel/panel-newvision-nv3051d.c
index 22560384e..762279eee 100644
--- a/drivers/gpu/drm/panel/panel-newvision-nv3051d.c
+++ b/drivers/gpu/drm/panel/panel-newvision-nv3051d.c
@@ -474,14 +474,14 @@ static const struct drm_display_mode nv3051d_rgxx3_modes[] = {
 static const struct drm_display_mode nv3051d_rk2023_modes[] = {
 	{
 		.hdisplay       = 640,
-		.hsync_start    = 640 + 40,
-		.hsync_end      = 640 + 40 + 2,
-		.htotal         = 640 + 40 + 2 + 80,
+		.hsync_start    = 640 + 64,
+		.hsync_end      = 640 + 64 + 2,
+		.htotal         = 640 + 64 + 2 + 80,
 		.vdisplay       = 480,
-		.vsync_start    = 480 + 18,
-		.vsync_end      = 480 + 18 + 2,
-		.vtotal         = 480 + 18 + 2 + 4,
-		.clock          = 24150,
+		.vsync_start    = 480 + 2,
+		.vsync_end      = 480 + 2 + 4,
+		.vtotal         = 480 + 2 + 4 + 3,
+		.clock          = 23040,
 		.flags          = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,
 	},
 };
diff --git a/drivers/gpu/drm/panel/panel-sitronix-st7701.c b/drivers/gpu/drm/panel/panel-sitronix-st7701.c
index 2f79ec4a2..e2feb6ce5 100644
--- a/drivers/gpu/drm/panel/panel-sitronix-st7701.c
+++ b/drivers/gpu/drm/panel/panel-sitronix-st7701.c
@@ -959,7 +959,7 @@ static const struct st7701_panel_desc kd50t048a_desc = {
 };
 
 static const struct drm_display_mode rg_arc_mode = {
-	.clock          = 25600,
+	.clock          = 26000,
 
 	.hdisplay	= 480,
 	.hsync_start	= 480 + 60,
@@ -967,9 +967,9 @@ static const struct drm_display_mode rg_arc_mode = {
 	.htotal         = 480 + 60 + 42 + 60,
 
 	.vdisplay	= 640,
-	.vsync_start	= 640 + 10,
-	.vsync_end	= 640 + 10 + 4,
-	.vtotal         = 640 + 10 + 4 + 16,
+	.vsync_start	= 640 + 8,
+	.vsync_end	= 640 + 8 + 4,
+	.vtotal         = 640 + 8 + 4 + 13,
 
 	.width_mm	= 63,
 	.height_mm	= 84,
diff --git a/drivers/gpu/drm/panel/panel-sitronix-st7703.c b/drivers/gpu/drm/panel/panel-sitronix-st7703.c
index 1a007a244..68f8ed6ca 100644
--- a/drivers/gpu/drm/panel/panel-sitronix-st7703.c
+++ b/drivers/gpu/drm/panel/panel-sitronix-st7703.c
@@ -347,8 +347,8 @@ static void rg353v2_init_sequence(struct mipi_dsi_multi_context *dsi_ctx)
 				     0x28, 0x03, 0xff, 0x00, 0x00, 0x00, 0x00);
 	mipi_dsi_dcs_write_seq_multi(dsi_ctx, ST7703_CMD_SETCYC, 0x80);
 	mipi_dsi_dcs_write_seq_multi(dsi_ctx, ST7703_CMD_SETBGP, 0x0a, 0x0a);
-	mipi_dsi_dcs_write_seq_multi(dsi_ctx, ST7703_CMD_SETVCOM, 0x92, 0x92);
-	mipi_dsi_dcs_write_seq_multi(dsi_ctx, ST7703_CMD_SETPOWER_EXT, 0x25, 0x22,
+	mipi_dsi_dcs_write_seq_multi(dsi_ctx, ST7703_CMD_SETVCOM, 0x7f, 0x7f);
+	mipi_dsi_dcs_write_seq_multi(dsi_ctx, ST7703_CMD_SETPOWER_EXT, 0x26, 0x62,
 				     0xf0, 0x63);
 	mipi_dsi_dcs_write_seq_multi(dsi_ctx, ST7703_CMD_SETMIPI, 0x33, 0x81, 0x05,
 				     0xf9, 0x0e, 0x0e, 0x20, 0x00, 0x00, 0x00, 0x00,
@@ -490,7 +490,7 @@ static const struct drm_display_mode rgb30panel_mode = {
 	.vsync_start	= 720 + 15,
 	.vsync_end	= 720 + 15 + 3,
 	.vtotal		= 720 + 15 + 3 + 11,
-	.clock		= 36570,
+	.clock		= 37000,
 	.flags		= DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,
 	.width_mm	= 76,
 	.height_mm	= 76,
diff --git a/drivers/input/Kconfig b/drivers/input/Kconfig
index 88ecdf521..d5340645e 100644
--- a/drivers/input/Kconfig
+++ b/drivers/input/Kconfig
@@ -51,6 +51,19 @@ config INPUT_FF_MEMLESS
 	  To compile this driver as a module, choose M here: the
 	  module will be called ff-memless.
 
+config INPUT_POLLDEV
+	tristate "Polled input device skeleton"
+	help
+	  Say Y here if you are using a driver for an input
+	  device that periodically polls hardware state. This
+	  option is only useful for out-of-tree drivers since
+	  in-tree drivers select it automatically.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called input-polldev.
+
 config INPUT_SPARSEKMAP
 	tristate "Sparse keymap support library"
 	help
diff --git a/drivers/input/Makefile b/drivers/input/Makefile
index 2cd6e1c9a..fb14d4f9f 100644
--- a/drivers/input/Makefile
+++ b/drivers/input/Makefile
@@ -10,6 +10,7 @@ input-core-y := input.o input-compat.o input-mt.o input-poller.o ff-core.o
 input-core-y += touchscreen.o touch-overlay.o
 
 obj-$(CONFIG_INPUT_FF_MEMLESS)	+= ff-memless.o
+obj-$(CONFIG_INPUT_POLLDEV)	+= input-polldev.o
 obj-$(CONFIG_INPUT_SPARSEKMAP)	+= sparse-keymap.o
 obj-$(CONFIG_INPUT_MATRIXKMAP)	+= matrix-keymap.o
 obj-$(CONFIG_INPUT_VIVALDIFMAP)	+= vivaldi-fmap.o
diff --git a/drivers/input/input-polldev.c b/drivers/input/input-polldev.c
new file mode 100644
index 000000000..9bf1c9aeb
--- /dev/null
+++ b/drivers/input/input-polldev.c
@@ -0,0 +1,362 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Generic implementation of a polled input device
+
+ * Copyright (c) 2007 Dmitry Torokhov
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/jiffies.h>
+#include <linux/slab.h>
+#include <linux/mutex.h>
+#include <linux/workqueue.h>
+#include <linux/module.h>
+#include <linux/input-polldev.h>
+
+MODULE_AUTHOR("Dmitry Torokhov <dtor@mail.ru>");
+MODULE_DESCRIPTION("Generic implementation of a polled input device");
+MODULE_LICENSE("GPL v2");
+
+static void input_polldev_queue_work(struct input_polled_dev *dev)
+{
+	unsigned long delay;
+
+	delay = msecs_to_jiffies(dev->poll_interval);
+	if (delay >= HZ)
+		delay = round_jiffies_relative(delay);
+
+	queue_delayed_work(system_freezable_wq, &dev->work, delay);
+}
+
+static void input_polled_device_work(struct work_struct *work)
+{
+	struct input_polled_dev *dev =
+		container_of(work, struct input_polled_dev, work.work);
+
+	dev->poll(dev);
+	input_polldev_queue_work(dev);
+}
+
+static int input_open_polled_device(struct input_dev *input)
+{
+	struct input_polled_dev *dev = input_get_drvdata(input);
+
+	if (dev->open)
+		dev->open(dev);
+
+	/* Only start polling if polling is enabled */
+	if (dev->poll_interval > 0) {
+		dev->poll(dev);
+		input_polldev_queue_work(dev);
+	}
+
+	return 0;
+}
+
+static void input_close_polled_device(struct input_dev *input)
+{
+	struct input_polled_dev *dev = input_get_drvdata(input);
+
+	cancel_delayed_work_sync(&dev->work);
+
+	if (dev->close)
+		dev->close(dev);
+}
+
+/* SYSFS interface */
+
+static ssize_t input_polldev_get_poll(struct device *dev,
+				      struct device_attribute *attr, char *buf)
+{
+	struct input_polled_dev *polldev = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%d\n", polldev->poll_interval);
+}
+
+static ssize_t input_polldev_set_poll(struct device *dev,
+				struct device_attribute *attr, const char *buf,
+				size_t count)
+{
+	struct input_polled_dev *polldev = dev_get_drvdata(dev);
+	struct input_dev *input = polldev->input;
+	unsigned int interval;
+	int err;
+
+	err = kstrtouint(buf, 0, &interval);
+	if (err)
+		return err;
+
+	if (interval < polldev->poll_interval_min)
+		return -EINVAL;
+
+	if (interval > polldev->poll_interval_max)
+		return -EINVAL;
+
+	mutex_lock(&input->mutex);
+
+	polldev->poll_interval = interval;
+
+	if (input->users) {
+		cancel_delayed_work_sync(&polldev->work);
+		if (polldev->poll_interval > 0)
+			input_polldev_queue_work(polldev);
+	}
+
+	mutex_unlock(&input->mutex);
+
+	return count;
+}
+
+static DEVICE_ATTR(poll, S_IRUGO | S_IWUSR, input_polldev_get_poll,
+					    input_polldev_set_poll);
+
+
+static ssize_t input_polldev_get_max(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	struct input_polled_dev *polldev = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%d\n", polldev->poll_interval_max);
+}
+
+static DEVICE_ATTR(max, S_IRUGO, input_polldev_get_max, NULL);
+
+static ssize_t input_polldev_get_min(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	struct input_polled_dev *polldev = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%d\n", polldev->poll_interval_min);
+}
+
+static DEVICE_ATTR(min, S_IRUGO, input_polldev_get_min, NULL);
+
+static struct attribute *sysfs_attrs[] = {
+	&dev_attr_poll.attr,
+	&dev_attr_max.attr,
+	&dev_attr_min.attr,
+	NULL
+};
+
+static struct attribute_group input_polldev_attribute_group = {
+	.attrs = sysfs_attrs
+};
+
+static const struct attribute_group *input_polldev_attribute_groups[] = {
+	&input_polldev_attribute_group,
+	NULL
+};
+
+/**
+ * input_allocate_polled_device - allocate memory for polled device
+ *
+ * The function allocates memory for a polled device and also
+ * for an input device associated with this polled device.
+ */
+struct input_polled_dev *input_allocate_polled_device(void)
+{
+	struct input_polled_dev *dev;
+
+	dev = kzalloc(sizeof(struct input_polled_dev), GFP_KERNEL);
+	if (!dev)
+		return NULL;
+
+	dev->input = input_allocate_device();
+	if (!dev->input) {
+		kfree(dev);
+		return NULL;
+	}
+
+	return dev;
+}
+EXPORT_SYMBOL(input_allocate_polled_device);
+
+struct input_polled_devres {
+	struct input_polled_dev *polldev;
+};
+
+static int devm_input_polldev_match(struct device *dev, void *res, void *data)
+{
+	struct input_polled_devres *devres = res;
+
+	return devres->polldev == data;
+}
+
+static void devm_input_polldev_release(struct device *dev, void *res)
+{
+	struct input_polled_devres *devres = res;
+	struct input_polled_dev *polldev = devres->polldev;
+
+	dev_dbg(dev, "%s: dropping reference/freeing %s\n",
+		__func__, dev_name(&polldev->input->dev));
+
+	input_put_device(polldev->input);
+	kfree(polldev);
+}
+
+static void devm_input_polldev_unregister(struct device *dev, void *res)
+{
+	struct input_polled_devres *devres = res;
+	struct input_polled_dev *polldev = devres->polldev;
+
+	dev_dbg(dev, "%s: unregistering device %s\n",
+		__func__, dev_name(&polldev->input->dev));
+	input_unregister_device(polldev->input);
+
+	/*
+	 * Note that we are still holding extra reference to the input
+	 * device so it will stick around until devm_input_polldev_release()
+	 * is called.
+	 */
+}
+
+/**
+ * devm_input_allocate_polled_device - allocate managed polled device
+ * @dev: device owning the polled device being created
+ *
+ * Returns prepared &struct input_polled_dev or %NULL.
+ *
+ * Managed polled input devices do not need to be explicitly unregistered
+ * or freed as it will be done automatically when owner device unbinds
+ * from * its driver (or binding fails). Once such managed polled device
+ * is allocated, it is ready to be set up and registered in the same
+ * fashion as regular polled input devices (using
+ * input_register_polled_device() function).
+ *
+ * If you want to manually unregister and free such managed polled devices,
+ * it can be still done by calling input_unregister_polled_device() and
+ * input_free_polled_device(), although it is rarely needed.
+ *
+ * NOTE: the owner device is set up as parent of input device and users
+ * should not override it.
+ */
+struct input_polled_dev *devm_input_allocate_polled_device(struct device *dev)
+{
+	struct input_polled_dev *polldev;
+	struct input_polled_devres *devres;
+
+	devres = devres_alloc(devm_input_polldev_release, sizeof(*devres),
+			      GFP_KERNEL);
+	if (!devres)
+		return NULL;
+
+	polldev = input_allocate_polled_device();
+	if (!polldev) {
+		devres_free(devres);
+		return NULL;
+	}
+
+	polldev->input->dev.parent = dev;
+	polldev->devres_managed = true;
+
+	devres->polldev = polldev;
+	devres_add(dev, devres);
+
+	return polldev;
+}
+EXPORT_SYMBOL(devm_input_allocate_polled_device);
+
+/**
+ * input_free_polled_device - free memory allocated for polled device
+ * @dev: device to free
+ *
+ * The function frees memory allocated for polling device and drops
+ * reference to the associated input device.
+ */
+void input_free_polled_device(struct input_polled_dev *dev)
+{
+	if (dev) {
+		if (dev->devres_managed)
+			WARN_ON(devres_destroy(dev->input->dev.parent,
+						devm_input_polldev_release,
+						devm_input_polldev_match,
+						dev));
+		input_put_device(dev->input);
+		kfree(dev);
+	}
+}
+EXPORT_SYMBOL(input_free_polled_device);
+
+/**
+ * input_register_polled_device - register polled device
+ * @dev: device to register
+ *
+ * The function registers previously initialized polled input device
+ * with input layer. The device should be allocated with call to
+ * input_allocate_polled_device(). Callers should also set up poll()
+ * method and set up capabilities (id, name, phys, bits) of the
+ * corresponding input_dev structure.
+ */
+int input_register_polled_device(struct input_polled_dev *dev)
+{
+	struct input_polled_devres *devres = NULL;
+	struct input_dev *input = dev->input;
+	int error;
+
+	if (dev->devres_managed) {
+		devres = devres_alloc(devm_input_polldev_unregister,
+				      sizeof(*devres), GFP_KERNEL);
+		if (!devres)
+			return -ENOMEM;
+
+		devres->polldev = dev;
+	}
+
+	input_set_drvdata(input, dev);
+	INIT_DELAYED_WORK(&dev->work, input_polled_device_work);
+
+	if (!dev->poll_interval)
+		dev->poll_interval = 500;
+	if (!dev->poll_interval_max)
+		dev->poll_interval_max = dev->poll_interval;
+
+	input->open = input_open_polled_device;
+	input->close = input_close_polled_device;
+
+	input->dev.groups = input_polldev_attribute_groups;
+
+	error = input_register_device(input);
+	if (error) {
+		devres_free(devres);
+		return error;
+	}
+
+	/*
+	 * Take extra reference to the underlying input device so
+	 * that it survives call to input_unregister_polled_device()
+	 * and is deleted only after input_free_polled_device()
+	 * has been invoked. This is needed to ease task of freeing
+	 * sparse keymaps.
+	 */
+	input_get_device(input);
+
+	if (dev->devres_managed) {
+		dev_dbg(input->dev.parent, "%s: registering %s with devres.\n",
+			__func__, dev_name(&input->dev));
+		devres_add(input->dev.parent, devres);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(input_register_polled_device);
+
+/**
+ * input_unregister_polled_device - unregister polled device
+ * @dev: device to unregister
+ *
+ * The function unregisters previously registered polled input
+ * device from input layer. Polling is stopped and device is
+ * ready to be freed with call to input_free_polled_device().
+ */
+void input_unregister_polled_device(struct input_polled_dev *dev)
+{
+	if (dev->devres_managed)
+		WARN_ON(devres_destroy(dev->input->dev.parent,
+					devm_input_polldev_unregister,
+					devm_input_polldev_match,
+					dev));
+
+	input_unregister_device(dev->input);
+}
+EXPORT_SYMBOL(input_unregister_polled_device);
diff --git a/drivers/input/keyboard/adc-keys.c b/drivers/input/keyboard/adc-keys.c
index f17532074..f86f0b3ac 100644
--- a/drivers/input/keyboard/adc-keys.c
+++ b/drivers/input/keyboard/adc-keys.c
@@ -29,6 +29,27 @@ struct adc_keys_state {
 	const struct adc_keys_button *map;
 };
 
+struct input_dev * joypad_input_g;
+EXPORT_SYMBOL(joypad_input_g);
+
+void rk_send_key_f_key_up(void)
+{
+	if (!joypad_input_g)
+		return;
+
+	input_report_key(joypad_input_g, BTN_MODE, 1);
+	input_sync(joypad_input_g);
+}
+
+void rk_send_key_f_key_down(void)
+{
+	if (!joypad_input_g)
+		return;
+
+	input_report_key(joypad_input_g, BTN_MODE, 0);
+	input_sync(joypad_input_g);
+}
+
 static void adc_keys_poll(struct input_dev *input)
 {
 	struct adc_keys_state *st = input_get_drvdata(input);
@@ -53,11 +74,21 @@ static void adc_keys_poll(struct input_dev *input)
 	if (abs(st->keyup_voltage - value) < closest)
 		keycode = 0;
 
-	if (st->last_key && st->last_key != keycode)
-		input_report_key(input, st->last_key, 0);
+	if (st->last_key && st->last_key != keycode) {
+		if (st->last_key == 316) {
+			rk_send_key_f_key_down();
+		} else {
+			input_report_key(input, st->last_key, 0);
+		}
+	}
 
-	if (keycode)
-		input_report_key(input, keycode, 1);
+	if (keycode) {
+		if (keycode == 316) {
+			rk_send_key_f_key_up();
+		} else {
+			input_report_key(input, keycode, 1);
+		}
+	}
 
 	input_sync(input);
 	st->last_key = keycode;
diff --git a/drivers/nvmem/rockchip-otp.c b/drivers/nvmem/rockchip-otp.c
index d88f12c53..29192f340 100644
--- a/drivers/nvmem/rockchip-otp.c
+++ b/drivers/nvmem/rockchip-otp.c
@@ -27,6 +27,7 @@
 #define OTPC_USER_CTRL			0x0100
 #define OTPC_USER_ADDR			0x0104
 #define OTPC_USER_ENABLE		0x0108
+#define OTPC_USER_QP			0x0120
 #define OTPC_USER_Q			0x0124
 #define OTPC_INT_STATUS			0x0304
 #define OTPC_SBPI_CMD0_OFFSET		0x1000
@@ -53,6 +54,7 @@
 #define SBPI_ENABLE_MASK		GENMASK(16, 16)
 
 #define OTPC_TIMEOUT			10000
+#define RK3568_NBYTES			2
 
 /* RK3588 Register */
 #define RK3588_OTPC_AUTO_CTRL		0x04
@@ -184,6 +186,73 @@ static int px30_otp_read(void *context, unsigned int offset,
 	return ret;
 }
 
+static int rk3568_otp_read(void *context, unsigned int offset, void *val,
+			   size_t bytes)
+{
+	struct rockchip_otp *otp = context;
+	unsigned int addr_start, addr_end, addr_offset, addr_len;
+	unsigned int otp_qp;
+	u32 data;
+	u8 *buf;
+	int ret, i = 0;
+
+	addr_start = rounddown(offset, RK3568_NBYTES) / RK3568_NBYTES;
+	addr_end = roundup(offset + bytes, RK3568_NBYTES) / RK3568_NBYTES;
+	addr_offset = offset % RK3568_NBYTES;
+	addr_len = addr_end - addr_start;
+
+	buf = kzalloc(array3_size(addr_len, RK3568_NBYTES, sizeof(*buf)),
+		      GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	ret = rockchip_otp_reset(otp);
+	if (ret) {
+		dev_err(otp->dev, "failed to reset otp phy\n");
+		return ret;
+	}
+
+	ret = rockchip_otp_ecc_enable(otp, true);
+	if (ret < 0) {
+		dev_err(otp->dev, "rockchip_otp_ecc_enable err\n");
+		return ret;
+	}
+
+	writel(OTPC_USE_USER | OTPC_USE_USER_MASK, otp->base + OTPC_USER_CTRL);
+	udelay(5);
+	while (addr_len--) {
+		writel(addr_start++ | OTPC_USER_ADDR_MASK,
+		       otp->base + OTPC_USER_ADDR);
+		writel(OTPC_USER_FSM_ENABLE | OTPC_USER_FSM_ENABLE_MASK,
+		       otp->base + OTPC_USER_ENABLE);
+
+		ret = rockchip_otp_wait_status(otp, OTPC_INT_STATUS, OTPC_USER_DONE);
+		if (ret < 0) {
+			dev_err(otp->dev, "timeout during read setup\n");
+			goto read_end;
+		}
+
+		otp_qp = readl(otp->base + OTPC_USER_QP);
+		if (((otp_qp & 0xc0) == 0xc0) || (otp_qp & 0x20)) {
+			ret = -EIO;
+			dev_err(otp->dev, "ecc check error during read setup\n");
+			goto read_end;
+		}
+
+		data = readl(otp->base + OTPC_USER_Q);
+		memcpy(&buf[i], &data, RK3568_NBYTES);
+
+		i += RK3568_NBYTES;
+	}
+
+	memcpy(val, buf + addr_offset, bytes);
+
+read_end:
+	writel(0x0 | OTPC_USE_USER_MASK, otp->base + OTPC_USER_CTRL);
+
+	return ret;
+}
+
 static int rk3588_otp_read(void *context, unsigned int offset,
 			   void *val, size_t bytes)
 {
@@ -282,6 +351,17 @@ static const struct rockchip_data rk3576_data = {
 	.reg_read = rk3588_otp_read,
 };
 
+static const char * const rk3568_otp_clocks[] = {
+	"usr", "sbpi", "apb", "phy",
+};
+
+static const struct rockchip_data rk3568_data = {
+	.size = 0x80,
+	.clks = rk3568_otp_clocks,
+	.num_clks = ARRAY_SIZE(rk3568_otp_clocks),
+	.reg_read = rk3568_otp_read,
+};
+
 static const char * const rk3588_otp_clocks[] = {
 	"otp", "apb_pclk", "phy", "arb",
 };
@@ -303,6 +383,10 @@ static const struct of_device_id rockchip_otp_match[] = {
 		.compatible = "rockchip,rk3308-otp",
 		.data = &px30_data,
 	},
+	{
+		.compatible = "rockchip,rk3568-otp",
+		.data = &rk3568_data,
+	},
 	{
 		.compatible = "rockchip,rk3576-otp",
 		.data = &rk3576_data,
diff --git a/drivers/power/supply/rk817_charger.c b/drivers/power/supply/rk817_charger.c
index 1251022eb..38def7306 100644
--- a/drivers/power/supply/rk817_charger.c
+++ b/drivers/power/supply/rk817_charger.c
@@ -681,7 +681,7 @@ static int rk817_bat_prop_writeable(struct power_supply *psy,
 }
 
 static const struct power_supply_desc rk817_bat_desc = {
-	.name = "rk817-battery",
+	.name = "battery",
 	.type = POWER_SUPPLY_TYPE_BATTERY,
 	.properties = rk817_bat_props,
 	.property_is_writeable	= rk817_bat_prop_writeable,
@@ -691,7 +691,7 @@ static const struct power_supply_desc rk817_bat_desc = {
 };
 
 static const struct power_supply_desc rk817_chg_desc = {
-	.name = "rk817-charger",
+	.name = "charger",
 	.type = POWER_SUPPLY_TYPE_USB,
 	.usb_types = BIT(POWER_SUPPLY_USB_TYPE_DCP) |
 		     BIT(POWER_SUPPLY_USB_TYPE_UNKNOWN),
diff --git a/include/linux/input-polldev.h b/include/linux/input-polldev.h
new file mode 100644
index 000000000..14821fd23
--- /dev/null
+++ b/include/linux/input-polldev.h
@@ -0,0 +1,58 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+#ifndef _INPUT_POLLDEV_H
+#define _INPUT_POLLDEV_H
+
+/*
+ * Copyright (c) 2007 Dmitry Torokhov
+ */
+
+#include <linux/input.h>
+#include <linux/workqueue.h>
+
+/**
+ * struct input_polled_dev - simple polled input device
+ * @private: private driver data.
+ * @open: driver-supplied method that prepares device for polling
+ *	(enabled the device and maybe flushes device state).
+ * @close: driver-supplied method that is called when device is no
+ *	longer being polled. Used to put device into low power mode.
+ * @poll: driver-supplied method that polls the device and posts
+ *	input events (mandatory).
+ * @poll_interval: specifies how often the poll() method should be called.
+ *	Defaults to 500 msec unless overridden when registering the device.
+ * @poll_interval_max: specifies upper bound for the poll interval.
+ *	Defaults to the initial value of @poll_interval.
+ * @poll_interval_min: specifies lower bound for the poll interval.
+ *	Defaults to 0.
+ * @input: input device structure associated with the polled device.
+ *	Must be properly initialized by the driver (id, name, phys, bits).
+ *
+ * Polled input device provides a skeleton for supporting simple input
+ * devices that do not raise interrupts but have to be periodically
+ * scanned or polled to detect changes in their state.
+ */
+struct input_polled_dev {
+	void *private;
+
+	void (*open)(struct input_polled_dev *dev);
+	void (*close)(struct input_polled_dev *dev);
+	void (*poll)(struct input_polled_dev *dev);
+	unsigned int poll_interval; /* msec */
+	unsigned int poll_interval_max; /* msec */
+	unsigned int poll_interval_min; /* msec */
+
+	struct input_dev *input;
+
+/* private: */
+	struct delayed_work work;
+
+	bool devres_managed;
+};
+
+struct input_polled_dev *input_allocate_polled_device(void);
+struct input_polled_dev *devm_input_allocate_polled_device(struct device *dev);
+void input_free_polled_device(struct input_polled_dev *dev);
+int input_register_polled_device(struct input_polled_dev *dev);
+void input_unregister_polled_device(struct input_polled_dev *dev);
+
+#endif
diff --git a/include/linux/of_gpio.h b/include/linux/of_gpio.h
index d0f66a5e1..5c4c7e1a3 100644
--- a/include/linux/of_gpio.h
+++ b/include/linux/of_gpio.h
@@ -17,8 +17,26 @@
 
 struct device_node;
 
+/*
+ * This is Linux-specific flags. By default controllers' and Linux' mapping
+ * match, but GPIO controllers are free to translate their own flags to
+ * Linux-specific in their .xlate callback. Though, 1:1 mapping is recommended.
+ */
+enum of_gpio_flags {
+        OF_GPIO_ACTIVE_LOW = 0x1,
+        OF_GPIO_SINGLE_ENDED = 0x2,
+        OF_GPIO_OPEN_DRAIN = 0x4,
+        OF_GPIO_TRANSITORY = 0x8,
+        OF_GPIO_PULL_UP = 0x10,
+        OF_GPIO_PULL_DOWN = 0x20,
+        OF_GPIO_PULL_DISABLE = 0x40,
+};
+
 #ifdef CONFIG_OF_GPIO
 
+extern int of_get_named_gpio_flags(const struct device_node *np,
+                const char *list_name, int index, enum of_gpio_flags *flags);
+
 extern int of_get_named_gpio(const struct device_node *np,
 			     const char *list_name, int index);
 
@@ -26,13 +44,30 @@ extern int of_get_named_gpio(const struct device_node *np,
 
 #include <linux/errno.h>
 
-/* Drivers may not strictly depend on the GPIO support, so let them link. */
 static inline int of_get_named_gpio(const struct device_node *np,
                                    const char *propname, int index)
 {
+        return -ENOSYS;
+}
+
+/* Drivers may not strictly depend on the GPIO support, so let them link. */
+static inline int of_get_named_gpio_flags(const struct device_node *np,
+		const char *list_name, int index, enum of_gpio_flags *flags)
+{
+	if (flags)
+		*flags = 0;
+
 	return -ENOSYS;
 }
 
 #endif /* CONFIG_OF_GPIO */
 
+static inline int of_get_gpio_flags(const struct device_node *np, int index,
+		      enum of_gpio_flags *flags)
+{
+	return of_get_named_gpio_flags(np, "gpios", index, flags);
+}
+
+//#endif /* CONFIG_OF_GPIO */
+
 #endif /* __LINUX_OF_GPIO_H */
diff --git a/include/linux/of_gpio_legacy.h b/include/linux/of_gpio_legacy.h
new file mode 100644
index 000000000..ce58afecb
--- /dev/null
+++ b/include/linux/of_gpio_legacy.h
@@ -0,0 +1,304 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * OF helpers for the GPIO API
+ *
+ * Copyright (c) 2007-2008  MontaVista Software, Inc.
+ *
+ * Author: Anton Vorontsov <avorontsov@ru.mvista.com>
+ */
+
+#ifndef __LINUX_OF_GPIO_H
+#define __LINUX_OF_GPIO_H
+
+#include <linux/compiler.h>
+#include <linux/gpio/driver.h>
+#include <linux/gpio.h>		/* FIXME: Shouldn't be here */
+#include <linux/of.h>
+
+struct device_node;
+
+/*
+ * This is Linux-specific flags. By default controllers' and Linux' mapping
+ * match, but GPIO controllers are free to translate their own flags to
+ * Linux-specific in their .xlate callback. Though, 1:1 mapping is recommended.
+ */
+enum of_gpio_flags {
+	OF_GPIO_ACTIVE_LOW = 0x1,
+	OF_GPIO_SINGLE_ENDED = 0x2,
+	OF_GPIO_OPEN_DRAIN = 0x4,
+	OF_GPIO_TRANSITORY = 0x8,
+	OF_GPIO_PULL_UP = 0x10,
+	OF_GPIO_PULL_DOWN = 0x20,
+};
+
+#ifdef CONFIG_OF_GPIO
+
+#include <linux/kernel.h>
+
+/*
+ * OF GPIO chip for memory mapped banks
+ */
+struct of_mm_gpio_chip {
+	struct gpio_chip gc;
+	void (*save_regs)(struct of_mm_gpio_chip *mm_gc);
+	void __iomem *regs;
+};
+
+static inline struct of_mm_gpio_chip *to_of_mm_gpio_chip(struct gpio_chip *gc)
+{
+	return container_of(gc, struct of_mm_gpio_chip, gc);
+}
+
+extern int of_get_named_gpio_flags(const struct device_node *np,
+		const char *list_name, int index, enum of_gpio_flags *flags);
+
+extern int of_mm_gpiochip_add_data(struct device_node *np,
+				   struct of_mm_gpio_chip *mm_gc,
+				   void *data);
+static inline int of_mm_gpiochip_add(struct device_node *np,
+				     struct of_mm_gpio_chip *mm_gc)
+{
+	return of_mm_gpiochip_add_data(np, mm_gc, NULL);
+}
+extern void of_mm_gpiochip_remove(struct of_mm_gpio_chip *mm_gc);
+
+#else /* CONFIG_OF_GPIO */
+
+#include <linux/errno.h>
+
+/* Drivers may not strictly depend on the GPIO support, so let them link. */
+static inline int of_get_named_gpio_flags(const struct device_node *np,
+		const char *list_name, int index, enum of_gpio_flags *flags)
+{
+	if (flags)
+		*flags = 0;
+
+	return -ENOSYS;
+}
+
+#endif /* CONFIG_OF_GPIO */
+
+/**
+ * of_gpio_named_count() - Count GPIOs for a device
+ * @np:		device node to count GPIOs for
+ * @propname:	property name containing gpio specifier(s)
+ *
+ * The function returns the count of GPIOs specified for a node.
+ * Note that the empty GPIO specifiers count too. Returns either
+ *   Number of gpios defined in property,
+ *   -EINVAL for an incorrectly formed gpios property, or
+ *   -ENOENT for a missing gpios property
+ *
+ * Example:
+ * gpios = <0
+ *          &gpio1 1 2
+ *          0
+ *          &gpio2 3 4>;
+ *
+ * The above example defines four GPIOs, two of which are not specified.
+ * This function will return '4'
+ */
+static inline int of_gpio_named_count(const struct device_node *np,
+				      const char *propname)
+{
+	return of_count_phandle_with_args(np, propname, "#gpio-cells");
+}
+
+/**
+ * of_gpio_count() - Count GPIOs for a device
+ * @np:		device node to count GPIOs for
+ *
+ * Same as of_gpio_named_count, but hard coded to use the 'gpios' property
+ */
+static inline int of_gpio_count(const struct device_node *np)
+{
+	return of_gpio_named_count(np, "gpios");
+}
+
+static inline int of_get_gpio_flags(const struct device_node *np, int index,
+		      enum of_gpio_flags *flags)
+{
+	return of_get_named_gpio_flags(np, "gpios", index, flags);
+}
+
+/**
+ * of_get_named_gpio() - Get a GPIO number to use with GPIO API
+ * @np:		device node to get GPIO from
+ * @propname:	Name of property containing gpio specifier(s)
+ * @index:	index of the GPIO
+ *
+ * Returns GPIO number to use with Linux generic GPIO API, or one of the errno
+ * value on the error condition.
+ */
+static inline int of_get_named_gpio(const struct device_node *np,
+                                   const char *propname, int index)
+{
+	return of_get_named_gpio_flags(np, propname, index, NULL);
+}
+
+/**
+ * of_get_gpio() - Get a GPIO number to use with GPIO API
+ * @np:		device node to get GPIO from
+ * @index:	index of the GPIO
+ *
+ * Returns GPIO number to use with Linux generic GPIO API, or one of the errno
+ * value on the error condition.
+ */
+static inline int of_get_gpio(const struct device_node *np, int index)
+{
+	return of_get_gpio_flags(np, index, NULL);
+}
+
+#endif /* __LINUX_OF_GPIO_H */
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * OF helpers for the GPIO API
+ *
+ * Copyright (c) 2007-2008  MontaVista Software, Inc.
+ *
+ * Author: Anton Vorontsov <avorontsov@ru.mvista.com>
+ */
+
+#ifndef __LINUX_OF_GPIO_H
+#define __LINUX_OF_GPIO_H
+
+#include <linux/compiler.h>
+#include <linux/gpio/driver.h>
+#include <linux/gpio.h>		/* FIXME: Shouldn't be here */
+#include <linux/of.h>
+
+struct device_node;
+
+/*
+ * This is Linux-specific flags. By default controllers' and Linux' mapping
+ * match, but GPIO controllers are free to translate their own flags to
+ * Linux-specific in their .xlate callback. Though, 1:1 mapping is recommended.
+ */
+enum of_gpio_flags {
+	OF_GPIO_ACTIVE_LOW = 0x1,
+	OF_GPIO_SINGLE_ENDED = 0x2,
+	OF_GPIO_OPEN_DRAIN = 0x4,
+	OF_GPIO_TRANSITORY = 0x8,
+	OF_GPIO_PULL_UP = 0x10,
+	OF_GPIO_PULL_DOWN = 0x20,
+};
+
+#ifdef CONFIG_OF_GPIO
+
+#include <linux/kernel.h>
+
+/*
+ * OF GPIO chip for memory mapped banks
+ */
+struct of_mm_gpio_chip {
+	struct gpio_chip gc;
+	void (*save_regs)(struct of_mm_gpio_chip *mm_gc);
+	void __iomem *regs;
+};
+
+static inline struct of_mm_gpio_chip *to_of_mm_gpio_chip(struct gpio_chip *gc)
+{
+	return container_of(gc, struct of_mm_gpio_chip, gc);
+}
+
+extern int of_get_named_gpio_flags(const struct device_node *np,
+		const char *list_name, int index, enum of_gpio_flags *flags);
+
+extern int of_mm_gpiochip_add_data(struct device_node *np,
+				   struct of_mm_gpio_chip *mm_gc,
+				   void *data);
+static inline int of_mm_gpiochip_add(struct device_node *np,
+				     struct of_mm_gpio_chip *mm_gc)
+{
+	return of_mm_gpiochip_add_data(np, mm_gc, NULL);
+}
+extern void of_mm_gpiochip_remove(struct of_mm_gpio_chip *mm_gc);
+
+#else /* CONFIG_OF_GPIO */
+
+#include <linux/errno.h>
+
+/* Drivers may not strictly depend on the GPIO support, so let them link. */
+static inline int of_get_named_gpio_flags(const struct device_node *np,
+		const char *list_name, int index, enum of_gpio_flags *flags)
+{
+	if (flags)
+		*flags = 0;
+
+	return -ENOSYS;
+}
+
+#endif /* CONFIG_OF_GPIO */
+
+/**
+ * of_gpio_named_count() - Count GPIOs for a device
+ * @np:		device node to count GPIOs for
+ * @propname:	property name containing gpio specifier(s)
+ *
+ * The function returns the count of GPIOs specified for a node.
+ * Note that the empty GPIO specifiers count too. Returns either
+ *   Number of gpios defined in property,
+ *   -EINVAL for an incorrectly formed gpios property, or
+ *   -ENOENT for a missing gpios property
+ *
+ * Example:
+ * gpios = <0
+ *          &gpio1 1 2
+ *          0
+ *          &gpio2 3 4>;
+ *
+ * The above example defines four GPIOs, two of which are not specified.
+ * This function will return '4'
+ */
+static inline int of_gpio_named_count(const struct device_node *np,
+				      const char *propname)
+{
+	return of_count_phandle_with_args(np, propname, "#gpio-cells");
+}
+
+/**
+ * of_gpio_count() - Count GPIOs for a device
+ * @np:		device node to count GPIOs for
+ *
+ * Same as of_gpio_named_count, but hard coded to use the 'gpios' property
+ */
+static inline int of_gpio_count(const struct device_node *np)
+{
+	return of_gpio_named_count(np, "gpios");
+}
+
+static inline int of_get_gpio_flags(const struct device_node *np, int index,
+		      enum of_gpio_flags *flags)
+{
+	return of_get_named_gpio_flags(np, "gpios", index, flags);
+}
+
+/**
+ * of_get_named_gpio() - Get a GPIO number to use with GPIO API
+ * @np:		device node to get GPIO from
+ * @propname:	Name of property containing gpio specifier(s)
+ * @index:	index of the GPIO
+ *
+ * Returns GPIO number to use with Linux generic GPIO API, or one of the errno
+ * value on the error condition.
+ */
+static inline int of_get_named_gpio(const struct device_node *np,
+                                   const char *propname, int index)
+{
+	return of_get_named_gpio_flags(np, propname, index, NULL);
+}
+
+/**
+ * of_get_gpio() - Get a GPIO number to use with GPIO API
+ * @np:		device node to get GPIO from
+ * @index:	index of the GPIO
+ *
+ * Returns GPIO number to use with Linux generic GPIO API, or one of the errno
+ * value on the error condition.
+ */
+static inline int of_get_gpio(const struct device_node *np, int index)
+{
+	return of_get_gpio_flags(np, index, NULL);
+}
+
+#endif /* __LINUX_OF_GPIO_H */
diff --git a/include/linux/pwm.h b/include/linux/pwm.h
index 8cafc483d..5ca7c9d8d 100644
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -140,6 +140,12 @@ static inline bool pwm_is_enabled(const struct pwm_device *pwm)
 	return state.enabled;
 }
 
+static inline void pwm_set_period(struct pwm_device *pwm, u64 period)
+{
+	if (pwm)
+		pwm->state.period = period;
+}
+
 static inline u64 pwm_get_period(const struct pwm_device *pwm)
 {
 	struct pwm_state state;
diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 5846b4bae..8e38fd57b 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -2392,8 +2392,13 @@ int hci_conn_check_link_mode(struct hci_conn *conn)
 		return 0;
 	}
 
-	if (hci_conn_ssp_enabled(conn) &&
-	    !test_bit(HCI_CONN_ENCRYPT, &conn->flags))
+	/* If Secure Simple Pairing is not enabled, then legacy connection
+	 * setup is used and no encryption or key sizes can be enforced.
+	 */
+	if (!hci_conn_ssp_enabled(conn))
+		return 1;
+
+	if (!test_bit(HCI_CONN_ENCRYPT, &conn->flags))
 		return 0;
 
 	return 1;
