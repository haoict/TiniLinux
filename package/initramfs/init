#!/bin/sh

#####
#
# TiniLinux initramfs init script (with A/B slot support)
#
#####
echo "[initramfs] Booting..."

# Mount pseudo filesystems
echo "[initramfs] Mounting pseudo filesystems..."
mount -t proc proc /proc
mount -t sysfs sys /sys
mount -t devtmpfs dev /dev
mount -t tmpfs tmpfs /run

# Parse kernel command line
for param in $(cat /proc/cmdline); do
    case $param in
        root=*)
            root="${param#root=}"
            ;;
        init=*)
            init="${param#init=}"
            ;;
        overlayfs=*)
            overlayfs="${param#overlayfs=}"
            ;;
        bootpart=*)
            bootpart="${param#bootpart=}"
            ;;
        squashfsimg=*)
            squashfsimg="${param#squashfsimg=}"
            ;;
        ab_boot=*)
            ab_boot="${param#ab_boot=}"
            ;;
    esac
done

# A/B slot management functions
AB_METADATA_PATH=""
get_ab_active_slot() {
    if [ -f "$AB_METADATA_PATH" ]; then
        . "$AB_METADATA_PATH"
        echo "$ACTIVE_SLOT"
    else
        echo "a"  # Default to slot A
    fi
}

increment_boot_count() {
    local slot=$1
    if [ -f "$AB_METADATA_PATH" ]; then
        . "$AB_METADATA_PATH"
        if [ "$slot" = "a" ]; then
            BOOT_COUNT_A=$((BOOT_COUNT_A + 1))
        else
            BOOT_COUNT_B=$((BOOT_COUNT_B + 1))
        fi
        # Write back metadata
        cat > "$AB_METADATA_PATH" <<ABEOF
# TiniLinux A/B Boot Slot Metadata
ACTIVE_SLOT=${ACTIVE_SLOT}
BOOT_COUNT_A=${BOOT_COUNT_A}
BOOT_COUNT_B=${BOOT_COUNT_B}
BOOT_SUCCESS_A=${BOOT_SUCCESS_A}
BOOT_SUCCESS_B=${BOOT_SUCCESS_B}
FALLBACK_ENABLED=${FALLBACK_ENABLED}
PENDING_SLOT=${PENDING_SLOT}
ABEOF
        sync
    fi
}

check_and_switch_slot() {
    if [ -f "$AB_METADATA_PATH" ]; then
        . "$AB_METADATA_PATH"
        
        # Check if there's a pending slot to switch to
        if [ -n "$PENDING_SLOT" ]; then
            echo "[initramfs] Switching to pending slot: $PENDING_SLOT"
            ACTIVE_SLOT=$PENDING_SLOT
            PENDING_SLOT=""
            if [ "$ACTIVE_SLOT" = "a" ]; then
                BOOT_COUNT_A=0
                BOOT_SUCCESS_A=0
            else
                BOOT_COUNT_B=0
                BOOT_SUCCESS_B=0
            fi
            # Save updated metadata
            cat > "$AB_METADATA_PATH" <<ABEOF
# TiniLinux A/B Boot Slot Metadata
ACTIVE_SLOT=${ACTIVE_SLOT}
BOOT_COUNT_A=${BOOT_COUNT_A}
BOOT_COUNT_B=${BOOT_COUNT_B}
BOOT_SUCCESS_A=${BOOT_SUCCESS_A}
BOOT_SUCCESS_B=${BOOT_SUCCESS_B}
FALLBACK_ENABLED=${FALLBACK_ENABLED}
PENDING_SLOT=${PENDING_SLOT}
ABEOF
            sync
        fi
        
        # Check for fallback condition (too many boot failures)
        local boot_count
        if [ "$ACTIVE_SLOT" = "a" ]; then
            boot_count=$BOOT_COUNT_A
        else
            boot_count=$BOOT_COUNT_B
        fi
        
        if [ "$FALLBACK_ENABLED" = "1" ] && [ "$boot_count" -ge "3" ]; then
            echo "[initramfs] Boot failed 3 times, falling back to other slot"
            if [ "$ACTIVE_SLOT" = "a" ]; then
                ACTIVE_SLOT=b
                BOOT_SUCCESS_A=0
            else
                ACTIVE_SLOT=a
                BOOT_SUCCESS_B=0
            fi
            # Save fallback metadata
            cat > "$AB_METADATA_PATH" <<ABEOF
# TiniLinux A/B Boot Slot Metadata
ACTIVE_SLOT=${ACTIVE_SLOT}
BOOT_COUNT_A=${BOOT_COUNT_A}
BOOT_COUNT_B=${BOOT_COUNT_B}
BOOT_SUCCESS_A=${BOOT_SUCCESS_A}
BOOT_SUCCESS_B=${BOOT_SUCCESS_B}
FALLBACK_ENABLED=${FALLBACK_ENABLED}
PENDING_SLOT=${PENDING_SLOT}
ABEOF
            sync
        fi
        
        echo "$ACTIVE_SLOT"
    else
        echo "a"
    fi
}

mkdir -p /newroot
INIT_UNIT=""

# if overlayfs is specified, set up OverlayFS
if [ -n "$overlayfs" ] && [ -n "$bootpart" ] && [ -n "$squashfsimg" ]; then
    echo "[initramfs] Setting up OverlayFS: lower from $bootpart/$squashfsimg, upper on $overlayfs"
    mkdir -p /mnt/boot /mnt/squashfsimg /mnt/overlayfs
    echo "[initramfs] Mounting boot partition $bootpart (read-only)..."
    mount -o ro "$bootpart" /mnt/boot || exec sh
    
    # Handle A/B slot selection if enabled
    ACTUAL_SQUASHFS="$squashfsimg"
    if [ "$ab_boot" = "1" ]; then
        echo "[initramfs] A/B boot enabled"
        # Mount overlay temporarily to access metadata
        mount -o rw "$overlayfs" /mnt/overlayfs || exec sh
        AB_METADATA_PATH="/mnt/overlayfs/ab-metadata"
        
        # Initialize metadata if it doesn't exist
        if [ ! -f "$AB_METADATA_PATH" ]; then
            echo "[initramfs] Initializing A/B metadata"
            mkdir -p /mnt/overlayfs
            cat > "$AB_METADATA_PATH" <<ABEOF
# TiniLinux A/B Boot Slot Metadata
ACTIVE_SLOT=a
BOOT_COUNT_A=0
BOOT_COUNT_B=0
BOOT_SUCCESS_A=1
BOOT_SUCCESS_B=0
FALLBACK_ENABLED=1
PENDING_SLOT=
ABEOF
            sync
        fi
        
        # Check for slot switch and fallback
        ACTIVE_SLOT=$(check_and_switch_slot)
        echo "[initramfs] Active slot: $ACTIVE_SLOT"
        
        # Increment boot count
        increment_boot_count "$ACTIVE_SLOT"
        
        # Determine which squashfs to use
        if [ "$ACTIVE_SLOT" = "b" ]; then
            ACTUAL_SQUASHFS="rootfs-b.squashfs"
        else
            ACTUAL_SQUASHFS="rootfs-a.squashfs"
        fi
        
        # Check if slot-specific image exists, fallback to legacy single image
        if [ ! -f "/mnt/boot/$ACTUAL_SQUASHFS" ]; then
            echo "[initramfs] Slot-specific image not found, using legacy single image"
            ACTUAL_SQUASHFS="$squashfsimg"
        fi
        
        umount /mnt/overlayfs
    fi
    
    echo "[initramfs] Mounting squashfs image /mnt/boot/$ACTUAL_SQUASHFS (read-only)..."
    mount -t squashfs -o loop,ro "/mnt/boot/$ACTUAL_SQUASHFS" /mnt/squashfsimg || exec sh
    echo "[initramfs] Mounting overlay partition $overlayfs (read-write)..."
    mount -o rw "$overlayfs" /mnt/overlayfs || exec sh

    # Check for rootfs resize flags
    if [ -f /mnt/overlayfs/overlay_upper/root/.resize-rootfs ]; then
        mv /mnt/overlayfs/overlay_upper/root/.resize-rootfs /mnt/overlayfs/overlay_upper/root/.resize-rootfs-done # fs-resize.sh won't know the flag, so we remove it here
        if [ -f /mnt/overlayfs/overlay_upper/root/.resize-romsfs ]; then
            echo "[initramfs] Found .resize-rootfs and .resize-romsfs flags - will boot into rootfs_romsfs resize mode"
            INIT_UNIT="--unit=fs-resize@rootfs_romsfs.service"
        else
            echo "[initramfs] Found .resize-rootfs flag - will boot into rootfs resize mode"
            INIT_UNIT="--unit=fs-resize@rootfs.service"
        fi
        echo "[initramfs] Unmounting overlay partition for resize..."
        umount $overlayfs || exec sh
        echo "[initramfs] Moving squashfs mount to /newroot..."
        mount --move /mnt/squashfsimg /newroot || exec sh
    else
        mkdir -p /mnt/overlayfs/overlay_upper /mnt/overlayfs/overlay_workdir
        echo "[initramfs] Mounting overlay filesystem to /newroot..."
        mount -t overlay overlay -o lowerdir=/mnt/squashfsimg,upperdir=/mnt/overlayfs/overlay_upper,workdir=/mnt/overlayfs/overlay_workdir /newroot || exec sh

        mkdir -p /newroot/boot /newroot/mnt/squashfsimg /newroot/mnt/overlayfs
        echo "[initramfs] Moving boot partition mount to /newroot/boot..."
        mount --move /mnt/boot /newroot/boot || exec sh
        echo "[initramfs] Moving squashfs mount to /newroot/mnt/squashfsimg..."
        mount --move /mnt/squashfsimg /newroot/mnt/squashfsimg || exec sh
        echo "[initramfs] Moving overlay mount to /newroot/mnt/overlayfs..."
        mount --move /mnt/overlayfs /newroot/mnt/overlayfs || exec sh

        # Check for romsfs resize flag
        if [ -f /newroot/root/.resize-romsfs ]; then
            echo "[initramfs] Found .resize-romsfs flag - will boot into romsfs resize mode"
            # /root/.resize-romsfs flag will be removed by fs-resize.sh after resizing
            INIT_UNIT="--unit=fs-resize@romsfs.service"
        else
            echo "[initramfs] No resize flags found - proceeding with normal boot"
            INIT_UNIT="" # normal boot
        fi
    fi
else # no OverlayFS, just mount root directly
    echo "[initramfs] No OverlayFS specified, using root=$root directly (r/w)."
    mount -o rw "$root" /newroot || exec sh

    # Check for rootfs resize flags
    if [ -f /newroot/root/.resize-rootfs ]; then
        echo "[initramfs] Found .resize-rootfs flag - will boot into rootfs resize mode"
        mv /newroot/root/.resize-rootfs /newroot/root/.resize-rootfs-done
        if [ -f /newroot/root/.resize-romsfs ]; then
            INIT_UNIT="--unit=fs-resize@rootfs_romsfs.service"
        else
            INIT_UNIT="--unit=fs-resize@rootfs.service"
        fi
    elif [ -f /newroot/root/.resize-romsfs ]; then
        echo "[initramfs] Found .resize-romsfs flag - will boot into romsfs resize mode"
        # /root/.resize-romsfs flag will be removed by fs-resize.sh after resizing
        INIT_UNIT="--unit=fs-resize@romsfs.service"
    else
        echo "[initramfs] No resize flags found - proceeding with normal boot"
        INIT_UNIT="" # normal boot
    fi
fi

# Mount runtime dirs for systemd
echo "[initramfs] Moving runtime directories mount to /newroot..."
mount --move /proc /newroot/proc
mount --move /sys /newroot/sys
mount --move /dev /newroot/dev
mount --move /run /newroot/run

echo "[initramfs] Init: ${init:-/sbin/init} $INIT_UNIT. Switching to real root..."
exec switch_root /newroot ${init:-/sbin/init} $INIT_UNIT || exec sh
